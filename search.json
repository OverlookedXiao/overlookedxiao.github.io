[{"title":"DRSSTC教程 第五章 - DRSSTC的功率电路设计","url":"/post/3df782a1.html","content":"## 前言\n\n⠀⠀本章将设计DRSSTC的强电部分：整流桥和逆变桥。\n\n## DRSSTC功率电路简介\n\n⠀⠀回顾我们在第二章给出的DRSSTC初级回路框图。\n\n![DRSSTC框图（未画出次级线圈）](https://image.overlooked.top/img/drsstc/five/1.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">DRSSTC框图（未画出次级线圈）</center><br>\n\n⠀⠀我们在第二章分析过，DRSSTC初级回路的组成包括了电流取样器（电流互感器）、过零比较器和功率放大器。\n\n⠀⠀在第四章中，我们分析并设计了前两个部分，它们是DRSSTC电路中的弱电部分。它们可以检测初级回路谐振电流的方向，输出+15V或-15V的电压。\n\n⠀⠀由于弱电部分的输出功率很小，所以我们需要用功率放大器将信号放大，再去驱动DRSSTC的初级串联谐振回路。\n\n⠀⠀功率放大器的功能就是将驱动电路输出的电压和电流放大。\n\n⠀⠀例如，驱动电路输出+15V的电压，放大器就应该输出+310V（假设）的电压提供给初级回路。驱动桥输出-15V的电压，放大器就会输出-310V的电压提供给初级回路。驱动电路不输出电压，放大器也不输出电压，不向初级回路提供能量。\n\n⠀⠀所以，DRSSTC的功率电路的任务是接受驱动电路的信号，然后输出+310V、-310V或0V的电压。\n\n![功率输出由市电先整流再逆变得到](https://image.overlooked.top/img/drsstc/five/2.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">功率输出由市电先整流再逆变得到</center><br>\n\n⠀⠀我们知道，DRSSTC是由市电供电的。市电是正弦波，电压的大小和方向是不断变化的。所以功率部分通常先将市电整流，将其方向确定。\n\n⠀⠀整流，就是将交流电变为直流电。经过整流后，市电的电压方向变得不再变化，变为直流电源。然后要输出±310V的电压，我们只需要利用桥式电路切换直流电源的两极就可以了。\n\n## 市电的电压是多少？\n\n⠀⠀市电的电压是220V。\n\n⠀⠀市电是正弦波交流电，它的电压每时每刻都在变化，而我们为什么说市电有220V？是指电压的平均值吗？\n\n⠀⠀显然，正负半周对称的市电的平均值是零。而我们说的的220V，是指市电的有效值为220V。有效值为220V的的含义是指，使用市电 与使用220V的恒压直流电源分别驱动电阻，在相同的时间，在同样的电阻负载上产生的热量是相等的。\n\n![两者的关系](https://image.overlooked.top/img/drsstc/five/3.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">两者的关系</center><br>\n\n⠀⠀市电的电压是按正弦规律波动的，时大时小。如果它的有效值为220V，那么它的最大值（图中蓝色曲线峰值）必定会大于220V。\n\n⠀⠀那么市电的峰值电压有多大呢？经过推导（积分）后可知，市电的峰值为有效值的根号二倍。也就是220V*1.41=310V。\n\n## 如何实现整流？\n\n⠀⠀刚才我们说过我们要将市电整流，下面我们来看看常见的整流电路。\n\n### 半波整流电路\n\n![半波整流电路](https://image.overlooked.top/img/drsstc/five/4.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">半波整流电路</center><br>\n\n⠀⠀上图为半波整流电路。R1为负载，D1为整流二极管，R2为交流电源内阻\n\n![输入电压（市电）与输出电压（红线）](https://image.overlooked.top/img/drsstc/five/5.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">输入电压（市电）与输出电压（红线）</center><br>\n\n⠀⠀可以看到，仅在220v正弦波的正半周，二极管导通，负载R1得到电流，在正弦波的负半周电路中无电流。所以负载得到的是断续的正弦半波。\n\n⠀⠀R1上的电压峰值即为市电的峰值电压，为220V*1.41=310V\n\n⠀⠀R1上的电压平均值为220V*0.45=99V\n\n⠀⠀所以，使用半波整流电路可以获得最大值为310V，但平均值很小的脉冲直流。\n\n![交流电源（市电）的输出电流](https://image.overlooked.top/img/drsstc/five/6.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">交流电源（市电）的输出电流</center><br>\n\n⠀⠀由于为R1为阻性负载，所以220V交流电源的输出电流也是正弦半波。\n\n### 电容滤波的半波整流电路\n\n![半波整流加滤波](https://image.overlooked.top/img/drsstc/five/7.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">半波整流加滤波</center><br>\n\n⠀⠀如图，我们在半波整流负载R1上并联一个2200uF的滤波电容C1。\n\n![输入电压（市电）与输出电压（绿线）](https://image.overlooked.top/img/drsstc/five/8.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">输入电压（市电）与输出电压（绿线）</center><br>\n\n⠀⠀并联电容后，半波整流电路不向负载供电时，由电容放电负责供电。所以R1两端的电压波形（绿色）得到了滤波，变的平缓。\n\n⠀⠀所以，上图的整流电路输出电压峰值仍然是310V，但是平均值却达到了226V，比不加滤波的半波整流电路大了一倍多，负载R1上的功率也增大了许多倍。\n\n![交流电源（市电）的输出电流](https://image.overlooked.top/img/drsstc/five/9.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">交流电源（市电）的输出电流</center><br>\n\n⠀⠀由于滤波电容的加入，整流二极管D1仅在交流电源的电压大于滤波电容上的电压时开启。\n\n⠀⠀二极管开启的时间在正弦波周期中对应的角度称为导通角。加入滤波电容后，二极管每次开启的时间都变小了，所以二极管的导通角变小。220V电源的输出电流变成了尖脉冲。\n\n![将滤波电容增大](https://image.overlooked.top/img/drsstc/five/10.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">将滤波电容增大</center><br>\n\n⠀⠀我们将C1增大，换成10000uF的滤波电容。\n\n![输入电压（市电）与输出电压（红线）](https://image.overlooked.top/img/drsstc/five/11.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">输入电压（市电）与输出电压（红线）</center><br>\n\n⠀⠀可以看到，与2200uF的滤波电容相比，10000uF的滤波电容使R1两端的电压（红线）滤波得更平缓，几乎成了一条直线。此时电路输出电压的平均值达到了284V，接近最大值310V。\n\n![交流电源（市电）的输出电流](https://image.overlooked.top/img/drsstc/five/12.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">交流电源（市电）的输出电流</center><br>\n\n⠀⠀我们再来看看交流电源的输出电流波形。由于滤波电容C1增大，整流二极管的导通角进一步减小，电源的输出电流波形进一步变尖。\n\n⠀⠀所以，在增大滤波电容后，虽然输出平均电压变高，但是电源的输出电流峰值也增大了一倍多，这会给整流二极管造成很大的压力。所以我们不应该把滤波电容加得过大。\n\n⠀⠀同时，增大输出的滤波电容也意味着滤波电容储存的能量会更多。在整流电路的负载发生短路故障时，滤波电容会将储存的能量快速释放，造成负载发生爆炸。所以在炸管的时候，更大的滤波电容就意味着声音更响~\n\n### 桥式整流电路\n\n⠀⠀半波整流电路只能利用交流电源的正半周来驱动负载，输出平均电压较低。而桥式整流电路可以利用交流电源的正负半周。\n\n![桥式整流电路](https://image.overlooked.top/img/drsstc/five/13.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">桥式整流电路</center><br>\n\n⠀⠀上图为我们的桥式整流电路。R1为负载，R2为电源内阻。电路使用了四个二极管来整流。\n\n⠀⠀在交流电源的正半周时，D1和D4导通，接通电路；在交流电源的负半周时，D2和D3导通，接通电路。\n\n![输出波形](https://image.overlooked.top/img/drsstc/five/14.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">输出波形</center><br>\n\n⠀⠀可以看到，由于交流电源的正、负半周均有二极管接通电路，负载R1上的电压变为了连续的正弦半波。\n\n⠀⠀桥式整流电路的输出电压峰值依然为220V*1.4=310V\n\n⠀⠀桥式整流电路的输出平均值变为了220V*0.9=198V，比半波整流电路大了一倍。\n\n![各种整流桥](https://image.overlooked.top/img/drsstc/five/15.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">各种整流桥</center><br>\n\n⠀⠀通常我们使用上图这样封装好的整流桥，代替四个二极管作为整流电路。整流桥有两个交流输入端和两个直流输出端，其内部由四个二极管组成。\n\n⠀⠀根据不同的电流大小，整流桥的尺寸也不同。大功率的整流桥（4A以上）通常需要加散热器。我们在选取整流桥的电流时应该留有两倍以上的余量。\n\n### 电容滤波的桥式整流电路\n\n![输出加入电容滤波的整流桥](https://image.overlooked.top/img/drsstc/five/16.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">输出加入电容滤波的整流桥</center><br>\n\n⠀⠀我们给桥式整流电路的输出加上滤波电容C1。\n\n![输出电压波形（红线）](https://image.overlooked.top/img/drsstc/five/17.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">输出电压波形（红线）</center><br>\n\n⠀⠀可以看到，同半波整流一样，加入滤波电容后的桥式整流输出电压峰值不变，而波形同样变的平缓，平均电压升高。图中的电路参数输出的平均电压为268V。\n\n⠀⠀所以在桥式整流电路中，增大滤波电容同样可以增大输出的平均电压。\n\n⠀⠀不过与半波整流中情况相似，滤波电容过大同样会使整流二极管的压力增大，也会使电路爆炸时的声音变大。\n\n⠀⠀`通常，220V 50Hz供电的全波整流电路的滤波电容可以取每瓦的输出功率0.5uF - 1uF。`\n\n⠀⠀每瓦0.5uF的输出电容时，整流电路的输出电压在280V-310V间波动，平均电压约为300V。\n\n⠀⠀每瓦1uF的输出电容时，整流电路的输出电压在260V-310V间波动，平均电压约为290V。\n\n⠀⠀当然，以上的计算结果适用于电流不变，或电流的变化频率远大于50Hz的负载。对于脉冲负载（例如灭弧频率几Hz的特斯拉线圈之类），应按照电容储能公式计算电压的波动值，选取合适的滤波电容大小。\n\n⠀⠀另外，整流电路中的`滤波电容应并联泄放电阻`。也就是在滤波电容两端并联一个大电阻（100K-1M）。否则在电路断开后，滤波电容上会一直存储数百伏的电压，人体触摸时将受到电击。\n\n### 倍压整流电路\n\n⠀⠀由于我们使用的220V电源峰值为310V，所以上述几个整流电路的输出电压峰值均为310V。那么，我们的整流电路输出电压可不可以更高呢？\n\n⠀⠀我们可以使用倍压整流电路。\n\n![二倍压电路](https://image.overlooked.top/img/drsstc/five/18.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">二倍压电路</center><br>\n\n⠀⠀上图为二倍压整流电路。\n\n⠀⠀假设输出空载，则交流电源的正半周时，电流通过D1将C1两端电压充至310V；交流电源的负半周时，电流通过D2将C2两端电压充至310V，故电路的空载输出电压可达620V。\n\n⠀⠀不过由于负载R1的存在，在每个半周电容充电结束后，R1都会将电容两端的电压放掉一部分。所以到了另一个半周另一个电容充好电后，两个电容的电压叠加起来便达不到620V。\n\n⠀⠀所以二倍压整流电路的带载输出电压达不到空载电压620V。\n\n![倍压电路输出电压（红线）](https://image.overlooked.top/img/drsstc/five/19.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">倍压电路输出电压（红线）</center><br>\n\n⠀⠀上图为二倍压电路输出波形。\n\n![另一种二倍压电路](https://image.overlooked.top/img/drsstc/five/20.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">另一种二倍压电路</center><br>\n\n⠀⠀当然二倍压电路还有另一种，如上图。\n\n![多倍压电路](https://image.overlooked.top/img/drsstc/five/21.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">多倍压电路</center><br>\n\n⠀⠀也有N倍压整流电路。这些电路通常用于直流高压发生器。由于DRSSTC用不到，所以这里不细讲，大家有兴趣可以自己分析。\n\n### 上电缓冲电路\n\n⠀⠀在桥式整流电路电路接通前，整流电路中的滤波电容两端的电压为零。而在整流电路直接接入市电后，市电在半个周期内就需要将滤波电容上的电压充到接近310V。\n\n⠀⠀所以对于较大的滤波电容，接通电路将产生巨大的充电电流，可能损坏整流二极管、烧蚀开关或引起跳闸。为此，我们应在市电输入整流桥时给电流提供缓冲。\n\n⠀⠀通常，滤波电容在100uF-1000uF的桥式整流电路，可以在电源输入串联NTC热敏电阻作为缓冲元件。\n\n![NTC电阻](https://image.overlooked.top/img/drsstc/five/22.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">NTC电阻</center><br>\n\n⠀⠀上图为NTC电阻，我们可以在许多开关电源的整流桥前见到它。NTC热敏电阻的温度越高，电阻越小。\n\n![将NTC串联到整流桥前](https://image.overlooked.top/img/drsstc/five/23.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">将NTC串联到整流桥前</center><br>\n\n⠀⠀缓冲电路如上图。将NTC电阻串联到整流电路的输入，电路接通市电后，NTC电阻处于室温，电阻较大，使滤波电容可以缓慢充电，避免了电流冲击。而经过一段时间后，由于NTC电阻的自身发热，其两端电阻迅速降低至接近短路，整流电路便可以正常的工作。\n\n![电容缓冲的缓冲电路](https://image.overlooked.top/img/drsstc/five/24.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电容缓冲的缓冲电路</center><br>\n\n⠀⠀对于更大的滤波电容（&gt;2200uF），我们可以使用多个NTC元件串并联作为输入缓冲，或者像上图这样，在输入使用无极电容电容C2（也可以用电阻或灯泡）限制滤波电容C1的充电电流。\n\n⠀⠀在电容C1通过C2缓慢充电至接近310V后，电压比较电路驱动继电器将限流元件C2短路，整流电路便可以加负载，开始工作。\n\n### 三相桥式整流电路\n\n⠀⠀三相交流电源有三根相线（火线）和一根零线。\n\n![三相电源的相电压](https://image.overlooked.top/img/drsstc/five/25.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">三相电源的相电压</center><br>\n\n⠀⠀如图为三相电源的三根相线分别对零线的电压波形。相线对零线的电压我们称之为相电压。可以看到三个相电压分别相差120°，有效值均为220V（峰值310V）。\n\n⠀⠀三相电源两根相线之间的电压称为线电压，有效值为380V。\n\n⠀⠀由于我们通常制作的DRSSTC（6KW以下）用不到三相动力电，所以这里只简单介绍一下三相桥式整流电路。\n\n![三相整流桥](https://image.overlooked.top/img/drsstc/five/26.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">三相整流桥</center><br>\n\n⠀⠀上图为三相桥式整流电路。输入为三相电源的三根相线，使用六个整流二极管。\n\n![三相整流桥的输出波形](https://image.overlooked.top/img/drsstc/five/27.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">三相整流桥的输出波形</center><br>\n\n⠀⠀这是三相桥式整流电路的输出电压。可以看到，即使电路中没有加滤波电容，它的输出电压也不会像单相整流电路那样降至零。\n\n⠀⠀所以，使用三相电供电时，我们更容易获得较高的平均电压。\n\n## 如何实现逆变？\n\n⠀⠀逆变与整流相反，是将直流电变成交流电。\n\n⠀⠀我们把市电输入整流电路，得到了约310V的直流电。那么，我们怎么把它变成可以在+310V和-310V之间交替变化的交流电，实现逆变呢？\n\n### 方式一：半桥电路\n\n![半桥电路](https://image.overlooked.top/img/drsstc/five/28.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">半桥电路</center><br>\n\n⠀⠀半桥电路如图。我们使用两个310V电源，和两个可以控制的开关，去驱动负载电阻R1。开关A和开关B我们称为一个桥臂。\n\n⠀⠀当开关A接通时，电源V1与负载R1接通，R1的电压为左负右正，我们设其为+310V。\n\n⠀⠀当开关B接通时，电源V2与负载R1接通，R1的电压为左正右负，也就是变为-310V。\n\n⠀⠀所以，交替打开A和B，我们的半桥电路就能交替输出正电压和负电压，实现了逆变。\n\n⠀⠀同时关闭A和B，半桥电路没有输出电压。\n\n⠀⠀同时打开A和B，则电源被桥臂短路，这种情况绝对不允许。\n\n### 方式二：全桥电路\n\n![全桥电路](https://image.overlooked.top/img/drsstc/five/29.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">全桥电路</center><br>\n\n⠀⠀全桥电路如图。在全桥电路中，我们只使用一个电源，并用了四个开关来驱动负载R1。全桥电路有开关A、B和开关C、D两个桥臂。\n\n⠀⠀当开关B、C接通时，R1的电压为左负右正，我们设其为+310V。\n\n⠀⠀当开关A、D接通时，R1的电压则为左正右负，也就是变为-310V。\n\n⠀⠀所以，交替打开开关BC和开关AD，我们的全桥电路就能交替输出正电压或负电压，实现了逆变。\n\n⠀⠀同时关闭开关ABCD，半桥电路没有输出电压。\n\n⠀⠀同时打开开关AB或开关CD，则电源被桥臂短路，这种情况绝对不允许。\n\n## 开关器件介绍\n\n⠀⠀上面介绍的桥式电路中，我们使用开关来切换输出电压。在实际电路中，我们的手速显然不能快到驱动开关来使电路正常工作。\n\n⠀⠀所以我们使用开关器件来代替桥式电路中的开关。\n\n⠀⠀常见的开关器件有晶闸管（SCR）、门极可关断晶闸管（GTO）、三极管（双极结型晶体管，BJT，电力三极管又称GTR），场效应管（FET，常用绝缘栅型场效应管MOSFET，简称MOS），IGBT（绝缘栅双极晶体管）和一些其他的新型器件。\n\n⠀⠀由于电力器件的发热较大，所以它们都被安装在散热片上。\n\n⠀⠀SCR和GTO的工作频率较低，通常用在工频变流电路中。而我们的DRSSTC的工作频率通常在20KHz以上，小功率的DRSSTC更是可达200KHz，所以在DRSSTC中，我们不使用它们作为开关器件，而考虑使用剩下的三种。\n\n### 三极管（BJT）\n\n⠀⠀这里以NPN型三极管为例。\n\n![NPN三极管作为开关使用](https://image.overlooked.top/img/drsstc/five/30.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">NPN三极管作为开关使用</center><br>\n\n⠀⠀三极管具有发射极e、基极b和集电极c。\n\n⠀⠀我们在三极管的b与e间加入电流信号ib，在c和e间便可获得经过三极管放大β倍的电流βib。所以，三极管实现的功能是用电流来控制电流，为电流控制型器件。\n\n⠀⠀作为开关器件使用时，我们使βib大于电路中的最大电流，则在三极管导通时，其理论上将流过的电流将大于实际的电流。三极管为了将电流扩大到理论值，便会完全导通（进入饱和区），两端的电压降至接近零，相当于c与e短路（实际上三极管两端还是有零点几伏的压降，所以会发热）。\n\n⠀⠀所以，给三极管的be间输入足够大的ib时，三极管的ce将会因导通而被短路，相当于开关闭合。而三极管没有输入电流时，ce间也无电流，相当于开关断开。\n\n⠀⠀我们可以用b、e作为控制端，`输入电流来控制三极管`，以c、e作为开关接入电路，将三极管当做可控制的开关使用。\n\n![BJT的输入输出特性](https://image.overlooked.top/img/drsstc/five/31.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">BJT的输入输出特性</center><br>\n\n⠀⠀三极管的输出-输入特性为一条直线。\n\n⠀⠀不过在DRSSTC中，我们通常不直接使用三极管作为开关元件，而使用更容易驱动的IGBT。\n\n### MOS管\n\n⠀⠀我们通常使用FET中的MOS型作为开关器件。MOS管在没有输入电压时没有导电沟道，也就是输入电压为零时不导通。\n\n⠀⠀在MOS管中，我们又通常使用内阻小且容易制造的NMOS管作为开关器件。所以这里以NMOS为例。\n\n![NMOS作为开关使用](https://image.overlooked.top/img/drsstc/five/32.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">NMOS作为开关使用</center><br>\n\n⠀⠀MOS管具有门极g、源极s和漏极d。\n\n⠀⠀我们在MOS的g与s间加入电压信号，在d和s间便可获得经过MOS放大的电流i。所以，MOS管实现的功能是用电压来控制电流，为电压控制型器件。\n\n![NMOS的输出曲线](https://image.overlooked.top/img/drsstc/five/33.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">NMOS的输出曲线</center><br>\n\n⠀⠀可以看到，NMOS管的输入-输出特性为一条曲线。在gs间电压达到3-4V时，MOS管开始导通。之后随着输入电压的上升，流过ds的电流接近指数上升。\n\n⠀⠀作为开关器件使用时，我们输入足够大的Ugs，使id大于电路中的最大电流，那么在MOS导通时，其理论上将流过的电流将大于实际的电流。MOS为了将电流扩大到理论值，便会完全导通，两端的电压降至接近零，相当于d与s短路（实际上MOS管有一定的内阻，所以会发热）。\n\n⠀⠀所以，给MOS的gs间输入足够大的电压（通常为10V以上）时，MOS的ds间将会因导通而被短路，相当于开关闭合。而MOS管没有足够的输入电压（3V以下）时无法导通，ds间无电流，相当于开关断开。\n\n⠀⠀我们可以用g、s作为控制端，`输入电压来控制MOS管`，以d、s作为开关接入电路，将MOS管当做可控制的开关使用。\n\n### IGBT（绝缘栅双极晶体管）\n\n![IGBT简化等效电路](https://image.overlooked.top/img/drsstc/five/34.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">IGBT简化等效电路</center><br>\n\n⠀⠀如上图，IGBT的简化等效电路可以看做是MOS和BJT的组合。\n\n⠀⠀MOS管是电压驱动型器件，驱动容易，且开关速度很快，但是电流通常较小。BJT由于具有电导调制效应，c与e间压降较低，通过电流的能力很大，但是为电流驱动的器件，驱动比较麻烦。\n\n⠀⠀`IGBT克服了两者的缺点，结合了两者的优点。IGBT为电压驱动型器件，驱动容易、开关速度较快。而IGBT的后级为BJT，所以它的通流能力也很强。`\n\n![IGBT作为开关使用](https://image.overlooked.top/img/drsstc/five/35.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">IGBT作为开关使用</center><br>\n\n⠀⠀由于IGBT的前级管是MOS，所以它具有门极g。由于它的后级是BJT，所以它有发射极e和集电极c。\n\n⠀⠀由于IGBT的前级管是MOS，所以我们在它的g与e间加入电压信号。之后IGBT内部的MOS管驱动BJT管，我们在c与e间便可获得经过IGBT放大的电流i。所以，IGBT实现的功能是用电压来控制电流，为电压控制型器件。\n\n⠀⠀通常，我们在DRSSTC中使用的IGBT，其内部有一个独立的续流二极管与IGBT的ce极反向并联。\n\n⠀⠀在DRSSTC的灭弧生效时，所有开关管均关闭，这个二极管便会为初级回路中的谐振电流续流。如果IGBT内部没有这个二极管（通过查阅datasheet确定），我们可以在其外部反向并联一个高耐压大电流的快恢复二极管。\n\n![IGBT的输入输出特性](https://image.overlooked.top/img/drsstc/five/36.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">IGBT的输入输出特性</center><br>\n\n⠀⠀可以看到，IGBT管的输入-输出特性与NMOS相似，为一条曲线。在ge间电压达到2-6V时，IGBT管开始导通。之后随着输入电压的上升，流过ce的电流接近指数上升。\n\n⠀⠀作为开关器件使用时，我们输入足够大的Uge，使坐标对应的ic大于电路中的实际最大电流，那么在IGBT导通时，其理论上将流过的电流将大于实际的电流。IGBT为了将电流扩大到理论值，便会完全导通，两端的电压降至接近零，相当于d与s短路（实际上IGBT管导通时ce间会有1V-4V的压降，所以会发热）。\n\n⠀⠀所以，给IGBT的ge间输入足够大的电压（通常为15V以上）时，IGBT的ce间将会因导通而被短路，相当于开关闭合。而IGBT管没有足够的输入电压（2V以下）时无法导通，ce间无电流，相当于开关断开。\n\n⠀⠀不过，为了让IGBT更快的关断，通常在关断时给ge间输入负压（例如-9V）。\n\n⠀⠀我们可以用g、e作为控制端，`输入电压来控制IGBT管`，以c、e作为开关接入电路，将IGBT管当做可控制的开关使用。\n\n## IGBT桥式电路\n\n⠀⠀SSTC的工作频率通常较高（200Khz-2MHz），且在SSTC中，初级回路的电流不大。所以在SSTC中我们普遍使用开关速度快的MOS管作为开关管。\n\n⠀⠀DRSSTC的工作频率通常在20Khz-300Khz，且在DRSSTC中，初级谐振回路电流很大，可达数百至上千安，所以在DRSSTC中普遍使用通流能力很强的IGBT作为开关管。\n\n⠀⠀由于本教程为DRSSTC教程，所以功率桥中的功率器件使用IGBT。实际上如果使用MOS管做功率桥，电路也基本是一样的。\n\n### 半桥电路\n\n⠀⠀我们说过，半桥电路需要使用两个电源和两个开关。但是我们整流获得的电源只有一个，怎么办呢？\n\n⠀⠀我们可以把一个电源分成两个。\n\n![IGBT半桥](https://image.overlooked.top/img/drsstc/five/37.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">IGBT半桥</center><br>\n\n⠀⠀如图为我们的IGBT半桥电路。我们将半桥电路中的开关换成了IGBT，两个电源换成了两个电容。两个IGBT组成一支桥臂，两个电容组成一支桥臂。\n\n⠀⠀假设电路的工作占空比为50%。当两个IGBT轮流开启时，C点的电压就会有50%的时间为310V,另外50%的时间为0V，所以C点电压的直流分量（也就是平均值）为155V。\n\n⠀⠀之后，这个155V的C点电压会通过负载R3对C1和C2充电。于是，C2和C3的中点电压也为155V。\n\n⠀⠀这就相当于C1和C2将310V的直流电源分成了两个155V的电源，这两个新的电源的内阻就是C1和C2的交流电阻。由于DRSSTC的工作频率较高，所以C1与C2的中点电压几乎不变化，保持在155V。\n\n⠀⠀所以，当A管导通时，R1两端的电压，也就是半桥电路的输出电压，为310V-155V=155V。当B管导通时，半桥电路的输出电压为0V-155V=-155V。也就是说，在占空比为50%时，半桥电路的输出电压峰值为电源电压的一半。\n\n⠀⠀显然，为了DRSSTC的初级谐振回路中电流能更快的振升，我们希望电路的输出电压高一些。所以通常我们在DRSSTC中使用输出电压更高的全桥电路。\n\n### OTL电路\n\n⠀⠀半桥电路中，我们使用了C1和C2两个电容组成桥臂。实际上，由于理想电源的内阻为零，C1和C2对于交流分量来说相当于直接并联，我们完全可以扔掉其中的一个。\n\n![OTL功放](https://image.overlooked.top/img/drsstc/five/38.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">OTL功放</center><br>\n\n⠀⠀扔掉一个桥臂电容后，电路变成了这样。\n\n⠀⠀C1将负责承担两个IGBT中点电压155V的直流分量，而让交流分量通过，所以其容量应该大一些，使容抗减小。\n\n⠀⠀虽然电路省去了一个电容，但是在实际电路中，我们又需要在电源上并联一个退耦电容，减小其高频内阻。而在半桥电路中，电容桥臂可以充当电源的退耦电容，所以可以不用额外再加一个退耦电容。\n\n⠀⠀OTL电路的输出电压峰值同样为电源电压的一半，所以我们也不使用。\n\n### 全桥电路\n\n![IGBT全桥](https://image.overlooked.top/img/drsstc/five/39.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">IGBT全桥</center><br>\n\n⠀⠀如图为我们的IGBT全桥电路。我们将全桥电路中的四个开关都换成了IGBT，电路有两个桥臂。\n\n⠀⠀BC管导通时，负载R3能获得310V的电压，而AD管导通时，输出电压则为-310V。\n\n⠀⠀所以，在同样的电源电压下，全桥电路的输出电压峰值比半桥电路提高了一倍，我们使用全桥电路来制作DRSSTC。\n\n![接入初级谐振回路](https://image.overlooked.top/img/drsstc/five/40.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">接入初级谐振回路</center><br>\n\n⠀⠀将全桥电路的电阻负载换成我们的初级线圈和谐振电容（实际上它们串联谐振时也是阻性负载），然后给电源加上退耦电容以减小其高频内阻，DRSSTC的全桥电路就完成啦。\n\n⠀⠀注意图中的IGBT是自带续流二极管的。前面提到过，如果你的IGBT没有则你需要自己并联一个。\n\n⠀⠀全桥是完成了，可是IGBT的g极还悬空着呢，我们需要利用g极驱动每个IGBT，让它们在合适的时间开启和关断。\n\n## 如何驱动IGBT？\n\n⠀⠀前面我们说过，我们需要用正电压去驱动IGBT的门极使它开启，用负压使它关断。\n\n⠀⠀IGBT的驱动电压通常在±20V以内（过高的驱动电压会将IGBT损坏），15V的驱动电压即可让它完全导通。\n\n⠀⠀而我们之前设计的驱动电路可以输出±15V的电压，那我们用它直接来驱动IGBT吧。\n\n⠀⠀直接驱动是不行的。可以发现，电路中桥臂上方的IGBT的e脚电压和下方的IGBT的e脚电压是不同的。我们需要驱动四个IGBT，显然我们不能它们的把e脚接在一起来驱动。\n\n⠀⠀由于IGBT的e脚电压不同，所以我们想到了用变压器来驱动IGBT。因为变压器的初级线圈和次级线圈是电气隔离的。\n\n⠀⠀这里的驱动变压器称为门极驱动变压器（GDT，Gate Drive Transformer）\n\n![错误接法示范](https://image.overlooked.top/img/drsstc/five/41.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">错误接法示范</center><br>\n\n⠀⠀我们把变压比为1:1的变压器的初级绕组接在驱动电路中，次级线圈直接接在IGBT的g与e试试。\n\n![驱动输出发生振荡](https://image.overlooked.top/img/drsstc/five/42.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">驱动输出发生振荡</center><br>\n\n⠀⠀可以看到，输入波形（红色）很正常，而IGBT的g与e间却产生了严重的振荡（绿色），这个现象称为振铃。\n\n⠀⠀振铃会让IGBT开启和关断发生错误，将其损坏。\n\n⠀⠀我们知道，IGBT的门极是有输入电容的，而我们的GDT实际上是存在漏感的。\n\n![等效电路](https://image.overlooked.top/img/drsstc/five/43.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">等效电路</center><br>\n\n⠀⠀所以我们用GDT驱动IGBT的等效电路就像上图一样。显然，我们的变压器漏感和IGBT的门极电容产生了串联谐振。\n\n⠀⠀IGBT的门极电容我们无法改变，所以为了减小振铃现象，我们需要减小GDT的漏感。\n\n⠀⠀所以，通常我们使用环形变压器（磁环）绕制GDT。环形变压器没有气隙，且绕组分布均匀，漏感很小。\n\n⠀⠀但是这么做还是不够的。我们需要在这个串联谐振回路中串联一个电阻，让谐振回路的电流流过电阻，以快速的消耗谐振回路中的能量。\n\n![GDT驱动IGBT需要加合适的电阻](https://image.overlooked.top/img/drsstc/five/44.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">GDT驱动IGBT需要加合适的电阻</center><br>\n\n⠀⠀所以，我们在GDT与IGBT间加入了一个电阻。\n\n![串入电阻后](https://image.overlooked.top/img/drsstc/five/45.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">串入电阻后</center><br>\n\n⠀⠀可以看到，加入了10Ω电阻后，IGBT门极的振荡衰减的很快，振铃现象得到了改善。但是在振荡的初期，IGBT门极的电压仍然高达40V。\n\n⠀⠀通常，在IGBT的g、e间电压超过30V后，IGBT的门极就可能被击穿而使器件损坏，所以，我们需要对IGBT加以保护。\n\n![加入稳压管来保护IGBT](https://image.overlooked.top/img/drsstc/five/46.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">加入稳压管来保护IGBT</center><br>\n\n⠀⠀我们给IGBT的门极并联两个反串的18V稳压管。反向串联的稳压管的钳位原理我们在第四章讲过，这里就不再说了。\n\n![IGBT的门极电压被稳压管钳位限制](https://image.overlooked.top/img/drsstc/five/47.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">IGBT的门极电压被稳压管钳位限制</center><br>\n\n⠀⠀可以看到，加入稳压管后，IGBT的门极电压（绿色）被钳位到了最高±18.7V，振铃现象基本消失。\n\n![加快IGBT的关断速度](https://image.overlooked.top/img/drsstc/five/48.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">加快IGBT的关断速度</center><br>\n\n⠀⠀门极电阻的引入，降低了门极电容的充放电速度，也就降低了门极电压的上升和下降速度，减慢了IGBT的开关速度。\n\n⠀⠀由于IGBT的关断过程通常本身就较慢，为了让IGBT可以更快速的关断，我们一般在这个电阻上并联一个二极管，电路如上图。二极管是为了加快IGBT门极电容放电，所以我们要注意它的方向，别接反。\n\n## 关于g极电阻的选取\n\n⠀⠀我们给IGBT的g极与GDT间加入了电阻来抑制振铃现象，那么这个电阻通常取多大呢？\n\n![IGBT小管](https://image.overlooked.top/img/drsstc/five/49.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">IGBT小管</center><br>\n\n⠀⠀对于IGBT小管（TO-247封装）制作的DRSSTC，**g极电阻**通常取4.7Ω-22Ω。\n\n⠀⠀对于频率比较高的应用场合，它应该适当取小一些，使IGBT的门极充放电较快，以增加IGBT的开关速度。\n\n⠀⠀对于频率比较低的DRSSTC，这个电阻则可以适当地取大一些，以降低门极充放电时的脉冲电流，降低驱动电路的压力。\n\n![IGBT半桥模块](https://image.overlooked.top/img/drsstc/five/50.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">IGBT半桥模块</center><br>\n\n⠀⠀对于IGBT模块，这个电阻通常为1-5Ω，具体可以参考模块的数据手册。\n\n## 如何用GDT驱动IGBT全桥？\n\n⠀⠀知道了单个IGBT怎样用GDT驱动后，我们用四个GDT去驱动我们的全桥电路不就可以嘛。\n\n⠀⠀不过，由于这四个GDT的初级绕组都由DRSSTC驱动板来驱动，所以我们通常让四个变压器共用一个初级绕组。\n\n⠀⠀怎么共用呢？将四个变压器合为一个变压器就可以啦。\n\n⠀⠀所以，经过合并的GDT通常是在一个磁环绕制的，有一个初级绕组和四个次级绕组的变压器。\n\n![GDT驱动全桥](https://image.overlooked.top/img/drsstc/five/51.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">GDT驱动全桥</center><br>\n\n⠀⠀就像上图这样，我们用一个GDT来驱动全桥。为了方便观看，全桥电路的两个桥臂被竖着画了。\n\n⠀⠀我们说过，在全桥电路中，我们应该让BC管和AD管这两组管子轮流导通。如果IGBT导通的顺序错误，轻则全桥不工作，重则将电源短路而导致IGBT爆炸。所以我们应该特别注意GDT与每个IGBT管的接法，确保在任一时刻，GDT对每一个IGBT输出的电压极性都正确。\n\n## 变压器的同名端\n\n![变压器示例](https://image.overlooked.top/img/drsstc/five/52.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">变压器示例</center><br>\n\n⠀⠀上图为一个具有两个绕组：红色绕组4匝，绿色绕组3匝的，绕在磁环上的变压器。\n\n⠀⠀同名端指的是绕线方向相同的两个绕组的起点（也可以说是终点），图中用黑点标明。\n\n⠀⠀变压器的同名端在任一时刻输出电压的极性相同。\n\n⠀⠀所以，我们把全桥中的BC管组的g极用变压器绕组的一端驱动，AD管组的g极用变压器绕组的另一端驱动。这样，组内的管子驱动电压极性相同，组间的管子驱动电压极性相反，全桥电路就能正常的工作了。\n\n![标出GDT次级绕组的同名端](https://image.overlooked.top/img/drsstc/five/53.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">标出GDT次级绕组的同名端</center><br>\n\n⠀⠀按照这样接，我们把全桥电路中GDT的同名端用黑点标出，给大家提供参考。\n\n⠀⠀与驱动板连接的GDT初级线圈，它的两根线接法是任意的。调试DRSSTC时，除了互换电流互感器的两根线，也可以互换这两根线来尝试让DRSSTC起振。\n\n⠀⠀不过在DRSSTC调试到可以起振后这两根线就不能互换位置了，否则会导致DRSSTC的相位颠倒，无法起振。\n\n## GDT驱动的缺点\n\n⠀⠀较大的IGBT模块，其ge间的电容为小管的数十倍。\n\n⠀⠀我们知道，为了快速的开关，GDT的工作波形都为矩形波。\n\n⠀⠀矩形波是含有丰富的高频分量的，用它驱动容性负载会产生很大的瞬时功率。所以，我们就需要用很大尺寸的GDT。\n\n![GDT传输的为脉冲功率](https://image.overlooked.top/img/drsstc/five/54.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">GDT传输的为脉冲功率</center><br>\n\n⠀⠀如图，GDT中的脉冲功率很大。\n\n⠀⠀我们知道，我们使用GDT的直接目的，是隔离各IGBT的驱动回路，做到使用同一个信号驱动全桥电路中的每个IGBT。 那么，我们用互相隔离的驱动电路来直接驱动每个IGBT不就可以了吗。\n\n⠀⠀没错，我们可以使用光耦来隔离信号。我们只需要制作四个独立的IGBT的驱动电路，分别用四组互相独立的电源（悬浮电源）供电，然后用四个光耦向它们传送每个IGBT的驱动信号就可以了。这种电路在DRSSTC中称为IGBT的悬浮驱动（隔离驱动）电路。\n\n⠀⠀GDT的另一个缺点，是只能使用在IGBT工作占空比接近50%的场合。\n\n⠀⠀我们分析过，占空比不等于50%的不对称驱动信号含有一定的直流成分。而GDT作为变压器，是无法向次级绕组耦合直流分量的。\n\n⠀⠀所以，在占空比不为50%时，GDT输出的信号会丢失它的直流分量，电压改变。\n\n![GDT不能很好的传输占空比过大或过小的驱动信号](https://image.overlooked.top/img/drsstc/five/55.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">GDT不能很好的传输占空比过大或过小的驱动信号</center><br>\n\n⠀⠀如上图，GDT在传输占空比为90%（红色）的±15V驱动信号时，其输出电压偏离了±15V。此时正电压已经不足5V，显然无法驱动器件。所以在占空比可能很大或很小，且需要电气隔离的场合，我们应该使用悬浮驱动。\n\n## 悬浮驱动的结构\n\n![悬浮驱动](https://image.overlooked.top/img/drsstc/five/56.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">悬浮驱动</center><br>\n\n⠀⠀悬浮驱动的结构包括隔离电源、光耦和驱动电路。\n\n⠀⠀隔离电源通常使用自制的多输出开关电源，当然我们也可以使用四只笨重的工频变压器来代替。\n\n⠀⠀光耦必须使用高速光耦，普通的PC817之类的光耦速度非常慢，无法使用。\n\n⠀⠀驱动电路，就是我们在第四章讲过的TC4421+MOS图腾柱。这里需要注意，IGBT是负压关断的，所以我们需要取隔离电源的中点电压作为一个输出，MOS图腾柱作为另一个输出，以输出双极性电压驱动IGBT。\n\n⠀⠀由于悬浮驱动只在大型DRSSTC和QCWDRSSTC的BUCK部分才可能用到，所以这里就不给出电路和分析了。本章将制作的DRSSTC功率较小，使用GDT驱动即可。\n\n## 常见功率管的型号及参数\n\n### NMOS功率管（TO-247封装）\n\n⠀⠀**三位数系列**\n|  型号   | 电压 | 电流 | 功率 | 内阻  | 输入电容 |\n| :-----: | :--: | :--: | :--: | :---: | :------: |\n| IRFP044 | 60V  | 58A  | 180W | 28mΩ  |  2.5nF   |\n| IRFP140 | 100V | 31A  | 180W | 55mΩ  |  1.3nF   |\n| IRFP150 | 100V | 42A  | 160W | 36mΩ  |  1.9nF   |\n| IRFP240 | 200V | 20A  | 150W | 180mΩ |  1.4nF   |\n| IRFP250 | 200V | 33A  | 180W | 85mΩ  |  2.6nF   |\n| IRFP260 | 200V | 50A  | 300W | 40mΩ  |  4.1nF   |\n| IRFP340 | 400V | 11A  | 150W | 550mΩ |  1.4nF   |\n| IRFP360 | 400V | 23A  | 280W | 200mΩ |  4.5nF   |\n| IRFP440 | 500V |  9A  | 150W | 850mΩ |  1.3nF   |\n| IRFP450 | 500V | 14A  | 190W | 400mΩ |  2.6nF   |\n| IRFP460 | 500V | 20A  | 280W | 270mΩ |  4.2nF   |\n\n⠀⠀**四位数系列**\n|    型号    | 电压 | 电流 | 功率 | 内阻  | 输入电容 |\n| :--------: | :--: | :--: | :--: | :---: | :------: |\n|  IRFP2907  | 75V  | 209A | 470W |  5mΩ  |   13nF   |\n|  IRFP3077  | 75V  | 200A | 340W |  3mΩ  |  9.4nF   |\n|  IRFP3306  | 60V  | 120A | 200W |  4mΩ  |  4.5nF   |\n|  IRFP3415  | 150V | 43A  | 200W | 42mΩ  |  2.4nF   |\n|  IRFP3703  | 30V  | 210A | 230W |  3mΩ  |  8.3nF   |\n|  IRFP3710  | 100V | 57A  | 200W | 25mΩ  |  3.0nF   |\n|  IRFP4004  | 40V  | 350A | 380W |  1mΩ  |  8.9nF   |\n|  IRFP4110  | 100V | 180A | 370W |  4mΩ  |  9.6nF   |\n|  IRFP4227  | 200V | 65A  | 330W | 21mΩ  |  4.6nF   |\n|  IRFP4229  | 250V | 44A  | 310W | 38mΩ  |  4.6nF   |\n|  IRFP4232  | 250V | 60A  | 430W | 30mΩ  |  7.3nF   |\n|  IRFP4242  | 300V | 46A  | 430W | 49mΩ  |  7.4nF   |\n|  IRFP4310  | 100V | 134A | 280W |  5mΩ  |  6.9nF   |\n|  IRFP4332  | 250V | 57A  | 360W | 29mΩ  |  5.9nF   |\n|  IRFP4368  | 75V  | 350A | 520W |  1mΩ  |  19.2nF  |\n|  IRFP4468  | 100V | 290A | 520W |  2mΩ  |  19.9nF  |\n|  IRFP4668  | 200V | 130A | 520W |  8mΩ  |  10.7nF  |\n|  IRFP4710  | 100V | 72A  | 190W | 14mΩ  |  6.2nF   |\n|  IRFP4868  | 300V | 70A  | 517W | 26mΩ  |  10.7nF  |\n|  IRFP7430  | 40V  | 404A | 366W |  1mΩ  |  14.2nF  |\n|  IRFP7530  | 60V  | 280A | 340W |  2mΩ  |  13.7nF  |\n| IRFP90N20D | 200V | 94A  | 580W | 23mΩ  |  6.0nF   |\n| IRFP15N60L | 600V | 15A  | 280W | 385mΩ |  2.7nF   |\n\n### NMOS功率管（TO-220封装）\n\n|   型号   | 电压 | 电流 | 功率 | 内阻  | 输入电容 |\n| :------: | :--: | :--: | :--: | :---: | :------: |\n|  IRF530  | 100V | 17A  | 70W  | 90mΩ  |  1.5nF   |\n|  IRF540  | 100V | 33A  | 130W | 44mΩ  |  2.0nF   |\n|  IRF640  | 200V | 18A  | 130W | 180mΩ |  1.3nF   |\n|  IRF840  | 500V |  8A  | 125W | 850mΩ |  1.0nF   |\n| IRF3205  | 55V  | 110A | 200W |  8mΩ  |  3.2nF   |\n| IRFB4110 | 100V | 180A | 370W |  4mΩ  |  9.6nF   |\n| IRFB4115 | 150V | 104A | 380W | 11mΩ  |  8.9nF   |\n|  75NF75  | 75V  | 75A  | 200W | 13mΩ  |  3.8nF   |\n\n> MOS管的耐压一般不高。\n\n### PMOS功率管\n\n|  型号   | 电压 | 电流 | 功率 | 内阻  |\n| :-----: | :--: | :--: | :--: | :---: |\n| IRF9140 | 100V | 18A  | 125W | 200mΩ |\n| IRF9150 | 100V | 25A  | 150W | 150mΩ |\n| IRF9540 | 100V | 23A  | 140W | 117mΩ |\n| IRF9630 | 200V |  7A  | 74W  | 800mΩ |\n| IRF9640 | 200V | 11A  | 125W | 500mΩ |\n\n> PMOS管的功率一般都较小。\n\n⠀⠀虽然上面花了好长时间查了一堆MOS管的参数，不过**制作DRSSTC我们是使用IGBT管的**。。。\n\n### IGBT小管\n\n|     型号      | 耐压  | 电流 | 脉冲电流 | 功率 | 开启时间 | 关断时间 | 输入电容 |\n| :-----------: | :---: | :--: | :------: | :--: | :------: | :------: | :------: |\n| FGA25N120ANTD | 1200V | 50A  |   90A    | 312W |  110ns   |  290nS   |  3.7nF   |\n|  IRG4PC50UD   | 600V  | 55A  |   220A   | 200W |   71nS   |  214nS   |  4.0nF   |\n|  FGA60N65SMD  | 650V  | 120A |   180A   | 600W |   65nS   |  154nS   |  2.9nF   |\n\n> （25N120是电磁炉IGBT，比较常见，但电流较小，不适合DRSSTC）\n\n⠀⠀虽然IGBT小管的参数看起来挺磕碜的，不过我们用起来感觉似乎还好。。那是因为在DRSSTC中这些小管都是被过载使用的。。\n\n⠀⠀额定电流55A的G4PC50UD，在100KHz的高频下使用时，datasheet给出的电流已经只剩下了几A。然而在DRSSTC中，我们通常会把它用到200-300A。。。\n\n⠀⠀怎么样，神奇吧。。所以大家还是多准备一些小管为好，因为用的太狠了它可能会爆掉。。。\n\n### IGBT模块\n\n|     型号     | 耐压  | 电流  | 脉冲电流 |  功率  |  开启时间  |  关断时间  | 输入电容 |\n| :----------: | :---: | :---: | :------: | :----: | :--------: | :--------: | :------: |\n| CM300DY-12H  | 600V  | 300A  |   600A   | 1100W  | 最大950nS  | 最大650nS  |   30nF   |\n| CM600DY-24A  | 1200V | 600A  |  1200A   | 3670W  | 最大850nS  | 最大1050nS |   94nF   |\n| CM2400HC-34H | 1700V | 2400A |  4800A   | 17800W | 最大2900nS | 最大3500nS |  210nF   |\n\n⠀⠀IGBT模块的参数很霸气吧。。它的每项参数后面都跟着好几个零，当然也包括延迟时间。。所以它更适合大规模的DRSSTC使用。。。\n\n⠀⠀小型DRSSTC的谐振频率都在100KHz以上，我们通常还是选择速度更快且稍微便宜点（炸多了也挺贵的）的IGBT小管。。。\n\n## 最终使用的电路\n\n![DRSSTC功率部分电路（未标IGBT型号）](https://image.overlooked.top/img/drsstc/five/57.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">DRSSTC功率部分电路（未标IGBT型号）</center><br>\n\n⠀⠀将整流电路和IGBT全桥放在一起，我们的DRSSTC功率部分的电路就确定啦。\n\n⠀⠀这样，我们就完成了DRSSTC的功率电路部分，将剩下所有的电路连接起来，我们就完成了DRSSTC的电路设计工作。\n\n> 通过这几篇文章，DRSSTC的相关知识已经介绍得差不多了，剩下的便是电路板的制作、焊接、调试等，之后不再阐述。\n","tags":["DRSSTC"],"categories":["电子DIY"]},{"title":"DRSSTC教程 第四章 - DRSSTC的驱动电路原理","url":"/post/11ad15b.html","content":"## 前言\n⠀⠀本章将逐步分析并设计DRSSTC的驱动电路。\n\n> 如果您对DRSSTC的驱动电路的工作原理毫无兴趣，只是想照着图做一块驱动电路板的话，本章的内容可能对您帮助不大。。。\n\n## DRSSTC驱动电路简介\n\n⠀⠀回顾我们在第二章中设计的SSTC电路框图。\n\n![次级反馈的SSTC](https://image.overlooked.top/img/drsstc/four/1.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">次级反馈的SSTC</center><br>\n\n⠀⠀当时我们分析过，在SSTC中，我们检测次级线圈谐振回路中电流方向，然后依照次级线圈中谐振电流方向去驱动它，便可以让次级线圈谐振，获得高电压。\n\n⠀⠀所以，在SSTC中，初级线圈通常仅用来向次级线圈耦合能量。\n\n⠀⠀在DRSSTC中，情况发生了变化。\n\n⠀⠀在DRSSTC中，初级线圈也有了谐振回路，里面的谐振电流还挺大的，有几百安。而且，这几百安的电流要从我们脆弱的功率管上流过。\n\n⠀⠀如果我们在DRSSTC中，还是像SSTC那样完全依靠次级回路的状态的去驱动初级线圈，而不去管初级回路的状态，那么我们初级回路中的开关管将会在几百安的谐振电流中发生硬开关，然后炸掉。。（硬开关的知识见第二章）\n\n⠀⠀所以，在DRSSTC中，我们的应该依靠初级回路的状态去驱动初级回路。\n\n![DRSSTC都是初级反馈](https://image.overlooked.top/img/drsstc/four/2.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">DRSSTC都是初级反馈</center><br>\n\n⠀⠀初级回路的状态，也就是初级回路中谐振电流的过零点。在DRSSTC中，我们把电流互感器接在了初级线圈，依靠测得的电流过零点让功率管去驱动初级谐振回路，实现软开关。\n\n⠀⠀所以，在DRSSTC中，我们没有没有精力再去管次级线圈中谐振电流的情况，也不直接驱动次级线圈。次级线圈只是被放在初级线圈上，默默的吸收初级谐振回路中的能量，然后将其以电弧释放。\n\n⠀⠀初级回路和次级回路的关系就像是电磁炉和锅。\n\n**本章的任务，是设计一个可以驱动DRSSTC的初级串联谐振回路的驱动电路。**\n\n⠀⠀驱动电路指什么？我们分析一下上面那张DRSSTC的框图。\n\n⠀⠀DRSSTC初级串联谐振回路的电流被取样后送入过零比较器，比较结果被放大后驱动初级回路。\n\n⠀⠀所以，驱动电路包括了电流取样器，过零比较器和功率放大器\n\n⠀⠀`电流取样器`：电流取样的任务，我们用电流互感器来完成。\n\n⠀⠀`过零比较器`：将电流互感器返回的信号与零作比较并输出。过零比较器是DRSSTC中的弱电部分，使用十几伏的电源供电。\n\n⠀⠀`功率放大器`：是一个高压（市电）供电的功率桥。它的任务是将过零比较器输出的信号电压进行功率放大后直接驱动串联谐振回路。它的电压高，电流大，是DRSSTC的强电部分。\n\n⠀⠀由于过零比较器和功率放大器（功率桥）通常不直接连接，所以我们将功率桥放在下一章去讲。\n\n⠀⠀所以，本章要研究的电路，就是输入接电流互感器，输出驱动功率桥的过零比较器！\n\n![电路设计](https://image.overlooked.top/img/drsstc/four/3.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电路设计</center><br>\n\n## 电流互感器\n\n⠀⠀电流互感器是一种特殊的变压器，其初级圈数很少，流过较大的待测交变电流。而它的次级圈数很多。\n\n![电流互感器](https://image.overlooked.top/img/drsstc/four/4.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电流互感器</center><br>\n\n⠀⠀根据变压器原理，电流互感器的次级电流很小，而且与初级电流成比例，这个比例等于电流互感器的匝数比。\n\n⠀⠀DRSSTC中，我们需要用过零比较器去检测初级线圈回路中的电流过零点。但是初级线圈中的电流通常有几百安，我们无法直接去检测这么大的电流。所以我们使用电流互感器将初级线圈中的电流先缩小后，再送入过零比较器检测。\n\n⠀⠀对于理想的电流互感器，其初级电流和次级电流在任一时刻均成比例。所以初级回路中的电流流过电流互感器后电流过零的时间并不会变化，是否使用电流互感器对过零检测的结果没有影响。\n\n## DRSSTC的电流互感器\n\n⠀⠀那么在DRSSTC中，我们用多大匝数比的电流互感器呢？\n\n⠀⠀DRSSTC中，初级线圈流过几百安的峰值电流，所以我们可以取1:1000的电流互感器。这样在初级回路中的电流达到几百安后，我们的驱动电路便会得到几百mA的输入电流供过零检测。\n\n⠀⠀电流互感器输出几百毫安的电流给我们的弱电部分，是不是有点太大呢？是的，几百mA的电流是有点大，但没办法。\n\n⠀⠀如果我们用**1:100000**的电流互感器，那么它在几百安的初级电流流过时，会输出几mA的电流给驱动电路检测，听起来是挺好的。\n\n⠀⠀但是别忘了初级回路中的电流并不是一开始就几百安的，它是DRSSTC电路起振后才一步步升高到这么大的。\n\n⠀⠀如果我们使用**1:100000**的电流互感器，那么在起振的初期，互感器按照比例反馈回的电流会很小，可能只有几十微安。这么小的电流无法被我们的电路检测（即使能检测，精度也能差），所以DRSSTC不能正常起振，也就无法工作。\n\n⠀⠀综上，我们使用**1:1000**的电流互感器。其中1匝的互感器初级绕组接入我们的DRSSTC初级谐振回路，而1000匝的绕组输出给我们的过零比较器。\n\n![电流互感器可以按比例缩小电流](https://image.overlooked.top/img/drsstc/four/5.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电流互感器可以按比例缩小电流</center><br>\n\n⠀⠀如上图，1:1000的电流互感器输入电流200A，则输出电流是输入电流的千分之一，为0.2A。\n\n## 如何进行过零检测？\n\n⠀⠀本章的任务是设计一个DRSSTC用的过零比较器，那么我们就开始设计吧。\n\n⠀⠀前面我们说过，对于正常连接的理想电流互感器，初级线圈的电流过零时，次级线圈输出的电流也过零。\n\n⠀⠀所以我们可以用第三章讲过的过零比较器电路来检测电流互感器输出电流的过零点，也就是初级谐振回路电流的过零点。\n\n![错误接法示范](https://image.overlooked.top/img/drsstc/four/6.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">错误接法示范</center><br>\n\n⠀⠀像上图这样，我们把电流互感器反馈回的信号接到过零比较器上，行吗？\n\n⠀⠀不行！电压比较器的输入阻抗很高，而电流互感器的输出禁止开路！这样接的话，开路的互感器的次级绕组会输出高压，把我们可爱的电压比较器击穿。\n\n![接入负载后电流互感器可以正常工作](https://image.overlooked.top/img/drsstc/four/7.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">接入负载后电流互感器可以正常工作</center><br>\n\n⠀⠀既然电流互感器的输出严禁开路，那么我们给它加一个电阻当负载不就行了嘛。\n\n![过零比较](https://image.overlooked.top/img/drsstc/four/8.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">过零比较</center><br>\n\n⠀⠀看一下接上电阻负载的结果。红色线是初级回路中那200安培的电流，绿色线是电流互感器的输出电压，蓝色线是过零比较器的输出电压。\n\n⠀⠀是不是很完美？过零比较器检测到了初级回路中电流的过零点，输出了正确的信号。\n\n![受到干扰时的过零比较器](https://image.overlooked.top/img/drsstc/four/9.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">受到干扰时的过零比较器</center><br>\n\n⠀⠀不过，开环工作的电压比较器容易受到外界干扰，导致输出波形在跳变点出现一些毛刺。这些高频的毛刺会对我们的DRSSTC正常工作造成影响，甚至损坏我们的器件。\n\n⠀⠀还记得我们讲过的滞回比较器吗？它具有一定的抗干扰能力。\n\n![引入滞回特性](https://image.overlooked.top/img/drsstc/four/10.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">引入滞回特性</center><br>\n\n⠀⠀于是我们果断的把我们的过零比较器引入了滞回特性，变成了滞回过零比较器。\n\n![可是滞回比较器的输出跳变点发生了滞后](https://image.overlooked.top/img/drsstc/four/11.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">可是滞回比较器的输出跳变点发生了滞后</center><br>\n\n⠀⠀使用滞回比较器后，虽然电路的抗干扰能力有一定的提升，但更大的问题来了，滞回比较器的滞回特性，使我们的过零检测结果滞后了。过零点检测的错误会导致功率管硬开关的出现。。\n\n⠀⠀为什么滞回比较器的输出会滞后呢？电流互感器输出的正弦波上升到滞回比较器的UT2后，输出才会变为高电平。电流互感器输出的正弦波下降到滞回比较器的UT1后，输出才会变为低电平。\n\n⠀⠀因为我们的R3太小，导致电流互感器输出的正弦波幅度太低，电压的上升到UT2的时间和下降到UT1的时间太慢了，所以滞回效应带来的延迟会比较明显。\n\n⠀⠀所以我们有一种改进方法，是将R3增大，例如增大到100Ω。这时电流互感器输出的电压会非常的大，电压的上升和下降就会非常迅速，我们再用滞回比较器检测其过零点，滞回效应带来的输出滞后影响就很小了。类似的方法在我们后面要讲的移相驱动中会用到。\n\n⠀⠀不过换用较大的R3后，R3的发热量也会很大（I²R）。\n\n⠀⠀所以我们又想出了一种方法：直接用稳压管钳位电流互感器的输出。\n\n![用稳压管代替电阻作为互感器负载](https://image.overlooked.top/img/drsstc/four/12.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">用稳压管代替电阻作为互感器负载</center><br>\n\n⠀⠀我们用一对反向串联的稳压管这个非线性负载来代替电阻R3。\n\n![反串稳压管的电阻-电压曲线](https://image.overlooked.top/img/drsstc/four/13.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">反串稳压管的电阻-电压曲线</center><br>\n\n⠀⠀假设稳压管的稳压值是5V。那么，两个反向串联的稳压管，两端电压的绝对值在5.7V以内时，其电阻几乎无穷大，而当两端超过5.7V之后，它的电阻就会迅速降低。\n\n⠀⠀所以，在±5.7V之内，相当于电流互感器的负载电阻R3非常大，它的输出电压便会变化的非常剧烈。而电流互感器输出的电压超过±5.7V后，又相当于R3变得非常小，限制了电流互感器的输出电压。\n\n![稳压管做负载时互感器的输入电流和输出电压曲线](https://image.overlooked.top/img/drsstc/four/14.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">稳压管做负载时互感器的输入电流和输出电压曲线</center><br>\n\n⠀⠀如上图，将一对反向串联的稳压管接到电压互感器的输出，由于稳压管的稳压特性，互感器的输出电压在超过±5.7V后几乎不会变化，即被钳位成矩形波。\n\n⠀⠀由于稳压管同样是（非线性）阻性负载，且它在大多数时间都导通，所以电流互感器的工作与之前使用电阻负载时相似：互感器的输出电压过零点，就是它的初级电流的过零点。只不过现在互感器输出的电压波形由正弦波变成了电压上升和下降都很快的矩形波\n\n![当滞回比较器遇到矩形波](https://image.overlooked.top/img/drsstc/four/15.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">当滞回比较器遇到矩形波</center><br>\n\n⠀⠀然后，我们接上过零滞回比较器\n\n![波形分析](https://image.overlooked.top/img/drsstc/four/16.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">波形分析</center><br>\n\n⠀⠀因为互感器现在的输出是矩形波，它在滞回比较器的UT2和UT1两个阈值电压附近上升和下降的很快，滞回比较器的滞回效应带来的输出滞后就被消除了。\n\n⠀⠀另外，我们可以使用具有滞回特性的施密特反相器7414来代替上图中的滞回比较器。\n\n![7414是输入带有滞回特性的非门](https://image.overlooked.top/img/drsstc/four/17.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">7414是输入带有滞回特性的非门</center><br>\n\n⠀⠀7414的工作特性与我们之前讲的NE555组成的施密特反相器相似。\n\n![7414工作波形，红色为输入，蓝色为输出](https://image.overlooked.top/img/drsstc/four/18.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">7414工作波形，红色为输入，蓝色为输出</center><br>\n\n⠀⠀上图为7414的工作波形图。输入电压在上升超过UT+后，7414输出转为低电平，输入电压在下降低于UT-后，7414输出转为高电平。\n\n![将滞回比较器换成7414](https://image.overlooked.top/img/drsstc/four/19.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">将滞回比较器换成7414</center><br>\n\n⠀⠀7414的输入电压范围为约为0V-5V，而我们的电流互感器输出电压在经过两个5V稳压管钳位后为±5V 。由于两个信号的电压不同，我们使用电容C2将电流的互感器输出耦合到7414的输入。\n\n⠀⠀我们用稳压管D3对7414的输入再次进行钳位，使7414的输入电压在它的允许范围内。电阻R4用于限制电流。\n\n![钳位的作用](https://image.overlooked.top/img/drsstc/four/20.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">钳位的作用</center><br>\n\n⠀⠀由图可知，D3钳位后7414的输入电压符合要求。\n\n![7414过零点检测电路仿真波形](https://image.overlooked.top/img/drsstc/four/21.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">7414过零点检测电路仿真波形</center><br>\n\n⠀⠀通过仿真可以看到电路可以准确的检测过零点。\n\n⠀⠀成功的设计出过零点检测后，我们便可以用它驱动功率桥了。\n\n## 如何驱动功率桥？\n\n⠀⠀由于功率桥部分的内容我们还没讲到，这里大家先简单了解一下。\n\n⠀⠀通常我们有两种方法驱动功率桥：变压器和悬浮驱动。悬浮驱动我们在之后的章节和再讲。\n\n⠀⠀变压器驱动所用的这个变压器我们一般叫门极驱动变压器，英文缩写GDT。\n\n⠀⠀简单的来说，给GDT提供+15V（假设）的电压，功率桥就会输出+100V（假设）的电压提供给初级回路。给GDT提供-15V的电压，功率桥就会输出-100V的电压提供给初级回路。不给GDT提供电压，功率桥就会关闭，不向初级回路提供能量。\n\n⠀⠀然而，想给GDT提供+15V的电压也不是很容易的。GDT要求有一定的输入电流。\n\n⠀⠀我们刚才设计的电路中，7414完成了过零检测的任务，但是它的输出电压只有5V，电流也只有数十mA，不能直接驱动GDT。我们要把7414的输出放大后，再驱动GDT。\n\n⠀⠀那么如何放大7414的输出？\n\n⠀⠀谈到放大，常见的三极管放大电路有三种共发射极、共集电极和共基极放大电路，我们用哪个呢？\n\n⠀⠀共基极放大电路没有电流放大能力，不符合要求。\n\n⠀⠀共发射极放大电路的电流输出能力不强，我们也不用。\n\n⠀⠀所以我们首先考虑共集电极放大电路，也就是射极跟随器。\n\n![共集电极放大器](https://image.overlooked.top/img/drsstc/four/22.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">共集电极放大器</center><br>\n\n⠀⠀就是这个电路。假设三极管的电流放大倍数β是100倍，那么我们就能用1mA的输入电流，得到101mA的输出电流啦。\n\n⠀⠀但是，这个射极跟随器的上拉的能力较强，下拉靠的是电阻，能力较弱。所以说，这个电路输出高电平的能力较强，而输出低电平的能力较弱。\n\n⠀⠀功率桥输出的电压是对称的，是因为功率桥内部的功率管是对称的。所以我们希望GDT能得到对称的信号去驱动功率桥。这就要求我们的驱动电路输出电流的能力是对称的。\n\n![甲乙类后级](https://image.overlooked.top/img/drsstc/four/23.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">甲乙类后级</center><br>\n\n⠀⠀所以我们试一试用互补输出级来放大。互补输出级是两个不同极性的射极跟随器的组合，所以它具有将输出上拉和下拉的能力，可以输出对称的电流。\n\n⠀⠀由于三极管基极和发射极间的电压大于0.7V才会使三极管导通。所以两个射极跟随器拼起来的话，输入就会有1.4V的电压区间两个三极管都不导通。在放大正弦波信号的时候，会造成失真。\n\n![交越失真示意图](https://image.overlooked.top/img/drsstc/four/24.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">交越失真示意图</center><br>\n\n⠀⠀可以看到，输入正弦波在±0.7V以内时，输出啥都没有，于是输出的正弦波就产生交越失真，变形了。\n\n⠀⠀所以在上面的电路图中加入了D1、D2、R1、R2，把两个三极管的基极电压分别垫高0.7V，然后交越失真现象就被消除啦。\n\n⠀⠀等等，刚才放大的是正弦波？我们的7414输出是方波诶。。方波的上升和下降时间很快，根本不用考虑交越失真。\n\n![图腾柱](https://image.overlooked.top/img/drsstc/four/25.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">图腾柱</center><br>\n\n⠀⠀于是我们果断的把那几个用来消除交越失真的元件给扔了，现在电路就只剩下这俩三级管了。这就是我们常说的图腾柱。\n\n![图腾柱的工作波形](https://image.overlooked.top/img/drsstc/four/26.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">图腾柱的工作波形</center><br>\n\n⠀⠀给图腾柱输入来自7414的信号，输出接上一个电阻负载。可以看到，虽然图腾柱的输出电流能力很强，但是它没有电压放大能力。它的输出电压比输入电压小0.7V，现在输出的高电平只有4.3V了。\n\n⠀⠀既然图中我们用了15V电源供电，我们就希望输出能达到15V，对吧。\n\n⠀⠀所以。。我们可以在图腾柱前加一级共射放大电路，先放大电压再扩大电流。。\n\n⠀⠀或者，使用我们的神器，**TC4421/ TC4422**芯片！\n\n![引脚图](https://image.overlooked.top/img/drsstc/four/27.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">引脚图</center><br>\n\n⠀⠀就是它，一个8脚的芯片。用它就可以代替我们的放大电路和图腾柱。\n\n![内部电路](https://image.overlooked.top/img/drsstc/four/28.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">内部电路</center><br>\n\n⠀⠀为什么说它是神器？因为它方便啊！我们看一下它的内部电路：共源放大电路+施密特反相器+MOS图腾柱。它带电压放大，还能把波形整形为方波，输出还带有电流放大。\n\n⠀⠀它的输出电流允许多大呢？峰值电流9A，持续电流2A。它较大的峰值电流特别适合推动我们的MOS或者IGBT门极这类容性负载。\n\n⠀⠀那么它怎么使用呢？\n\n⠀⠀1脚和8脚并联作为Vcc输入，供电电压最高允许20V。4脚和5脚并联接电路地。\n\n⠀⠀2脚是信号输入，6脚和7脚并联作为驱动输出。\n\n⠀⠀输入电压高于2V左右会被芯片视为输入高电平，低于1V左右会被芯片视为输入低电平。\n\n⠀⠀TC4422是同相放大，也就是输入为高电平时，输出也为高电平。\n\n⠀⠀TC4421则是反相放大，输出的电平总是与输入相反。\n\n⠀⠀另外还有TC442X系列的其他芯片，它们的功能大家可以自己查阅资料了解。\n\n![错误接法示范](https://image.overlooked.top/img/drsstc/four/29.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">错误接法示范</center><br>\n\n⠀⠀所以我们加一级TC4421（TC4421电源的输入省略了），放大来自7414的信号，然后去驱动GDT。\n\n⠀⠀然而，GDT这个变压器能这么驱动吗？不能。\n\n⠀⠀我们先来看看TC4421的输出波形。TC4421是单电源供电的，它输出的电压平均值大于零，也就是输出有直流分量。\n\n![TC4421的输出波形](https://image.overlooked.top/img/drsstc/four/30.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">TC4421的输出波形</center><br>\n\n⠀⠀如上图，GDT初级线圈的电感对于直流分量相当于短路，所以说，如果直接把变压器初级绕组接在TC4421的输出与地之间，就相当于把TC4421的输出给短路了，这会让TC4421烧坏。\n\n![两个用TC4421放大7414的输出，驱动GDT](https://image.overlooked.top/img/drsstc/four/31.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">两个用TC4421放大7414的输出，驱动GDT</center><br>\n\n⠀⠀所以，我们用两个TC4421共同驱动变压器，其中一个4421的输入先作反相。\n\n![占空比50%时，两个4421的输出没有直流分量](https://image.overlooked.top/img/drsstc/four/32.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">占空比50%时，两个4421的输出没有直流分量</center><br>\n\n⠀⠀于是电路便像上图这样，在任一时刻，总有一个TC4421输出电源电压（15V），而另一个输出0V，两个TC4421的输出互补。\n\n⠀⠀所以，变压器上的电压（蓝色线）为±15V，平均电压为0V（占空比=50%时）。\n\n![占空比50%占空比不为50%时](https://image.overlooked.top/img/drsstc/four/33.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">占空比50%占空比不为50%时</center><br>\n\n⠀⠀不过如果驱动电路的占空比并恰好等于50%，那么两个TC4421的输出会有一定的直流分量。\n\n⠀⠀理论上，谐振产生的正弦波电流是对称的，过零比较器输出的占空比等于50%。\n\n⠀⠀不过DRSSTC有一个起振的过程，在这个过程中GDT中会流过一定的直流分量，占空比也并不一定严格等于50%，所以为了防止TC4421损坏，我们还是给电路加一个隔直电容为好。\n\n![加入隔直电容](https://image.overlooked.top/img/drsstc/four/34.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">加入隔直电容</center><br>\n\n⠀⠀于是我们加上了隔直电容C1。当两个TC4421的输出带有直流分量时，C1上会积累相反的电压，使GDT中没有直流电流流过。\n\n⠀⠀于是，使用两个TC4421（也可以用TC4422），我们驱动了GDT。\n\n## 如何实现灭弧？(第一部分）\n\n⠀⠀在第三章中我们分析过，DRSSTC的驱动电路应具有灭弧的功能，以在DRSSTC的谐振电流振升到足够大后暂时使它停止工作。\n\n⠀⠀所以，我们的驱动电路应该有一个灭弧信号输入。在灭弧信号为高电平时，驱动电路使DRSSTC工作，而灭弧信号为低电平时，驱动电路停止DRSSTC的工作。\n\n⠀⠀前面我们设计的驱动电路可以让DRSSTC好好的工作。那么，如何让它停止工作呢？\n\n⠀⠀我们可以在灭弧信号高电平时，允许驱动电路输出矩形波去驱动GDT，而在灭弧信号低电平时，禁止驱动电路对GDT输出电流。\n\n![加入两个与门用来实现灭弧功能的驱动电路](https://image.overlooked.top/img/drsstc/four/35.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">加入两个与门用来实现灭弧功能的驱动电路</center><br>\n\n⠀⠀所以像上图这样，我们在电路中加入两个与门来控制驱动信号的通断。与门的一端输入灭弧信号，而另一端输入原本将驱动TC4421的信号。\n\n⠀⠀当灭弧信号为高电平时，与门的输出等于输入，允许电路输出信号给TC4421。\n\n⠀⠀当灭弧信号为低电平时，与门的输出为低电平，两个TC4421的输入便为低电平，输出均为高电平，GDT中无电流流过，DRSSTC停振。\n\n⠀⠀我们让灭弧信号为低电平后DRSSTC就会因驱动信号被切断而停振。那么，在灭弧信号再次转为高电平后，DRSSTC还会起振吗？\n\n## DRSSTC如何起振？\n\n⠀⠀在灭弧信号上升沿之后，DRSSTC会试图起振。\n\n![标出一些电路节点以分析电路](https://image.overlooked.top/img/drsstc/four/36.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">标出一些电路节点以分析电路</center><br>\n\n⠀⠀我们给电路中的一些节点标号，然后来分析一下电路。\n\n⠀⠀由于A为B经过U5A反相后的结果，所以在任一时刻，A与B的电平都相反。\n\n⠀⠀在灭弧信号低电平时，两个与门关闭，输出C和D为低电平，所以两个TC4421的输出E和F均为高电平，GDT中没有电流。\n\n⠀⠀当灭弧信号变为高电平后，与门接通电路，C点电压等于A点电压，D点电压等于B点电压。\n\n⠀⠀而任一时刻，A与B的电平都相反，所以C点的电平在灭弧信号变为高电平后，变为与D点相反。由于两个TC4421的输出E和F分别为C和D反相后的结果，此时两个TC4421的输出电平相反。\n\n⠀⠀所以，灭弧信号变为高电平后，两个TC4421的输出由全高变为了一高一低。这会产生一个15V的脉冲，通过耦合电容C1加在GDT的初级。GDT会驱动功率桥，向谐振回路提供一个电压。\n\n⠀⠀于是谐振回路中产生电流，开始发生振荡。振荡电流流过电流互感器T1后，经过过零检测和功率放大，驱动GDT，GDT又驱动功率桥，功率桥继续驱动谐振回路，向谐振回路中补充电流...电路形成了正反馈，可以持续振荡。\n\n⠀⠀当然，正反馈的形成前提，是电流互感器的相位正确。如果电流互感器接反了，则电路不能形成正反馈，无法起振。此时我们可以将电流互感器两根线互换，DRSSTC便可以起振。\n\n## 如何实现灭弧？（第二部分）\n\n⠀⠀我们再来看看我们上面设计的带灭弧的DRSSTC的工作过程。\n\n![起振和灭弧](https://image.overlooked.top/img/drsstc/four/37.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">起振和灭弧</center><br>\n\n⠀⠀灭弧信号从低电平升到高电平，电路起振，谐振回路中的电流上升，嗯，挺好的。\n\n⠀⠀灭弧信号保持高电平，电路一直振荡，嗯，挺好的。\n\n⠀⠀灭弧信号从高电平降到低电平，驱动电路中的与门将信号切断，停止驱动GDT，于是，功率桥中的功率管关断，电路停振。\n\n⠀⠀嗯。。挺。。什么？在谐振电流最大的时候，功率管竟然直接关断了？这是明目张胆的硬开关嘛！功率管会爆掉的。\n\n⠀⠀灭弧信号是外部电路产生的信号，与驱动电路并不相关。所以它转为低电平的时间是不确定的。\n\n⠀⠀如果我们在灭弧信号转为低电平后就立刻停止DRSSTC的工作，就会有一定的概率使功率管在谐振电流不为零的时刻直接关断，也就是硬关断。\n\n⠀⠀如果硬关断刚好发生在初级回路中电流振升到峰值时，功率管很可能会损坏。\n\n⠀⠀那么，如何避免灭弧导致的硬关断的发生呢？\n\n⠀⠀我们知道，DRSSTC自身的工作是软开关的。它总是在谐振回路中的电流过零时开启和关闭它的功率管。所以，我们只要让灭弧引起的功率管关闭也发生在谐振回路中的电流过零时刻，就可以避免硬关断了。\n\n⠀⠀为此，我们需要制作一个“灭弧同步电路”，把输入的灭弧信号与谐振回路中的电流过零时刻“同步”，用同步后的灭弧信号给DRSSTC灭弧。\n\n⠀⠀用什么同步呢？\n\n⠀⠀我们知道，谐振回路中的电流过零时，过零比较器翻转，在高低电平之间切换一次。所以，谐振回路中的电流过零时刻也就是过零比较器输出产生上升沿和下降沿的时刻。\n\n⠀⠀所以，我们可以用边沿触发的触发器来制作灭弧同步电路，同步灭弧信号与过零信号。\n\n![7474符号图](https://image.overlooked.top/img/drsstc/four/38.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">7474符号图</center><br>\n\n⠀⠀上图是D触发器74LS74。它有输入、时钟（上升沿）输入、异步（复位、置位）输入、同相输出和反相输出。下面所说的输出都是指7474的同相输出。\n\n⠀⠀D触发器所实现的功能非常简单：存储一位二进制数字。\n\n⠀⠀每当7474监测到时钟输入产生上升沿，它的输出电平都会立刻变为为此刻的输入电平（高电平或低电平）。而在其他时刻，7474的输出保持不变，也就是存储了上次的输入。\n\n⠀⠀7474的异步操作为低电平有效。异步复位输入为低电平时，即使时钟没有输入上升沿，7474也强制将输出变为低电平（0）；异步置位输入为低电平时，即使时钟没有输入上升沿，7474也强制将输出变为高电平（1）。\n\n⠀⠀异步操作结束（异步操作输入返回高电平）后，7474的输出同样保持操作后的电平。\n\n![错误接法](https://image.overlooked.top/img/drsstc/four/39.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">错误接法</center><br>\n\n⠀⠀那么，我们像上图这样，把灭弧输入连接到灭弧器，把灭弧输出连接到驱动电路中的与门输入初级回路电流的过零信号作为D触发器的时钟可以吗？\n\n⠀⠀上图这样接，灭弧输出的改变的确可以同步于初级回路的电流过零点。也就是说，即使输入的灭弧信号变为低电平，只有在过零信号产生上升沿，初级回路电流过零时，灭弧输出才会变为低电平。于是DRSSTC在初级回路电流为零时停振。避免了硬开关的出现。\n\n⠀⠀上面这个接法看起来很完美，但是实际上这样接的话DRSSTC就没法起振了。\n\n⠀⠀DRSSTC停振之后，初级回路的电流终将消失，然后就没有过零信号去更新灭弧输出了。于是在DRSSTC停振后即使你的灭弧输入变为高电平，灭弧输出也无法改变，与门始终无法开启，DRSSTC无法起振。\n\n⠀⠀由于DRSSTC停振后就没有过零信号可以作为时钟来改变D触发器的输出，所以我们只能将灭弧信号作为D触发器的异步信号输入。\n\n⠀⠀异步操作的特点是不需要时钟。这样即使在DRSSTC停振后的任意时刻，灭弧输入也能重新使灭弧输出变为高电平，从而使DRSSTC起振。\n\n![灭弧-过零同步电路](https://image.overlooked.top/img/drsstc/four/40.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">灭弧-过零同步电路</center><br>\n\n⠀⠀所以我们把灭弧信号接在D触发器的异步置位端。由于异步置位为低电平有效，我们将灭弧信号用7414反相后输入。D触发器的输入接地，始终为零。\n\n⠀⠀当灭弧输入变为高电平时，D触发器立刻被异步置位，使输出变为高电平，DRSSTC起振。灭弧输入在高电平期间，D触发器始终被强行置位，输出保持高电平。\n\n⠀⠀而灭弧信号变为低电平后，由于D触发器的记忆，灭弧输出仍将保持高电平。\n\n⠀⠀直到过零输入产生上升沿，也就是初级谐振回路电流过零，D触发器的输出才更新为它的输入：零。于是此时灭弧输出变为低电平，DRSSTC的功率管软关断。\n\n⠀⠀当灭弧信号再次变为高电平时，D触发器再次被异步置位，输出立刻变为高电平，DRSSTC再次起振。\n\n![同步电路的作用演示](https://image.overlooked.top/img/drsstc/four/41.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">同步电路的作用演示</center><br>\n\n⠀⠀如图，灭弧同步电路可以使灭弧信号保持高电平，直到初级回路电流过零。\n\n⠀⠀我们再考虑一个问题，如果上一次灭弧输入高电平，DRSSTC没有成功起振会怎么样？\n\n⠀⠀灭弧输入高电平，就会使D触发器异步置位，灭弧输出变为高电平。\n\n⠀⠀前面我们分析过，D触发器的灭弧输出想重新变为低电平，需要输入的过零信号产生上升沿。没有成功起振，过零比较器就没有产生上升沿。于是D触发器也不曾被过零信号置零。\n\n⠀⠀所以，如果电路没有起振，即使灭弧输入回到了低电平，D触发器的灭弧输出也会保持高电平不变。在灭弧输入再次变为高电平时，D触发器的灭弧输出依旧是高电平。\n\n⠀⠀前面我们分析过，DRSSTC的起振是靠灭弧信号从低电平变为高电平后驱动电路在GDT中产生一个脉冲引发正反馈而实现的。\n\n⠀⠀如果DRSSTC的灭弧信号一直保持高电平，它显然无法起振。\n\n⠀⠀所以，我们需要增加一个电路，使DRSSTC没有起振时，D触发器可以复位，以尝试在下一个灭弧周期起振。\n\n⠀⠀于是，我们可以设计一个延时电路。在输入灭弧信号变为低电平一段时间后，将D触发器异步复位，使其输出变为低电平。\n\n⠀⠀若DRSSTC上一次成功起振，则D触发器的输出在初级电流过零后便已经变为低电平，异步复位无效，对电路无影响。若DRSSTC上一次没有起振，则电路将D触发器的输出重新复位为低电平。于是灭弧输入下一次变为高电平时，灭弧输出又会从低电平跳变到高电平，让DRSSTC再次尝试起振。\n\n![加入延时电路的灭弧同步电路](https://image.overlooked.top/img/drsstc/four/42.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">加入延时电路的灭弧同步电路</center><br>\n\n⠀⠀上图是加入延时电路的灭弧同步电路。\n\n⠀⠀灭弧输入为高电平时，U9A输出低电平，使D触发器异步置位，灭弧输出变为高电平。同时C3通过D4放电，使U10A输出变为低电平，输出变为高电平。\n\n⠀⠀灭弧输入转为低电平时，U9A输出高电平，D触发器异步置位停止，但是C3上电压为零，U10A输出高电平，D触发器也没有被异步复位，灭弧输出仍保持高电平。\n\n⠀⠀如果DRSSTC已经成功起振，则过零输入在初级谐振电流过零时产生上升沿将D触发器的输出变为零，也就是灭弧输出变为低电平，DRSSTC功率管软关断，停振。\n\n⠀⠀灭弧信号转为低电平后，C3通过R3充电。当电压上升到U10A的UT+时，U10A输出变为低电平，使D触发器异步复位。如果之前电路并没有起振，则此时灭弧输出变为低电平，在下个灭弧输入高电平时DRSSTC可以再次尝试起振。\n\n![延时电路工作波形](https://image.overlooked.top/img/drsstc/four/43.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">延时电路工作波形</center><br>\n\n⠀⠀灭弧同步电路中延时部分的工作波形如上图。使用图中的元件参数，电路的延时时间为100uS。\n\n![带有灭弧同步的驱动电路](https://image.overlooked.top/img/drsstc/four/44.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">带有灭弧同步的驱动电路</center><br>\n\n⠀⠀我们将灭弧同步电路加入之前设计的驱动电路。于是，我们的DRSSTC驱动电路就完成啦。\n\n⠀⠀哦，没完成。。还差电源部分。这个驱动电路是用15V直流供电的。电路中的TC4421可以在15V下工作，但是电路图中的74系列芯片的工作电压是5V。所以我们用7805将15V的电压降到5V来为74芯片供电。\n\n⠀⠀7805是一个有三个引脚的线性降压稳压块。\n\n![7805应用电路图](https://image.overlooked.top/img/drsstc/four/45.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">7805应用电路图</center><br>\n\n⠀⠀7805的接法如图。它的1脚接电源输入，2脚接电路地，从三脚就可以输出5V的电压啦。\n\n⠀⠀使用时记得在电源输入和输出并联退耦电容，否则7805可能产生自激振荡，使输出电压异常。\n\n⠀⠀7805的输入电压在7V到35V左右，最大的输出电流在1.5A左右。它的发热功率P=（输入电压-5V）*输出电流。大功率使用时记得加散热片哦。\n\n![基础版DRSSTC驱动器](https://image.overlooked.top/img/drsstc/four/46.png)\n<center style=\"font-size:14px;color:#A0A0A0;\">基础版DRSSTC驱动器</center><br>\n\n⠀⠀加入了7805的DRSSTC驱动电路如上图。C4用于低通滤波以抗干扰，&nbsp;灭弧输入对地接了R5，以在驱动电路未连接灭弧线时，将灭弧输入拉到低电平，DRSSTC不工作。\n\n## 如何实现过流保护？\n\n⠀⠀过流保护电路（<span style=\"text-decoration: line-through;\">强迫症</span>OCD）可以在DRSSTC初级谐振回路的电流振升到设定值的时候将特斯拉线圈关闭，保护功率管不会因过流而损坏。\n\n⠀⠀要实现过流保护功能，我们首先需要检测DRSSTC初级回路中的电流。没错，我们又需要一个电流互感器。\n\n⠀⠀因为要检测电流的大小，所以我们就不能像之前那样给电流互感器的输出接稳压管了。这次我们接一个电阻。\n\n![电流取样电路](https://image.overlooked.top/img/drsstc/four/47.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电流取样电路</center><br>\n\n⠀⠀电流取样部分的电路如上图。我们依旧使用1:1000的电流互感器，电流互感器的输出正弦波经过桥式整流后变为正弦半波，加在R1上。\n\n⠀⠀这里要注意，电阻必须接在整流桥的输出。如果接在输入，则整流二极管的压降会对我们的检测产生影响。\n\n![电流取样电路输出的电压](https://image.overlooked.top/img/drsstc/four/48.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电流取样电路输出的电压</center><br>\n\n⠀⠀R1两端的波形如图。\n\n⠀⠀一般我们在DRSSTC中用初级回路峰值电流，也就是初级回路中电流所能达到的最大值来描述谐振回路中的电流大小。所以我们先将电流表显示的有效值换算为峰值：200A*1.4=280A。即该实验模拟初级谐振电流为280A的DRSSTC。\n\n⠀⠀电流互感器次级电流峰值为280A*（1:1000）=0.28A，R1两端的电压峰值为0.28A*10Ω=2.8V。\n\n⠀⠀所以，假设如果我们不想让初级回路中的电流超过300A，我们就不要让R1两端的电压峰值超过3V。\n\n⠀⠀所以我们可以把R1两端的电压与3V去比较，通过比较结果确定电流是否超标。用什么比较呢？电压比较器。\n\n![电流280A时](https://image.overlooked.top/img/drsstc/four/49.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电流280A时</center><br>\n\n⠀⠀如图，我们把电压比较器的反相输入接入R1上的电流信号，同相输入接入3V电源。初级电流峰值为280A。\n\n⠀⠀由于R1两端的电压始终没有超过3V，电压比较器的同相输入端电压便始终大于反相输入端电压，输出始终保持高电平。\n\n![输入350A](https://image.overlooked.top/img/drsstc/four/50.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">输入350A</center><br>\n\n⠀⠀而当初级回路中的电流超过300A时（上图为350A），电压比较器的输出开始出现低电平。电压比较器输出低电平代表电流超过了设定值，DRSSTC初级回路中电流过大。为此我们应该关闭DRSSTC。\n\n⠀⠀用什么关闭呢？当然是灭弧信号啦。\n\n⠀⠀我们可以在初级回路中电流过大时，强制让灭弧信号变为低电平，使DRSSTC关闭。而在下一个灭弧高电平到来时，由于初级谐振电流早就没了，我们便当做无事发生，使DRSSTC重新起振。\n\n⠀⠀也就是说，我们要把过流信号和灭弧信号同步起来。过流信号一旦出现，灭弧输出就变为低电平。灭弧输入一旦重新变为高电平，则灭弧输出重新变为高电平。\n\n⠀⠀用什么同步呢？还是用D触发器。\n\n![过流保护-灭弧同步电路](https://image.overlooked.top/img/drsstc/four/51.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">过流保护-灭弧同步电路</center><br>\n\n⠀⠀同步电路如上图。\n\n⠀⠀电路中的与门作为一个开关，负责接通或断开灭弧输入。\n\n⠀⠀在初级回路过流时，电压比较器输出过流信号（低电平），将D触发器异步复位，输出变为低电平，于是与门的一个输入变为低电平，输出立刻变为低电平，使DRSSTC停止工作。\n\n⠀⠀在灭弧输入产生上升沿时，意味着灭弧输入由低电平重新变为高电平，由于D触发器的输入D=1（5V），它被同步置位，输出变为高电平，使与门重新接通灭弧信号。\n\n![同步电路的作用](https://image.overlooked.top/img/drsstc/four/52.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">同步电路的作用</center><br>\n\n⠀⠀电路的工作时序如上图。\n\n![过流保护电路可以在电流过大切断灭弧信号，使DRSSTC关闭](https://image.overlooked.top/img/drsstc/four/53.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">过流保护电路可以在电流过大切断灭弧信号，使DRSSTC关闭</center><br>\n\n⠀⠀将同步电路与电压比较器电路接在一起，就组成了我们的OCD电路。\n\n![带有OCD的DRSSTC驱动](https://image.overlooked.top/img/drsstc/four/54.png)\n<center style=\"font-size:14px;color:#A0A0A0;\">带有OCD的DRSSTC驱动</center><br>\n\n⠀⠀将OCD电路加入我们的驱动电路，嗯，电路是不是瞬间就多了一半？\n\n⠀⠀所以，为了电路的简洁，本章教程将制作的DRSSTC中不加入OCD功能。\n\n## 如何增大驱动电路的驱动能力？\n\n⠀⠀本教程将制作的DRSSTC功率较小，使用的功率桥为四支“小管”组成的功率桥。所以我们设计的的驱动电路后级，也只使用了两个TC4421来推动GDT，驱动这四支“小管”。\n\n⠀⠀两个TC4421的输出能力并不大，实际上也仅能驱动四支“小管”。如果我们要使用并管全桥或IGBT模块等更强力组件制作功率DRSSTC，那么驱动电路允许的的输出电流必须要进一步扩大，以有能力驱动这些较大的器件。\n\n⠀⠀回顾我们讲的TC4421的内部结构。\n\n![TC4421\\TC4422内部结构](https://image.overlooked.top/img/drsstc/four/55.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">TC4421\\TC4422内部结构</center><br>\n\n⠀⠀它使用了MOS图腾作为后级放大。不过由于芯片封装的散热能力有限，它内部的MOS管的电流并不是很大。\n\n⠀⠀那么，我们只要在它的外部再加一级更大电流的MOS图腾来放大电路就行了嘛\n\n![MOS图腾柱](https://image.overlooked.top/img/drsstc/four/56.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">MOS图腾柱</center><br>\n\n⠀⠀于是我们用常用的MOS对管540和9540，组成了一个MOS图腾柱。输入高电平时，540导通，输出下拉。输入低电平时，9540导通，输出上拉。\n\n![MOS图腾柱的共态导通](https://image.overlooked.top/img/drsstc/four/57.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">MOS图腾柱的共态导通</center><br>\n\n⠀⠀这是供电电压为15V的MOS图腾柱的输入电压与空载输入电流的关系。\n\n⠀⠀可以看到，在输入电压4V-11V时，MOS图腾柱产生了输入电流。此时两个MOS管都会导通，产生额外的发热。当输入电压为7.5V时，输入电流达到了25A，这几乎相当于两个MOS管将电源短路了。\n\n⠀⠀所以， 使用MOS图腾柱需要注意的是：MOS图腾柱的输入电压只能为接近0V或接近Vcc，否则可能使两个MOS管共态导通而损坏。MOS图腾柱的门极承受全部电源电压，所以Vcc一般在20V以内。另外MOS图腾柱的输出与输入是反相的。\n\n![TC4421驱动MOS图腾柱](https://image.overlooked.top/img/drsstc/four/58.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">TC4421驱动MOS图腾柱</center><br>\n\n⠀⠀我们使用15V电源的TC4421驱动15V电源的MOS图腾柱，并在输出接一个小电阻作为负载。\n\n![MOS图腾柱工作波形](https://image.overlooked.top/img/drsstc/four/59.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">MOS图腾柱工作波形</center><br>\n\n⠀⠀可以看到输入矩形波时，输出也为矩形波，输入与输出反相。\n\n⠀⠀由于上面我们的驱动电路中TC4421的输出电压为0V和15V，所以我们的MOS图腾柱的电源电压也最好是15V。图腾柱的电源电压如果超过19V，即使TC4421输出高电平，9540也无法关断，从而发热损坏。图腾柱的电源电压如果再高，例如达到30V，即使TC4421输出低电平，9540的门极也会被-30V的电压击穿。\n\n⠀⠀那么，有没有什么办法克服MOS图腾柱的这些问题呢？\n\n⠀⠀我们上面分析过，电源电压过大时，不是9540关不了，就是9540被击穿。所以我们让这个9540舒服一些就行了嘛。\n\n![MOS图腾柱改良版](https://image.overlooked.top/img/drsstc/four/60.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">MOS图腾柱改良版</center><br>\n\n⠀⠀所以我们把电路改成这样。初始状态，TC4421输出低电平0V，540关断，C1通过R2充电，其电压升至24V，9540的G-S电压为0V ，关断。\n\n⠀⠀电路工作：TC4421输出高电平15V时，540导通，C1通过D1放电到9V，9540的G-S电压为0V，关断，电路的输出下拉。\n\n⠀⠀TC4421输出低电平0V时，540关断，9540的门极电压被C2下拉到9V，其G-S电压为-15V，开启，电路的输出上拉。\n\n![MOS图腾柱改良版的工作波形](https://image.overlooked.top/img/drsstc/four/61.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">MOS图腾柱改良版的工作波形</center><br>\n\n⠀⠀看一下仿真后的结果：改良后的MOS图腾柱可以在输入高电平小于图腾柱的Vcc时，正常的工作。\n\n⠀⠀不过，实际上不管是MOS图腾柱还是改良版的MOS图腾柱，都可能存在共态导通的问题。只不过输入为矩形波时，共态导通的时间约为矩形波的上升（下降）时间，这个时间很短，对电路影响不大。\n\n⠀⠀共态导通的问题是可以改善的。对于540和9540组成的MOS图腾柱，降低`电源电压`可以减小共态导通的程度，当电源电压在8V以下时不会发生共态导通。对于改良版的图腾柱，降低`输入电压`可以减小共态导通的程度，当输入电压在8V以下时不会发生共态导通。\n\n⠀⠀不过电压也不能太小。电压低于5V时，MOS不会完全导通，图腾柱就不能用了。\n\n⠀⠀综上，用来驱动MOS图腾柱的TC4421我们不用15V供电，而使用9V供电，以减轻MOS的共态导通发热。\n\n![输出电流加大的带有OCD功能的DRSSTC驱动电路图](https://image.overlooked.top/img/drsstc/four/62.png)\n<center style=\"font-size:14px;color:#A0A0A0;\">输出电流加大的带有OCD功能的DRSSTC驱动电路图</center><br>\n\n⠀⠀所以我们给带有OCD功能的驱动电路的输出又加了俩改良后的MOS图腾柱。\n\n⠀⠀由于MOS图腾柱的供电电压为24V，，所以我们又加上了一个7809稳压块来获得9V电压，给TC4421供电来驱动图腾柱。\n\n⠀⠀由于本教程之后要制作的DRSSTC功率较小，所以驱动电路也不必使用MOS图腾柱。\n\n## 带有移相功能的驱动电路\n\n⠀⠀在第二章我们讲过，由于电流互感器、电路元件和功率管均存在延迟，所以在实际的DRSSTC中，功率器件的开关落后于谐振电流过零点。这导致了一定程度的硬开关发生，增大了功率管的压力，也降低了谐振回路电流振升速度。\n\n### LR移相回路\n\n⠀⠀我们知道，电感上的电压波形是超前于电流波形的。而如果我们使用感性负载作为电流互感器的负载，感性负载两端的电压同样会超前电流。\n\n⠀⠀我们提到过，对于理想的电流互感器，其初级电流和次级电流在任一时刻均成比例，所以电流互感器接入感性负载后，输出电流的过零点不变，为实际过零点；而输出电压波形相对电流发生超前，其过零点提前。\n\n![电流互感器驱动感性负载](https://image.overlooked.top/img/drsstc/four/63.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电流互感器驱动感性负载</center><br>\n\n⠀⠀所以我们试试在电流互感器的输出接上电阻（R）加电感（L）组成的感性负载。\n\n![感性负载电压超前电流](https://image.overlooked.top/img/drsstc/four/64.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">感性负载电压超前电流</center><br>\n\n⠀⠀如图，接入RL负载后，电流互感器输出的电压过零点相对输入的电流过零点超前了一个相位角。\n\n⠀⠀如果我们将这个超前的电压送入过零比较器，就会导致功率管提前开关。\n\n⠀⠀我们可以用这段提前的时间，抵消掉电路固有的延迟时间，实现功率管在谐振电流过零点刚好开关，达到软开关的效果。\n\n![RL负载中的L（电感）的大小可以影响超前角](https://image.overlooked.top/img/drsstc/four/65.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">RL负载中的L（电感）的大小可以影响超前角</center><br>\n\n⠀⠀如上图，其他参数不变，将电路中的电感L由47uH更换为10uH，可以看到移相角变小。\n\n⠀⠀所以，改变L可以改变移相角。我们把L换成可变电感，电路的移相角就可以连续调节了。我们可以调节L，使移相电路引入超前时间等于电路的延迟时间。\n\n### 钳位电路\n\n⠀⠀电流互感器的输出通过LR移相后，我们将其送入过零比较器。\n\n⠀⠀要将电流互感器的输出送入过零比较器，我们必须像之前那样，对其过大的电压幅度进行钳位。\n\n![加入钳位电路](https://image.overlooked.top/img/drsstc/four/66.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">加入钳位电路</center><br>\n\n⠀⠀加入钳位的LR移相回路电路图如上图。我们通过电阻分压获得⅓Vcc，用两个反相并联的4148二极管钳位。\n\n⠀⠀由于二极管的导通压降为0.7V，所以钳位后的信号电压会在⅓Vcc±0.7V之内。\n\n⠀⠀C6为耦合电容，R16为限流电阻。\n\n![钳位前后对比](https://image.overlooked.top/img/drsstc/four/67.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">钳位前后对比</center><br>\n\n⠀⠀这是钳位前后的波形。可以看到钳位前电流互感器输出的电压幅度非常大，所以钳位后的输出接近矩形波。\n\n### 过零比较器\n\n⠀⠀由于我们要求电路有一定的抗干扰能力，我们应该使用过零滞回比较器。\n\n⠀⠀由于DRSSTC的驱动电路是单电源供电的，我们要使用单电源过零滞回比较器。\n\n![单电源供电过零滞回比较器](https://image.overlooked.top/img/drsstc/four/68.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">单电源供电过零滞回比较器</center><br>\n\n⠀⠀单电源供电的过零滞回比较器电路如上图。由于为单电源供电，我们将过零信号耦合到⅓VCC后进行比较。\n\n⠀⠀过零比较器通过正反馈引入了滞回特性。这里的正反馈通路有两条：R22和R23+C5。\n\n⠀⠀对于低频信号，R23+C5通路不起作用，正反馈通路的电阻较大。对于高频信号，正反馈通路的电阻由于C5容抗的下降而迅速降低。所以，这个滞回比较器在高频段的滞回特性较强。这样的设计有助于防止电路产生高频振荡。\n\n![过零比较器工作波形](https://image.overlooked.top/img/drsstc/four/69.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">过零比较器工作波形</center><br>\n\n⠀⠀这是我们过零比较器的工作波形。可以看到它将钳位的输出变为了矩形波。\n\n![带有移相功能的过零检测电路](https://image.overlooked.top/img/drsstc/four/70.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">带有移相功能的过零检测电路</center><br>\n\n⠀⠀将我们的LR移相器、钳位电路和过零比较器连接后，我们便得到了带有超前移相功能的过零检测电路。\n\n![电路的工作效果](https://image.overlooked.top/img/drsstc/four/71.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电路的工作效果</center><br>\n\n⠀⠀这是我们电路的工作波形。可以看出过零信号输出跳变要早于谐振回路电流过零。\n\n![DRSSTC驱动电路完全版](https://image.overlooked.top/img/drsstc/four/72.png)\n<center style=\"font-size:14px;color:#A0A0A0;\">DRSSTC驱动电路完全版</center><br>\n\n⠀⠀用带有超前移相功能的过零比较器换掉之前驱动电路中的7414过零比较器，我们便得到了带有移相功、OCD功能和驱动能力较大的DRSSTC驱动电路。\n\n⠀⠀注意，调试移相电路的移相角需要使用示波器。我们用示波器观察初级谐振电流和功率桥的输出电压，并将可调电感调到功率桥能实现零电流开关。如果没有示波器，不推荐使用带移相功能的驱动电路。\n\n⠀⠀怎么样，我们的最终版电路图是不是好长好长呢。。。\n\n![教程之后会使用这个较简单的驱动电路](https://image.overlooked.top/img/drsstc/four/73.png)\n<center style=\"font-size:14px;color:#A0A0A0;\">教程之后会使用这个较简单的驱动电路</center><br>\n\n⠀⠀不过教程之后制作的DRSSTC会使用这个基础版的驱动电路，不去用那个丧心病狂的长条形电路。。。\n\n⠀⠀DRSSTC驱动电路中，各元件如何焊接和使用的说明将在之后的章节给出。\n","tags":["DRSSTC"],"categories":["电子DIY"]},{"title":"DRSSTC教程 第三章 - 特斯拉线圈的灭弧电路设计","url":"/post/3a404290.html","content":"## 前言\n⠀⠀教程第三章后半部分将讲解一些基础电路知识，并利用这些知识设计特斯拉线圈的灭弧电路。\n\n## 什么是特斯拉线圈的灭弧？\n⠀⠀灭弧，字面意思上，就是让特斯拉线圈不产生电弧。\n\n⠀⠀当然，灭弧不是让特斯拉线圈永远不再产生电弧，而是让它休息一会。通常，灭弧会让特斯拉线圈在一秒钟内休息几十到几百次。\n\n⠀⠀特斯拉线圈的灭弧又称为中断。带有灭弧功能的DRSSTC，具有灭弧信号的输入端（电信号或光信号）。\n\n![灭弧信号示意图](https://image.overlooked.top/img/drsstc/three/1.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">灭弧信号示意图</center><br>\n\n⠀⠀如上图所示，灭弧信号是一个矩形波的信号电压，具有高电平（例如5V）和低电平（例如0V）两种电压值。随着时间变化，灭弧信号在这两个电压之间切换。\n\n⠀⠀`在本教程中，我们规定灭弧信号在高电平时（例如5V）允许特斯拉线圈工作，在低电平时（0V）使特斯拉线圈灭弧。（当然我们完全可以将两者反过来）`\n\n⠀⠀在输入特斯拉线圈的灭弧信号为高电平时，特斯拉线圈开始工作，驱动电路向谐振回路提供能量，之后特斯拉线圈开始放出电弧。\n\n⠀⠀当灭弧信号转为低电平时，灭弧生效，驱动电路停止向初级回路提供能量，特斯拉线圈的输入功率降为零。由于特斯拉线圈不再向谐振回路补充功率，谐振回路中的能量快速耗散，电弧会渐渐消失。\n\n## 为什么要给特斯拉线圈灭弧?\n### 火花隙特斯拉线圈（SGTC）\n\n⠀⠀SGTC的电路形式，导致它自带灭弧。SGTC电路中的打火器就是它的灭弧器。\n\n![SGTC](https://image.overlooked.top/img/drsstc/three/2.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">SGTC</center><br>\n\n⠀⠀上电后，高压电容组上的电压为零，而高压变压器开始为电容组充电。\n\n⠀⠀此时，打火器未被击穿，特斯拉线圈的谐振回路被打火器断开。这个状态可以视为灭弧信号的低电平。\n\n⠀⠀在电容电压上升到足够高后，打火器被电火花击穿，谐振回路被接通，开始振荡。此时特斯拉线圈开始工作，产生电弧，此时可以看做灭弧信号转为高电平。\n\n⠀⠀随着SGTC的工作，谐振回路的能量逐渐被消耗。在谐振回路的电流不足以维持打火器中的电火花时，电火花熄灭，将特斯拉线圈的谐振回路断开。此时特斯拉线圈停止工作，此时可以看做灭弧信号再次转入了低电平。\n\n![SGTC工作过程](https://image.overlooked.top/img/drsstc/three/3.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">SGTC工作过程</center><br>\n\n⠀⠀所以，SGTC的主电容充电时，即为灭弧。\n\n⠀⠀由于SGTC的主电容的相邻两次充能一般时间间隔很短（交流供电时为10mS），所以由于电弧产生的等离子体的残留，和我们的视觉暂留效应，电弧看起来是连续的。\n\n### 真空管特斯拉线圈（VTTC）\n⠀⠀VTTC加灭弧，主要是为了控制输入的功率。\n\n⠀⠀真空管对阳极和栅极的耗散功率有严格的限制（超功率使用时会使电子管过热，缩短寿命）。为了在控制输入平均功率（也就是控制电子管的发热量）的前提下获得更大的瞬时功率，VTTC可以加入灭弧电路。\n\n![VTTC](https://image.overlooked.top/img/drsstc/three/4.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">VTTC</center><br>\n\n⠀⠀例如图中这台VTTC，每隔190mS，工作10mS左右。也就是灭弧信号每隔190mS的低电平，变为高电平并持续10mS。这种爆发式的工作，可以以较小的平均功率（控制发热）获得较大的瞬时功率（电弧长度）。\n\n### 固态特斯拉线圈（SSTC）\n⠀⠀SSTC的电路形式决定了它与SGTC的不同。SSTC是可以连续工作（CW）的。\n\n⠀⠀只要初级线圈始终提供交变磁场，次级线圈就会一直谐振下去，也会连续的产生的高压去击穿空气。\n\n⠀⠀那么高压一直击穿空气会怎么样？\n\n⠀⠀次级线圈的放电尖端会优先把离它较近的空气都击穿掉。而在输入功率较小的时候，尖端在击穿掉周围的空气后，就没有额外的能量去击穿更远的空气了。\n\n⠀⠀于是被击穿的空气都在放电尖端周围，这些细小的电弧围在一起，形成一簇电晕。\n\n![电晕放电](https://image.overlooked.top/img/drsstc/three/5.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电晕放电</center><br>\n\n⠀⠀当然，当功率继续增大时，电晕放电的范围也会扩大，并有击穿更远空气的倾向。例如上图中右边的一簇电晕放电，向外伸出了一些电弧枝。\n\n⠀⠀CW工作的SSTC通常功率较大而电弧较短。然而，通常我们都希望我们制作的SSTC能播放普通的音乐，所以通常我们制作的SSTC是连续工作的。\n\n⠀⠀SSTC在连续工作时，我们可以通过PWM或电源调制等方式，连续改变电弧的功率，使其按照声音信号的波动规律去加热空气，通过空气的热胀冷缩，带来的气压的规律改变，产生声波，从而通过电弧播放音乐。\n\n⠀⠀但是也有少数SSTC加入了灭弧的（ISSTC）。\n\n⠀⠀在SSTC中，加入灭弧电路会产生的效果是输入功率减小，电弧长度增加和产生噪音。\n\n⠀⠀输入功率减小很好理解。原本是连续工作的SSTC，现在由于灭弧信号的加入，变得开始断断续续的工作。所以工作的时间少了，输入的平均功率也就小了。输入的平均功率减小，可以减小功率器件的压力\n\n⠀⠀前面我们说过，CW工作的SSTC的一直在均匀的击穿离放电尖端最近的空气，所以电弧是一小簇电晕。\n\n⠀⠀不同的是，带有灭弧的SSTC可以间断的击穿空气。间断的重复频率足够高时，线圈会沿着上一次线圈工作产生的电弧在空气中形成的导电通道来产生新的电弧。于是电弧便有机会在之前形成的电弧上积累，进而击穿更远的距离，形成更长的电弧。\n\n⠀⠀线圈的每次工作都会产生电弧加热空气，随着线圈的间断工作，空气被电弧周期性的加热。热胀冷缩带来的气压变化会转化为声波，我们便可以听到与灭弧信号频率相同的声音（很吵的）。\n\n![半波供电的SSTC](https://image.overlooked.top/img/drsstc/three/6.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">半波供电的SSTC</center><br>\n\n⠀⠀SSTC形成较长电弧的另一个途径是使用正弦半波供电。正弦半波供电时，形成的电弧形状与半波供电的VTTC相似。由于电源电压上升速率的缘故，电弧形状比较直，分叉少。\n\n### 双谐振固态特斯拉线圈（DRSSTC）\n\n⠀⠀理论上，DRSSTC同样可以像SSTC一样不加灭弧，CW工作。CWDRSSTC的电弧效果与CW工作的SSTC一样，是一簇电晕。而且由于DRSSTC是软开关工作，与SSTC相比效率更高。\n\n![CW工作的DRSSTC](https://image.overlooked.top/img/drsstc/three/7.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">CW工作的DRSSTC</center><br>\n\n⠀⠀但是，想想第二章中我们确定的DRSSTC的设计原则：初级回路要有较小的浪涌阻抗。\n\n⠀⠀我们这样设计的目的是让DRSSTC的初级线圈中的电流快速的振升。如果我们不加灭弧，让DRSSTC连续工作。。嗯，初级线圈中的电流会大到让我们的空开跳闸，功率管爆炸。(当然上面那台线圈是个特例，它用低压供电，设计的浪涌阻抗还很大)\n\n⠀⠀所以，我们需要给DRSSTC加入灭弧电路。在初级回路的电流振升到足够大后，就使DRSSTC的驱动电路停止为初级回路注入能量，以控制初级回路中的电流。\n\n⠀⠀此外，加入灭弧的其他好处同样有很多。灭弧的加入，减小了DRSSTC输入的平均功率，减轻了功率管的压力。灭弧使DRSSTC爆发性工作，瞬时功率较大，可以在一次次工作中逐步击穿很远的空气，获得很长的电弧。\n\n⠀⠀如果我们用方波音乐输入音乐灭弧电路（之后会设计），用灭弧电路产生的灭弧信号驱动DRSSTC，加入了灭弧的DRSSTC的电弧也能够播放简单的音乐。\n\n## 如何实现灭弧？\n\n⠀⠀我们要给特斯拉线圈加入灭弧功能，就要让驱动电路识别灭弧信号，并用灭弧信号来控制特斯拉线圈，这个部分内容属于驱动电路，我们在之后的章节中讲。\n\n⠀⠀而在此之前，我们首先需要获得灭弧信号。灭弧信号就是一组矩形波，在矩形波高电平时允许特斯拉线圈工作而低电平时灭弧。\n\n⠀⠀于是，我们需要设计并制作一个可以产生矩形波的电路。\n\n![理想的矩形波，在任一时刻不是高电平就是低电平](https://image.overlooked.top/img/drsstc/three/8.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">理想的矩形波，在任一时刻不是高电平就是低电平</center><br>\n\n⠀⠀这里我们先认识一下矩形波。把矩形波信号在时间推移下的变化规律画在坐标轴上，就得到了上面的波形图。\n\n⠀⠀正弦波的周期，指的是正弦波的电压从某个点出发向右推移，直到再次回到这个电压点所经历的的时间。矩形波的周期也类似，图中的T即为矩形波的一个周期。\n\n⠀⠀频率f是周期T的倒数。例如一个周期要持续2秒，那么每秒就有0.5个周期，频率就是0.5Hz。灭弧频率越高，特斯拉线圈发出的音调就越高。\n\n⠀⠀正脉宽，是矩形波一个周期中高电平持续的时间。它代表灭弧信号一个周期内特斯拉线圈的工作的时间。\n\n⠀⠀正占空比，是一个周期中矩形波高电平时间占总时间的百分比。它反映特斯拉线圈工作时间和休息时间的比例，占空比越大，特斯拉线圈平均工作的时间越长，输入功率也就越大。\n\n## 特斯拉线圈对灭弧信号矩形波有什么要求？\n### 对于SSTC：\n⠀⠀SSTC对灭弧信号的频率没有限制（&nbsp;只要低于SSTC的谐振频率）。但是实际上太高或太低都没有意义。\n\n⠀⠀通常SSTC灭弧信号的频率在1Hz-10KHz范围内。\n\n⠀⠀只要输入功率不要超过电路所能承受的大小，SSTC对灭弧信号的占空比也没有限制，可以取0%-100%。\n\n⠀⠀灭弧信号的占空比越大，SSTC在一个灭弧周期的平均工作时间就越长，输入功率就越大占空比0%就是灭弧信号总是低电平，SSTC一直不工作；100%就是灭弧信号一直是高电平，SSTC进入CW工作。\n\n### 对于DRSSTC：\n⠀⠀DRSSTC进行灭弧的主要目的是控制初级电流的振升。\n\n⠀⠀我们知道，在参数固定时，DRSSTC初级电流振升的速度是确定的。\n\n⠀⠀于是，我们可以使用正脉宽长度一定的信号，给DRSSTC做灭弧信号。这样，在灭弧信号的每个周期，DRSSTC的初级回路电流都能振升到相同的大小。我们可以调整灭弧信号正脉宽的大小，使电流能振升到的值处于安全范围内。\n\n⠀⠀综上，我们可以用脉宽和频率两个参数来确定DRSSTC的灭弧信号。\n\n⠀⠀通常，DRSSTC的灭弧信号脉宽在500uS（微秒）以内。\n\n⠀⠀DRSSTC的初级电流振升速度是很快的，所以它的瞬时输入功率也是非常大的。这就要求DRSSTC的工作占空比不能太高。如果占空比设置的过高，会产生非常大的输入功率，对功率管和供电线路造成损坏。\n\n⠀⠀在灭弧信号的脉宽确定后，其频率越高，DRSSTC的工作占空比就越高。所以，DRSSTC实际上对灭弧信号的频率也有限制。\n\n⠀⠀通常DRSSTC灭弧信号的频率在1Hz-1000Hz范围内。工作脉宽固定后，DRSSTC的工作频率越高，输入功率越大。\n\n## 如何搭建灭弧电路?\n⠀⠀要搭建灭弧电路，我们需要用到一些电子元件，这里作一个简单的介绍。\n\n> 新手向！有一定的电子基础者可以直接跳过这部分内容。\n\n### 运算放大器（运放）：\n\n![运放](https://image.overlooked.top/img/drsstc/three/9.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">运放</center><br>\n\n⠀⠀运放的电路符号如上图。\n\n⠀⠀它有两个输入端：同相输入端（其电压用**U1**表示）和反相输入端（其电压用**U2**表示）。 它有一个输出端，输出端的电压我们用**Uo**表示。\n\n⠀⠀运放实现的电路功能是将输入的信号放大：**Uo=A*(U1-U2）**（开环）\n\n⠀⠀它将两个输入端的电压相减后放大，我们称之为差分放大，其中**A**为开环放大倍数。\n\n⠀⠀这个**A**有多大呢？很大。以常用的运放**LM358**为例，**A=100000**倍。\n\n⠀⠀所以，一般来说我们不开环使用运放，因为开环使用时它放大倍数太大了，超过了一般电路的需求。过大的放大倍数也会使它的高频段增益严重衰减，通频带很窄。\n\n![运放应用电路图](https://image.overlooked.top/img/drsstc/three/10.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">运放应用电路图</center><br>\n\n⠀⠀上图是运放的几个实际应用电路图，这些电路的功能有求和，比例，积分，微分之类的。可以发现一个共同点，这些电路都在运放的输出端和反相输入端（-）引入了电路。\n\n⠀⠀这种接法我们称之为负反馈。在深度负反馈（定义不解释了。。）下，运放组成的电路的放大倍数不由运放决定，而是由外围电路决定。\n\n⠀⠀于是我们便可以通过负反馈，获得想要的放大倍数和电路功能。\n\n⠀⠀深度负反馈电路的求解方法是“虚短”、“虚断”。\n\n⠀⠀虚短：深度负反馈下运放的同相输入端和反相输入端的两个电压总是相等，类似于短路。\n\n⠀⠀虚断：由于运放的输入电阻很大，同相输入端和反相输入端几乎没有输入电流，可以视为断路。\n\n⠀⠀说多了。。。运放在DRSSTC的电路里用不到，大家了解一下就行。。。\n\n### 电压比较器：\n\n![电压比较器](https://image.overlooked.top/img/drsstc/three/11.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电压比较器</center><br>\n\n⠀⠀先来看看电压比较器的符号。嗯。。是不是。。跟运放一模一样？\n\n**Uo=A*(U1-U2）**，是不是也一模一样？\n\n⠀⠀没错。电压比较器就是开环使用的运放。电压比较器与运放的主要区别是，比较器的开环增益A更大，转换速度更快。但是由于比较器内部没有相位补偿电路，所以不能接成负反馈电路来使用。常用的电压比较器LM393的输出是集电极开路的，需要接上拉电阻才能输出信号。\n\n⠀⠀在通常的、低频的电路中，运放可以替换电压比较器（反之不行）。\n\n⠀⠀电压比较器的功能，也是将同相输入与反相输入差分放大（相减后放大）。\n\n⠀⠀不过电压比较器是开环使用的，而它有巨大的放大倍数，所以只要U1比U2大一点，UO就会上升到最大值（约为电源电压）；只要U2比U1大一点，UO就会上升到最小值（约为电0V或负电源电压），相当于比较结果只有两个：大于和小于。\n\n⠀⠀电子制作中常用的电压比较器LM393和常用的运放LM358都是8引脚的集成芯片，内部也都有两个功能模块，脚位也相同。它们的区别只是内部封装的功能模块一个是比较器，另一个是运放。\n\n⠀⠀不过这里要注意LM393的输出没有上拉能力，需要加上拉电阻，而LM358的输出不需要上拉电阻。\n\n![LM393和LM358的引脚图](https://image.overlooked.top/img/drsstc/three/12.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">LM393和LM358的引脚图</center><br>\n\n### 电压比较器的应用：过零比较器\n\n![过零比较器](https://image.overlooked.top/img/drsstc/three/13.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">过零比较器</center><br>\n\n⠀⠀如图，电压比较器使用±12V双电源供电，左端为信号输入，右端为信号输出。电压比较器将输入的信号与GND（即0V）作比较，输出比较结果\n\n![工作波形](https://image.overlooked.top/img/drsstc/three/14.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">工作波形</center><br>\n\n⠀⠀红色曲线为输入，绿色曲线为输出。可以看到，当输入的正弦波大于0V时，输出的结果为电源电压（12V），当输入的正弦波变为小于0V时，输出的结果为负的电源电压（-12V）。\n\n### 电压比较器的应用：过零滞回比较器\n\n![过零滞回比较器](https://image.overlooked.top/img/drsstc/three/15.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">过零滞回比较器</center><br>\n\n⠀⠀如图，电路左边是输入，右边是输出。可以看到，与过零比较器相比，电路多出来两个电阻。电路中引入了正反馈。\n\n![工作波形](https://image.overlooked.top/img/drsstc/three/16.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">工作波形</center><br>\n\n⠀⠀加入正反馈后，电路有了滞回特性。虽然输入电压上升到超过零，还要继续超过一个正的电压（我们称之为UT1），比较器才会输出正结果。当输入电压下降到低于零，还要继续下降到低于一个负的电压（我们称之为UT2），才会输出负的结果。\n\n![阈值电压计算公式](https://image.overlooked.top/img/drsstc/three/17.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">阈值电压计算公式</center><br>\n\n![滞回特性](https://image.overlooked.top/img/drsstc/three/18.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">滞回特性</center><br>\n\n![两种电路对于干扰的抵抗能力](https://image.overlooked.top/img/drsstc/three/19.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">两种电路对于干扰的抵抗能力</center><br>\n\n⠀⠀使用滞回比较器的好处是可以抵抗干扰。可以看出，在输入有高频干扰的正弦波信号时，过零比较器的输出出现了高频杂波，而过零滞回比较器的输出则没有被影响。\n\n### 电压比较器的应用：单电源供电的过零滞回比较器\n\n![单电源供电的过零滞回比较器](https://image.overlooked.top/img/drsstc/three/20.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">单电源供电的过零滞回比较器</center><br>\n\n⠀⠀电路如图。单电源供电时，将输入信号用电容耦合到½Vcc，并将过零比较器原本的零电位也移到½Vcc。R17建立了正反馈，引入了滞回特性。这里的输入信号作为了反相输入，所以输出电压相位和输入电压是相反的。\n\n![工作波形](https://image.overlooked.top/img/drsstc/three/21.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">工作波形</center><br>\n\n⠀⠀绿色的是输入信号曲线，它被电容耦合到蓝色曲线，比较输出为红色曲线。\n\n### 或非门：\n⠀⠀在数字电路中，我们规定**高电平（例如5V）为数字1，低电平（例如0V）为数字0**。\n\n![或非门](https://image.overlooked.top/img/drsstc/three/22.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">或非门</center><br>\n\n⠀⠀或非门有输入A和B，输出Y。它的符号如上图：或门加一个小圈（表示非运算）。\n\n⠀⠀或非门可以实现或非运算。当输入A和B都是0的时候，输出Y为1。其他三种输入情况下，输出Y都是0。\n\n⠀⠀简单的数字电路知识相信大家都会，其他的“门”，例如与门非门之类的这里就不讲了，不知道的百度一下就行，一看就懂。\n\n### RS触发器：\n![RS触发器](https://image.overlooked.top/img/drsstc/three/23.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">RS触发器</center><br>\n\n⠀⠀两个或非门以奇怪的姿势连接起来，就构成了一个RS触发器（RS触发器还可以用与非门构成）\n\n⠀⠀RS触发器有置位输入S、复位输入R、同相输出Q、反相输出“Q加一杠”。\n\n⠀⠀RS触发器这的工作过程这里就不写了，大家通过或非门的连接，分析一下就能得到。这里给出结果，我们来看一下RS触发器能干什么。\n\n⠀⠀置位操作：输入S=1，R=0，此时输出Q立刻变为1。\n\n⠀⠀复位操作：输入S=0，R=1，此时输出Q立刻变为0。\n\n⠀⠀状态保持：输入S=0，R=0，此时输出Q不变，为上一次置位或复位后的结果。\n\n⠀⠀S=1，R=1通常不允许被输入，因为它会导致同相输出和反相输出相等。\n\n### NE555芯片：\n⠀⠀介绍了这么多电路器件，我们终于能分析NE555芯片的原理了。\n\n![NE555芯片](https://image.overlooked.top/img/drsstc/three/24.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">NE555芯片</center><br>\n\n⠀⠀NE555芯片是业余电子制作中，使用非常多的一种时基集成电路芯片。使用NE555可以很方便构成无稳态、单稳态和双稳态电路。\n\n![NE555结构图](https://image.overlooked.top/img/drsstc/three/25.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">NE555结构图</center><br>\n\n⠀⠀我们来看一下NE555的结构图。NE555内部由三个5KΩ分压电阻、两个电压比较器和一个RS触发器构成。\n\n⠀⠀NE555的3脚是矩形波信号的输出端，由RS触发器的输出Q经过放大后得到。NE555允许的的输出电流通常在100mA以上。\n\n⠀⠀NE555的1脚和8脚分别是地（单电源的负极）和正电源（Vcc）输入。电源电压应在4.5-18V之间。\n\n⠀⠀NE555的内部有3个分压电阻。在5脚没有外加电路的情况下，三个电阻可以分得⅔Vcc和⅓VCC两个电压，作为电压比较器的阈值电压。\n\n⠀⠀`6脚的输入电压高于⅔Vcc时，比较器A1输出1，将SR触发器复位，3脚输出变为低电平。`\n\n⠀⠀`2脚的输入电压低于⅓VCC时，比较器A2输出1，将SR触发器置位，3脚输出变为高电平。`\n\n⠀⠀`6脚的输入电压低于⅔Vcc且2脚的输入电压高于⅓VCC时，3脚输出维持上次改变后的值。`\n\n⠀⠀NE555输出的高电平约为电源电压，低电平约为0V。\n\n⠀⠀7脚对地有一个三极管，输出为低电平的时候三极管导通，此时NE555可以从7脚吸收电流。不需要使用这个三极管时，将7脚悬空或接地。\n\n⠀⠀4脚输入低电平时，触发器将复位并禁止置位。所以4脚输入低电平时，3脚的输出变为低电平并保持。不需要4脚的功能时应将4脚接入Vcc。\n\n⠀⠀5脚如果接输入电压，则可以由外部改变上述⅔Vcc阈值，同时⅓Vcc也随之变为输入电压的一半。不需要改变时可以将5脚悬空或对地加一小电容（提高电路稳定性）。\n\n⠀⠀NE555的8个引脚都介绍完了。下面来看看NE555可以用来干什么。\n\n### NE555组成的施密特反相器\n\n![施密特反相器](https://image.overlooked.top/img/drsstc/three/26.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">施密特反相器</center><br>\n\n⠀⠀如图，将NE555的2、6脚连接并作为信号输入，3脚作为信号输出。\n\n⠀⠀当输入上升到⅔Vcc=8V时，NE555内部的RS触发器被电压比较器复位，输出变为低电平\n\n⠀⠀当输入下降到⅓Vcc=4V时，NE555内部的RS触发器被电压比较器置位，输出变为高电平\n\n![工作波形](https://image.overlooked.top/img/drsstc/three/27.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">工作波形</center><br>\n\n⠀⠀工作波形如图所示。该电路的工作波形与之前讲的单电源供电的滞回比较器相似，均可把输入的波形整形为方波后反相输出，并具有一定的抗干扰能力。\n\n### NE555组成的矩形波振荡器\n\n⠀⠀讲了这么多，还记得我们要做什么吗？我们要制作为特斯拉线圈产生灭弧信号的矩形波振荡器。\n\n![矩形波振荡器](https://image.overlooked.top/img/drsstc/three/28.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">矩形波振荡器</center><br>\n\n⠀⠀将施密特反相器首尾连接就能够成一个振荡器。由于直接相连的振荡频率由电路由电路延迟决定，通常频率过高，所以我们加入了RC延迟环节，电路如上图。\n\n⠀⠀加入RC环节后，电路的振荡频率将由电阻和电容的大小决定。\n\n![NE555振荡器](https://image.overlooked.top/img/drsstc/three/29.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">NE555振荡器</center><br>\n\n⠀⠀于是我们把我们刚才用NE555搭的施密特反相器用电阻首尾相连，再加入振荡电容。\n\n![工作波形](https://image.overlooked.top/img/drsstc/three/30.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">工作波形</center><br>\n\n⠀⠀接通电路，电容C5上的电压为零，NE555输出高电平，通过R11开始给C5充电。\n\n⠀⠀C5上的电压升高到⅔Vcc=8V时，NE555输出转为低电平，通过R11开始给C5放电。\n\n⠀⠀C5上的电压降低到⅓Vcc=4V时，NE555输出转为高电平，通过R11开始给C5重新充电。\n\n⠀⠀于是，NE555在不断给C5充放电的同时，也输出了我们需要的矩形波。当我们改变R11的大小时，输出矩形波的频率也会改变。\n\n⠀⠀由于电路的输出总是在高低电平之间变化，没有稳定的状态，我们把这个电路称为无稳态（振荡器）电路。\n\n⠀⠀将R11换成电位器，我们就可以得到一个频率可调的矩形波发生器。\n\n### NE555组成的单稳态电路\n\n![NE555单稳态电路](https://image.overlooked.top/img/drsstc/three/31.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">NE555单稳态电路</center><br>\n\n⠀⠀单稳态电路，即只有一个稳定状态的电路。NE555组成的单稳态电路如上图。\n\n⠀⠀上电后，C5上的电压为零，NE555的2脚电压为12V，6脚电压为0V。假设NE555的3脚的输出在上电后为高电平，则7脚的三极管截止，C5通过R11充电，电压逐渐升高。\n\n⠀⠀当C5的电压升高到⅔Vcc=8V时，6脚触发NE555内部的电压比较器，使RS触发器置零。\n\n⠀⠀RS触发器置零后，NE555的输出变为低电平，7脚的三极管导通，将C5的电压快速泄放至零，并将R11接地，禁止C5充电。`此时电路进入稳态，输出保持低电平不变`\n\n![工作波形](https://image.overlooked.top/img/drsstc/three/32.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">工作波形</center><br>\n\n⠀⠀现在我们加上触发信号，电路的工作波形如上图。\n\n⠀⠀当外部输入信号将2脚的电压下拉至⅓Vcc=4V时，RS触发器置位，NE555的输出变为高电平。同时7脚的三极管截止，C5开始通过R11充电。\n\n⠀⠀当C5的电压升高到⅔Vcc=8V时，6脚触发NE555内部的电压比较器，使RS触发器置零，NE555的输出重新变为低电平，再次进入稳态。\n\n⠀⠀所以，该电路只有输出为低电平一个稳态。当2脚输入负脉冲将电路触发后，电路将输出一个`脉宽固定的矩形脉冲`，之后返回稳态。矩形脉冲的脉宽为定时电容C5通过R11充电，从0V充到⅔Vcc=8V所需要的时间，元件参数固定时它是一个定值。\n\n⠀⠀`我们可以用NE555单稳态电路，输出固定脉宽矩形波，作为DRSSTC的灭弧信号。`\n\n⠀⠀但是我们考虑一种情况：2脚输入的负脉冲持续时间大于输出矩形脉冲的宽度时，会怎么样呢？\n\n⠀⠀C5上的电压高于⅔Vcc=8V后，RS触发器被复位，而此时2脚电位为低电平，触发脉冲还没有消失，RS触发器同时也被置位。\n\n⠀⠀之前说过，RS触发器通常不允许同时被置位和复位。在此电路中，这种现象的出现会导致输出矩形脉冲的宽度变长，超过设定值。\n\n⠀⠀为了避免触发脉冲比输出脉冲更宽，我们需要在NE555的触发输入单稳态电路的输入端接入微分电路。\n\n### 微分电路\n\n![微分电路](https://image.overlooked.top/img/drsstc/three/33.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">微分电路</center><br>\n\n⠀⠀用于NE555单稳态电路输入的微分电路如上图。\n\n⠀⠀左端为电路的输入，接入矩形波信号，右端为电路的输出。电路将矩形波信号变为负脉冲，用于触发NE555单稳态电路。\n\n![微分电路波形](https://image.overlooked.top/img/drsstc/three/34.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">微分电路波形</center><br>\n\n⠀⠀电路的工作波形如上图。\n\n⠀⠀输入的矩形波信号出现下降沿时，输出的电压瞬间被C1拉低，形成负脉冲。之后C1通过R2充电，使输出电压快速回升。\n\n⠀⠀输入的矩形波信号出现上升沿时，C1通过D1放电。电路等待下一个下降沿的到来。\n\n## 设计我们的灭弧电路\n### 设计SSTC灭弧电路\n\n⠀⠀SSTC灭弧电路要求频率和占空比可调。\n\n⠀⠀我们之前设计过一个频率可调的矩形波发生电路，那么，如何让占空比也可调呢？\n\n⠀⠀这里提供两种电路。\n\n#### 第一种电路\n\n⠀⠀之前我们说过，施密特反相器组成的振荡器，通过定时电阻给定时电容充放电。\n\n⠀⠀如果要改变占空比，就要改变定时电容的充电时间和它的放电时间之间的比例。\n\n⠀⠀我们可以让定时电容的充电回路和放电回路的电阻不同。\n\n![可调占空比的矩形波发生器](https://image.overlooked.top/img/drsstc/three/35.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">可调占空比的矩形波发生器</center><br>\n\n⠀⠀我们设计的电路如图。通过两个二极管来分割定时电容的充电和放电回路，便可以通过电位器R1滑动端的位置来改变充放电回路电阻的比，进而调节输出矩形波的占空比。\n\n⠀⠀该电路的缺点是，更改输出频率需要更换不同容量的电容C1，操作比较繁琐。\n\n⠀⠀使用图中的元件参数，`输出的矩形波频率约为130Hz`。该频率与C1的容量成反比，例如将C1更换为10nF，则频率变为1300Hz。\n\n⠀⠀电位器R1可以调节占空比，范围比0%-100%略小（由于限流电阻R2的存在）。\n\n#### 第二种电路\n\n⠀⠀我们知道，NE555组成的振荡器，其振荡电容上的电压为三角波。所以我们可以通过一个PWM比较器来获得占空比可调的矩形波\n\n![可调频率和占空比的矩形波发生器](https://image.overlooked.top/img/drsstc/three/36.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">可调频率和占空比的矩形波发生器</center><br>\n\n⠀⠀我们设计的电路如上图。这个电路将555振荡器电容上的三角波引出，与一个⅓Vcc到⅔Vcc（由电位器R4调节）的直流基准用电压比较器作比较，便可获得占空比可调的矩形波信号。\n\n⠀⠀电路中使用了运放LM358代替电压比较器。如果要使用电压比较器LM393，则输出应加上拉电阻。\n\n![工作波形](https://image.overlooked.top/img/drsstc/three/37.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">工作波形</center><br>\n\n⠀⠀工作波形如图，黄色的为三角波，蓝色水平线为直流基准。紫色为比较结果，即输出的矩形波。可以看到，蓝线比黄线高的时候输出为高电平。改变蓝色线的水平位置（调节R4）即可改变输出矩形波的占空比。\n\n⠀⠀使用图中的元件参数，该电路通过电位器R1可以调节的`频率范围约70Hz-700Hz`。在R1不变的情况下，输出频率与C1的容量成反比。例如将C1更换为1uF，则频率调节范围变为7-70Hz。\n\n⠀⠀该电路通过R4可以调节的占空比范围在0%-100%，实际制作电路时，R3和R5可以取小一些（例如91KΩ），以免因元器件参数的误差，导致占空比的调节范围达不到极限。\n\n## 设计DRSSTC灭弧电路\n\n⠀⠀DRSSTC灭弧电路要求频率和脉宽可调。所以我们可以用频率可调的振荡器 去驱动输出脉宽可调的单稳态电路，来产生DRSSTC的灭弧信号。\n\n![DRSSTC灭弧电路](https://image.overlooked.top/img/drsstc/three/38.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">DRSSTC灭弧电路</center><br>\n\n⠀⠀我们设计的电路如上图。左边的NE555组成了频率可调的矩形波振荡器，经过C2、D1、R3组成的微分电路变为负尖脉冲，送入NE555单稳态电路，由单稳态电路产生脉宽可调节的正脉冲。\n\n![仿真波形](https://image.overlooked.top/img/drsstc/three/39.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">仿真波形</center><br>\n\n⠀⠀仿真波形如上图。黄色线是振荡器产生的频率信号，蓝色线是微分电路输出的波形。紫色线为单稳态电路中定时电容C3上的电压，绿色线为单稳态输出的矩形脉冲。\n\n⠀⠀使用图中的元件参数，该电路通过电位器R1可以调节的`频率范围约70Hz-700Hz`。在R1不变的情况下，输出频率与C1的容量成反比。例如将C1更换为1uF，则频率调节范围变为7-70Hz。\n\n⠀⠀使用图中的元件参数，该电路通过电位器R4能调节的`脉宽范围在20uS-350uS`。在R4不变的情况下，输出脉宽与C3的容量成正比。例如将C1更换为3.3nF，则脉宽调节范围变为2uS-35uS。\n\n⠀⠀`在实际使用中一定要注意，不当的灭弧参数设置可能使功率管过流或输入功率过大，进而损坏DRSSTC。`\n\n## 设计DRSSTC音乐灭弧电路\n\n⠀⠀想要让特斯拉线圈播放音乐，我们首先要有方波音乐。方波音乐是以方波作为乐器素材的单音轨音乐。\n\n⠀⠀方波音乐可以通过将midi音乐的乐器声音素材换成方波，然后导出后做一下处理得到。\n\n![方波音乐](https://image.overlooked.top/img/drsstc/three/40.webp)\n![方波音乐](https://image.overlooked.top/img/drsstc/three/41.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">方波音乐的波形通常长这个样子</center><br>\n\n⠀⠀使用播放器播放方波音乐，播放器就会输出音乐对应频率的方波。\n\n⠀⠀对于SSTC，要实现音乐灭弧，我们只需要把播放器输出的方波放大，然后直接当做SSTC的灭弧信号就可以。\n\n⠀⠀对于DRSSTC，要实现音乐灭弧，我们需要把播放器输出的方波放大，然限制它的脉宽到DRSSTC需要的值，作为DRSSTC的灭弧信号。\n\n![DRSSTC音乐灭弧电路](https://image.overlooked.top/img/drsstc/three/42.png)\n<center style=\"font-size:14px;color:#A0A0A0;\">DRSSTC音乐灭弧电路</center><br>\n\n⠀⠀这是我们设计的DRSSTC音乐灭弧电路。它由低通滤波器、滞回比较器、微分电路与单稳态触发器等组成。\n\n⠀⠀音频信号从音频插座输入。输入的两个4148二极管是为了在意外情况下（例如电弧劈中音频线）将电压钳位以保护播放器。R1和C2组成了低通滤波器，滤除了DRSSTC工作时音频线可能接受到的高频干扰。\n\n⠀⠀音频信号被送入单电源供电的过零滞回比较器，经过比较后变为方波。这里使用LM393比较器，所以加了上拉电阻。\n\n⠀⠀比较器的方波经过微分电路变为负尖脉冲，输入单稳态电路，变为脉宽固定的信号，经过470Ω电阻限流后从灭弧输出插座输出。\n\n⠀⠀由于电路中使用了滞回比较器，所以只有当方波音频信号的峰峰值达到200mV时（普通播放器均能达到），才能被灭弧电路成功的转换为灭弧信号。这提高了电路的抗干扰能力。\n\n⠀⠀使用图中的元件参数，灭弧电路可输出的脉宽范围约40uS（微秒）至400uS。\n\n## 灭弧信号的传输\n\n⠀⠀做好灭弧电路之后，我们可以在调整好参数后将灭弧电路与特斯拉线圈的其他电路安放在一起，装在底座或机箱中。\n\n⠀⠀或者，我们也可以将灭弧电路装入外壳，制成一台灭弧器。灭弧器通常远离特斯拉线圈，这样我们便可以远距离的调节特斯拉线圈的参数（不推荐在特斯拉线圈工作时调节它的参数）。\n\n⠀⠀将灭弧器远离特斯拉线圈的另一个好处是，避免与灭弧器连接的音乐播放器（你的手机）被雷劈。。\n\n⠀⠀目前来说，灭弧器与DRSSTC连接，传输信号的方式通常有两种：屏蔽线传输和光纤传输。\n\n⠀⠀屏蔽线传输适合小功率的特斯拉线圈使用。灭弧器和特斯拉线圈的驱动板通过屏蔽线直接连接，电路简单可靠。但由于没有电气隔离，应注意驱动板不要与高压母线连接。使用时屏蔽线的外层应接地，避免被电弧劈中时造成损失。\n\n⠀⠀光纤传输适合大功率的特斯拉线圈。光纤可以让灭弧信号在较远距离安全的传输。由于灭弧器和特斯拉线圈主体电气隔离，使用起来比较放心。\n\n⠀⠀考虑到电路的简洁，且光纤头并非常规元件，不易购买，本教程将制作的小型DRSSTC不使用光纤。\n\n⠀⠀除了这两种传输方式，大家有兴趣也可以研究其他的方式来传输灭弧信号。例如激光传输，红外线传输，光耦隔离传输之类的。。\n\n> 灭弧器的电路已经确定，而焊接过程将在后续章节给出。\n","tags":["DRSSTC"],"categories":["电子DIY"]},{"title":"DRSSTC教程 第二章 - 特斯拉线圈的原理分析","url":"/post/bb8c4a88.html","content":"## 前言\n⠀⠀本章将对特斯拉线圈的原理进行简单的分析\n\n⠀⠀虽然不懂原理也可以按着之后的教程来制作DRSSTC，但是了解一下原理其实还是挺有趣的，是吧。。。\n\n## TC的结构\n⠀⠀特斯拉线圈是一种特殊的变压器\n\n⠀⠀变压器，有初级线圈，次级线圈，和磁芯\n\n![理想变压器](https://image.overlooked.top/img/drsstc/two/1.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">理想变压器</center><br>\n\n⠀⠀特斯拉线圈也有次级线圈，通常有500-3000匝\n\n![实物图](https://image.overlooked.top/img/drsstc/two/2.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">实物图</center><br>\n\n⠀⠀特斯拉线圈的次级线圈通常是用细漆包线在绝缘的筒状物，比如PVC下水道管上绕制的。为了承受高电压，特斯拉线圈的次级线圈只平绕一层（图中这个绕完后缠上了黑色的绝缘材料）\n\n⠀⠀特斯拉线圈也有初级线圈，通常只有几匝，套在次级线圈的下方。有蚊香形，锥形，螺线管形。初级线圈通常用很粗的导体绕制，图中这个是螺线管形的初级线圈，用几十平方的纯铜电焊机线绕制的。。。\n\n⠀⠀特斯拉线圈通常没有磁芯，属于空心变压器\n\n## 升压原理\n⠀⠀我们在物理课中学过，初级线圈与次级线圈耦合度为1的理想变压器，它的输入、输出交流电压比，等于初级、次级线圈的匝数比\n\n![公式](https://image.overlooked.top/img/drsstc/two/3.webp)\n\n⠀⠀但是特斯拉线圈是空心变压器，存在漏磁现象，它的初级线圈又离次级线圈比较远。所以，特斯拉线圈的耦合度远小于1，通常在0.3以下\n\n⠀⠀也就是说，特斯拉线圈的初、次级线圈的磁通量并不是紧密相关的，特斯拉线圈的输入和输出电压的比例可以不等于初级线圈和次级线圈匝数的比\n\n![公式](https://image.overlooked.top/img/drsstc/two/4.webp)\n\n---\n⠀⠀特斯拉线圈可以超越匝数比的限制来升高电压，其实现的关键，是谐振回路。谐振回路由一个电容和一个电感构成，又叫LC振荡回路\n\n![谐振回路](https://image.overlooked.top/img/drsstc/two/5.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">谐振回路</center><br>\n\n⠀⠀谐振回路中存在能量时（电感上有电流或电容上有电压），能量会自发的在电感元件和电容元件之间交替流动。所以电感上的电流和电容上的电压将会周期性变化（两者互呈90°）\n\n⠀⠀所有的特斯拉线圈都至少有一个谐振回路：它存在于次级线圈中\n\n⠀⠀次级线圈的漆包线绕在绝缘体上，相距很近而互相绝缘，所以匝间形成了寄生电容。这些寄生电容可以等效成一个固有电容，与次级线圈螺线管形成固有电感并联，形成了一个谐振回路\n\n![特斯拉线圈次级回路等效图](https://image.overlooked.top/img/drsstc/two/6.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">特斯拉线圈次级回路等效图</center><br>\n\n⠀⠀为了从顶端放出电弧，特斯拉线圈的次级线圈底端是接地的。特斯拉线圈的金属顶端与大地间也存在着电容，这个顶端的电容等效与次级线圈的固有电容并联，共同参与谐振\n\n## LC振荡\n\n⠀⠀我们分析一下这个次级线圈的工作过程\n\n![LC振荡就像荡秋千](https://image.overlooked.top/img/drsstc/two/7.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">LC振荡就像荡秋千</center><br>\n\n⠀⠀为了方便理解，我们用荡秋千来比喻次级线圈的振荡。秋千的高度（势能）代表次级线圈中的电容上的电压，秋千的速度（动能）代表次级线圈中的电流\n\n⠀⠀想要击穿空气，我们就要有高电压，我们可以直接把秋千推到很高的位置（高电压）吗？不行，我们太矮了（普通高压变压器的输出电压太低，达不到效果）\n\n⠀⠀别忘了，电容和电感连接在一起，组成的“秋千”是可以摆动（谐振）的\n\n⠀⠀于是，我们将电容充了一些电，然后接在电感上，给电容充电相当于抬高了秋千，接通电路则相当于秋千从最高点释放。于是，电容和电感组成的秋千将会开始周期性的振荡\n\n⠀⠀电容上有电压，所以电容会给电感放电，出现电流，也就是秋千开始向下摆。这个过程，秋千的速度越来越快，相当于电感中电流越来越大，秋千的高度越来越低，相当于电容释放了能量，电压越来越低\n\n⠀⠀终于，秋千摆到了最低点，相当于电容上的电压为零。电容储存的电场能释放完了，而此时秋千的速度最大，也就是电感中的电流最大，电感储存的磁场能最大\n\n⠀⠀由于秋千在最低点有速度（电感中的电流不能突变），显然秋千会越过最低点向另一个方向摆去，也就是电感开始给电容反向充电，释放刚才储存的能量。秋千向另一侧越摆越高，相当于电容上的反向电压越来越高\n\n⠀⠀最终，秋千摆到了另一侧与起点相水平的最高点，相当于电容上的电压达到反向峰值。这时，秋千的速度减为零，也就是电感中的电流为零，磁场能全部释放\n\n![振荡分析](https://image.overlooked.top/img/drsstc/two/8.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">振荡分析</center><br>\n\n⠀⠀到这里，我们完成了次级线圈谐振回路半个振荡周期的分析\n\n⠀⠀之后会发生的事情显而易见。秋千会再摆回原来的位置，原来的高度，按照固定的频率的往复摆动\n\n![LC振荡频率公式](https://image.overlooked.top/img/drsstc/two/9.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">LC振荡频率公式</center><br>\n\n## 能量传递\n\n⠀⠀刚才分析了半天，最后秋千又摆回起点了（能量守恒，电压不变），怎么让秋千摆的高一些（升高电压）呢？\n\n![施加外力使秋千摆得更高](https://image.overlooked.top/img/drsstc/two/10.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">施加外力使秋千摆得更高</center><br>\n\n⠀⠀答案当然是，我们给它施加力（给谐振回路输入能量）。秋千向左摆的时候，我们用向左吹的风去吹它，秋千向右摆的时候，我们用向右吹的风去吹它。虽然我们没有秋千那么高，但是只要我们给秋千能量，我们就可以让秋千越摆越高\n\n⠀⠀所以，给予方向合适的能量供应，次级线圈的电压就会越振越高。因为次级线圈的下端接了地。于是，它的顶端电压就会逐渐振升，直到将空气击穿，开始向外释放能量，形成电弧\n\n⠀⠀我们要用风吹次级回路这个秋千，可以使用初级线圈。我们用初级线圈产生交变磁场，利用电磁感应将能量耦合到次级线圈，给次级线圈提供能量，便相当于用风去吹动秋千\n\n⠀⠀可是我们要提供的风的方向与秋千的运动方向有关。这个要怎么用电路实现？\n\n⠀⠀秋千的运动方向，也就是次级线圈谐振回路中的电流方向\n\n⠀⠀我们可以把次级线圈谐振回路中的电流取样，然后跟零去作比较。电流比零大，那么我们就知道秋千在向右摆，我们就要用向右的风去吹秋千让它加速（初级线圈通入正电压）。电流比零小，那么我们就知道秋千在向左摆，我们就要用向左的风去吹秋千让它加速（初级线圈通入负电压）。这样秋千就会越摆越高\n\n![自己设计的TC](https://image.overlooked.top/img/drsstc/two/11.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">自己设计的TC</center><br>\n\n⠀⠀依照上面的思路，我们设计了一台特斯拉线圈。它利用电流互感器（橙色圈）取样次级谐振回路中的电流方向，然后驱动初级线圈。是不是很简单？\n\n⠀⠀但是，别忘了，次级线圈的电容是寄生的。我们找不到它与次级线圈的连接线，自然也无法布置电流互感器去取样回路的电流。。。\n\n![次级反馈](https://image.overlooked.top/img/drsstc/two/12.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">次级反馈</center><br>\n\n⠀⠀所以我们把电流互感器接在这里，次级线圈的接地点\n\n⠀⠀这样也是可以工作的，为什么？因为放电顶端和电弧对大地存在电容\n\n⠀⠀因为这个电容的存在，所以次级线圈的接地线中有次级谐振电流的一部分。把电流互感器接在这里，我们同样可以知道次级线圈中谐振电流的方向，即秋千的摆动方向\n\n![天线反馈](https://image.overlooked.top/img/drsstc/two/13.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">天线反馈</center><br>\n\n⠀⠀还有一种方法，不使用电流互感器，而使用天线反馈\n\n⠀⠀天线与放电顶端不直接接触。它们间存在着以空气为介质的电容\n\n⠀⠀当秋千向右摆的时候，也就是顶端电压上升时，电容充电，天线上的电位为正。当秋千向左摆的时候，也就是顶端电压下降时（向负方向上升），电容放电，天线上的电位变为负\n\n⠀⠀所以使用天线接受顶端的电场变化，我们同样可以知道秋千的摆动方向\n\n![接通电路](https://image.overlooked.top/img/drsstc/two/14.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">接通电路</center><br>\n\n⠀⠀于是我们使用上面的框图设计了一个电路，将其接通\n\n⠀⠀只见次级线圈不断接受初级线圈的能量，电压越振越高，最终将空气都击穿了\n\n⠀⠀我们设计的次级反馈固态特斯拉线圈（SSTC）便成功了！\n\n![这个电路中有灭弧器，它的作用我们以后的章节再讲](https://image.overlooked.top/img/drsstc/two/15.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">这个电路中有灭弧器，它的作用我们以后的章节再讲</center><br>\n\n⠀⠀分析一下这台SSTC的电路，是不是发现与我们设计的思路一样呢？\n\n## SGTC原理\n\n⠀⠀我们说过，特斯拉线圈至少有一个谐振回路。那么，什么种类的特斯拉线圈，有两个谐振回路呢？\n\n⠀⠀最古老的特斯拉线圈：火花隙特斯拉线圈（SGTC），就有两个谐振回路\n\n⠀⠀SGTC的初级线圈和高压电容组构成一个谐振回路，次级线圈和寄生电容构成一个谐振回路\n\n![SGTC经典电路](https://image.overlooked.top/img/drsstc/two/16.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">SGTC经典电路</center><br>\n\n⠀⠀同样，我们把这两个回路分别比作两个秋千\n\n⠀⠀在SGTC电路中，这两个回路的固有频率相等，所以两个秋千的往复摆动频率一样\n\n⠀⠀下面开始分析SGTC的工作原理：\n\n⠀⠀接通电源后，电路由火花隙断开，而高压电容组开始充电储能（初级回路的秋千渐渐抬高）\n\n⠀⠀由于初级线圈的直流阻抗为零，电容组的电压会全部加在火花隙的两端。所以电容电压充到足够高时，打火间隙间的空气会被击穿\n\n⠀⠀火花间隙被击穿后，被电火花短路。它的电阻瞬间由很大降至接近零，相当于充满电的主电容和初级线圈接通，秋千被释放\n\n![能量传递](https://image.overlooked.top/img/drsstc/two/17.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">能量传递</center><br>\n\n⠀⠀于是，初级回路的秋千开始往复摆动，也就是初级线圈中的电流开始往复变化。而次级回路中因为没有能量，次级的秋千还处于静止\n\n---\n⠀⠀次级的秋千并不会一直静止下去\n\n⠀⠀由于两个秋千是相互耦合的，可以互相传递能量，而且它们的的固有频率相等，所以他们会发生共振。。。\n\n⠀⠀能量会依靠交变磁场从初级线圈逐渐向次级线圈转移\n\n![能量传递示意图](https://image.overlooked.top/img/drsstc/two/18.gif)\n<center style=\"font-size:14px;color:#A0A0A0;\">能量传递示意图</center><br>\n\n⠀⠀如图，能量从初级线圈（一个球），渐渐传递到次级线圈（另一个球），次级线圈（另一个球）的震荡幅度越来越大，电压逐渐升高，直到击穿空气\n\n![能量传递实际是有损耗的](https://image.overlooked.top/img/drsstc/two/19.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">能量传递实际是有损耗的</center><br>\n\n⠀⠀如果空气一直没有被击穿，则能量会像上图这样，在初级回路和次级回路间来回转移，慢慢被损耗。不过通常情况下，次级线圈在接受到一部分能量时，就会击穿空气发生放电，释放能量，我们就能欣赏电弧了\n\n---\n⠀⠀那么有个问题，为什么初级线圈不能放电，而要把能量转移到次级线圈中才能击穿空气发生？\n\n⠀⠀这是因为初级和次级回路的参数不同\n\n⠀⠀回顾之前的LC电路频率公式，我们发现，电容和电感的乘积相等，谐振频率就会相等\n\n⠀⠀但是，初级和次级回路的谐振频率相等，然而初级回路的电容大，电感小，次级回路电容小，电感大\n\n⠀⠀所以，在同样的能量下，初级回路的谐振特点是，电流大，电压低。而次级回路则是电流小，电压高。显然击穿空气要靠高电压的次级线圈\n\n⠀⠀用秋千来比喻的话：两个秋千的吊绳长度相同（单摆的摆动频率相同）。但是初级回路秋千重量为1000Kg，次级回路秋千重量为0.1kg（这个比例比较接近实际）\n\n⠀⠀初始状态，1000Kg的重秋千（电容大）从1米高（比较低的电压）释放。而当这个重秋千的能量（动能、势能）全都转移到轻的秋千（电容小）上时，轻的秋千就能摆到很高很高，高到能将空气击穿\n\n## DRSSTC原理\n\n⠀⠀本教程要介绍的双谐振固态特斯拉线圈（DRSSTC），结合了上述两种线圈（SSTC、SGTC）的部分特点\n\n⠀⠀DRSSTC同次级反馈的SSTC一样也是依靠电流反馈运行，DRSSTC同SGTC一样有初级和次级两个谐振回路\n\n⠀⠀不同的是，与SSTC相比，DRSSTC反馈的是初级线圈谐振回路中的电流。所以DRSSTC的驱动电路只负责初级线圈回路的振荡，次级线圈只是个接受能量的附属物\n\n![CW运行的DRSSTC初级回路](https://image.overlooked.top/img/drsstc/two/20.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">CW运行的DRSSTC初级回路</center><br>\n\n⠀⠀DRSSTC的驱动电路的结构与SSTC相似。它按初级线圈电流方向，也就是初级回路秋千的摆动方向，来直接推动初级的秋千\n\n⠀⠀DRSSTC的初级回路是串联谐振接法。初级线圈和主电容串联后由功率桥驱动。谐振回路的电流（电感电流）直接从功率桥流过，由功率器件承担。谐振回路的电压（电容电压）通常很高（达到上千伏，超过功率器件的耐压），但不需要由功率器件承受\n\n⠀⠀推动初级回路的放大电路是功率桥。功率桥是一个可以输出+100V或-100V的电源（假设DRSSTC的供电电压是100V）。功率桥接受初级电流与零比较的结果（大于或者小于），输出+100V或-100V的电压，来推动初级回路这个秋千\n\n![自激串联谐振电路](https://image.overlooked.top/img/drsstc/two/21.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">自激串联谐振电路</center><br>\n\n⠀⠀我们搭一个自激串联谐振电路来模拟DRSSTC的初级回路\n\n⠀⠀前面说过，功率桥是按初级线圈回路电流方向来直接推动初级的秋千的。在这个电路中，我们用R1来对初级电流进行采样，与零比较以计算出初级的电流方向，然后输出+100V或-100V，驱动串联谐振回路\n\n![仿真图](https://image.overlooked.top/img/drsstc/two/22.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">仿真图</center><br>\n\n⠀⠀由仿真图可见，电路起振后，电流曲线（蓝色线）在穿过x轴后，电流方向改变。所以功率桥的输出电压（红色线）也改变极性。同时，我们注意到驱动电压改变极性的点也是主电容电压最高的时候\n\n⠀⠀所以，功率桥每次的输出极性改变（例如输出由+100V变为-100V），都相当于将谐振回路的电压抬高了200V。功率桥通过这种方法向串联谐振回路注入了能量，将秋千推的越摆越高\n\n⠀⠀从图中还可以看到，谐振回路的内阻R2会使电流上升逐渐减缓\n\n---\n⠀⠀分析完了DRSSTC初级的串联谐振回路是如何被驱动的，剩下的就简单啦\n\n⠀⠀还记得之前讲的SGTC嘛？能量在初级回路和次级回路间来回转移的那个。DRSSTC也是这样运行的\n\n![为了便于观察，这里的初级回路和次级回路使用了相同的电参数](https://image.overlooked.top/img/drsstc/two/23.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">为了便于观察，这里的初级回路和次级回路使用了相同的电参数</center><br>\n\n⠀⠀上图为DRSSTC的运行波形\n\n⠀⠀电路开始工作后，由过零比较器驱动的功率桥，不断为初级线圈谐振回路注入能量，初级电压曲线（绿色）开始振升\n\n⠀⠀之后，通过电压的包络线，可以观察到能量在初级线圈和次级线圈中不断来回传递\n\n⠀⠀实际上，能量传递到次级线圈，使次级线圈电压振升到足够高的时候，空气就被击穿啦。之后能量被电弧释放，灭弧电路也会让功率桥停止工作，这样可以避免电流过大导致电路损坏\n\n## 名词解释\n\n### 功率管的软开关与硬开关\n\n⠀⠀功率管，就是一个可以控制的开关\n\n![硬开启](https://image.overlooked.top/img/drsstc/two/24.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">硬开启</center><br>\n\n⠀⠀我们把功率管两端的电压和通过的电流随时间变化的曲线画出来。这个图是功率管的硬开启。可以看到，功率管开启后，流过功率管的电流上升，而功率管两端的电压被导通的功率管下拉\n\n⠀⠀电压曲线与电流曲线的乘积（紫色曲线）是耗散在功率管上的热功率。显然此时这个功率大于零，所以功率管存在开关损耗（阴影部分为损耗）\n\n⠀⠀硬关断时，情况类似，功率管也会有开关损耗\n\n⠀⠀DRSSTC初级回路中的电流通常有几百安，电压有几百伏。我们可以想象，如果发生硬开关，将会有多大的开关损耗，功率管会有多热，炸的会有多惨。。。\n\n⠀⠀不过还好，回顾我们之前分析的电路，DRSSTC的功率桥受电流过零信号的驱动，总是在谐振电流过零点改变输出极性。所以功率桥中的功率管也总是在流过电流为零的时候开启或关闭。我们称之为零电流开关（ZCS）\n\n![ZCS](https://image.overlooked.top/img/drsstc/two/25.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">ZCS</center><br>\n\n⠀⠀ZCS是软开关计数的一种\n\n⠀⠀ZCS的波形像上一样，电压曲线和电流曲线没有交叠\n\n### 移相驱动\n\n⠀⠀在DRSSTC电路中，我们检测初级谐振电流的过零点，来控制功率桥在谐振电流为零时输出跳变，实现了ZCS\n\n⠀⠀然而实际的DRSSTC电路中，电流互感器、驱动电路、和开关器件（IGBT）等都会引入时间的延迟，使功率桥输出跳变的时间推后\n\n![电路延迟](https://image.overlooked.top/img/drsstc/two/26.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">电路延迟</center><br>\n\n⠀⠀延迟会导致DRSSTC的工作波形像上图这样。在初级回路电流波形在过零之后的一段时间，电路才会检测到，然后再过一段时间，功率器件才会开关\n\n⠀⠀从上图可以看出，延迟会导致功率器件在谐振回路存在电流时发生开关，造成了硬开关的出现。而延迟的时间越长，硬开关越严重\n\n⠀⠀延迟还会降低功率桥驱动谐振回路的功率因数，使初级回路的电流振升变慢\n\n⠀⠀所以，我们在规模较大的DRSSTC 和频率较高的小型DRSSTC中，使用移相驱动\n\n![移相驱动的输入部分](https://image.overlooked.top/img/drsstc/two/27.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">移相驱动的输入部分</center><br>\n\n⠀⠀使用移相驱动可以补偿电路延迟\n\n⠀⠀移相驱动的电流互感器反馈输入接有电阻和电感，它可以将电流互感器反馈回的信号的过零点超前一个相位角\n\n⠀⠀我们知道，工作周期乘上超前相位角，就是超前的移相时间。我们让超前的这部分时间等于延迟时间，便可以抵消延迟\n\n⠀⠀但是移相驱动也不是完美的。DRSSTC中的延迟时间几乎是定值，而移相驱动通过超前相位角来移相。所以，当DRSSTC的工作频率发生较大变化时（例如QCWDRSSTC电弧增长的过程中，频率降低明显），超前的相位角乘以工作周期，将不再等于延迟时间，移相对电路的改善效果的效果会下降\n\n### 耦合度\n\n![K≠1的变压器示意图](https://image.overlooked.top/img/drsstc/two/28.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">K≠1的变压器示意图</center><br>\n\n⠀⠀如上图。变压器的初级线圈和次级线圈都存在漏感（上图中的Le），漏感形成的磁通称为漏磁通，它不经过主磁路，所以不参与耦合传递能量，没有变压的作用\n\n⠀⠀DRSSTC的耦合度与初级线圈的形状和位置有关，但总体通常都较低\n\n⠀⠀也就是说，特斯拉线圈的初级线圈、次级线圈的漏感很大。初级线圈和次级线圈的主要功能是参与谐振，能量传输能力并不强\n\n⠀⠀那么，我们提高耦合度，增加初级、次级线圈之间的能量传输能力，对DRSSTC的工作有什么影响呢？\n\n![低耦合度的DRSSTC](https://image.overlooked.top/img/drsstc/two/29.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">低耦合度的DRSSTC</center><br>\n\n![高耦合度的DRSSTC](https://image.overlooked.top/img/drsstc/two/30.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">高耦合度的DRSSTC</center><br>\n\n⠀⠀可以发现，低耦合度的DRSSTC和高耦合度的DRSSTC相比有两个不同：\n\n⠀⠀低耦合度时，DRSSTC的初级回路电流峰值更大。而高耦合度时，初级线圈的能量快速的向次级线圈传递，导致电流振不高\n\n⠀⠀在通常的DRSSTC中，我们设计较低的耦合度，来获取较大的初级谐振电流峰值。因为初级谐振电流较大，则回路中的能量较多，电弧也较长\n\n⠀⠀同时，低耦合度时，电流包络线的波动频率较小，高耦合度时，电流包络线的波动频率较大。通过对电流波形傅里叶分析可知，包络线的出现，会导致谐振电流的频率分裂，成为一大一小两个新的频率的混合。包络线的振动频率就是两个新频率的拍频。在通常的DRSSTC中，由于耦合度较低，频率分裂现象不太明显，可以不考虑\n\n⠀⠀综上，DRSSTC使用较低的耦合度\n\n⠀⠀当然DRSSTC的耦合度也不能太小，否则能量传递到次级线圈的速度太慢，而电流振升的速度太快，会引起较大的损耗，降低工作效率\n\n### 电感的品质因数（Q值）\n\n⠀⠀Q值是指电感器在某一频率的交流电压下工作时，所呈现的感抗与其等效损耗电阻之比。电感器的Q值越高，其损耗越小，效率越高\n\n![Q值](https://image.overlooked.top/img/drsstc/two/31.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">Q值</center><br>\n\n⠀⠀特斯拉线圈由空心线圈组成，等效损耗电阻可以认为等于绕制线圈所用线材的电阻\n\n⠀⠀在谐振回路中，Q值正比于电感储存的能量除以电感在一个振荡周期损耗的能量。所以对于特斯拉线圈这个依靠谐振工作的机器，Q值当然是以大为好。Q值大了，线圈的发热损耗就会减小，电流也能振升的更高，所以电弧可以更长\n\n⠀⠀DRSSTC初级线圈通常都用很粗的导体绕制，电阻很小，Q值较高。所以我们分析次级线圈\n\n![固定长度与直径的次级线圈设计参数](https://image.overlooked.top/img/drsstc/two/32.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">固定长度与直径的次级线圈设计参数</center><br>\n\n⠀⠀这是一张DRSSTC的次级线圈设计的数据表\n\n⠀⠀从表中我们可以看出，在我们确定所要绕制的次级线圈的大小后，绕制所用的漆包线越粗，次级线圈的Q值就越大\n\n⠀⠀但是，漆包线越粗，最后绕出的次级线圈的电感就会越小。这就会导致DRSSTC的谐振频率变高。如果用过粗的漆包线绕制次级，工作频率可能会高到开关器件（IGBT）无法承受\n\n⠀⠀所以，在我们确定次级线圈的规模后，Q值就不是越大越好了。我们要在功率管和驱动电路可以承受的工作频率内，尽量提高次级线圈的Q值，增大特斯拉线圈的工作效率\n\n### 浪涌阻抗（Z因子）\n\n⠀⠀我们先看两个电路\n\n![Z因子不同，谐振频率相同的谐振电路](https://image.overlooked.top/img/drsstc/two/33.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">Z因子不同，谐振频率相同的谐振电路</center><br>\n\n![左边浪涌阻抗较小](https://image.overlooked.top/img/drsstc/two/34.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">左边浪涌阻抗较小</center><br>\n\n![右边浪涌阻抗较大](https://image.overlooked.top/img/drsstc/two/35.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">右边浪涌阻抗较大</center><br>\n\n⠀⠀同样谐振频率（L1C1=L2C2）的两个谐振电路，使用同样的电压驱动，花了相同的时间，而前者在电流振升到了1000A，而后者只振到了200A\n\n⠀⠀浪涌阻抗的定义：\n\n![浪涌阻抗的定义](https://image.overlooked.top/img/drsstc/two/36.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">浪涌阻抗的定义</center><br>\n\n⠀⠀可以看出，第一个电路中的浪涌阻抗较小，所以在相同电压驱动下，电流振升更快\n\n---\n⠀⠀由于DRSSTC的次级线圈的参数相对固定，而初级回路只需改变初级线圈和谐振电容就能改变浪涌阻抗，所以我们这里主要分析DRSSTC初级回路的浪涌阻抗大小对工作的影响\n\n![低浪涌阻抗的DRSSTC](https://image.overlooked.top/img/drsstc/two/37.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">低浪涌阻抗的DRSSTC</center><br>\n\n![高浪涌阻抗的DRSSTC](https://image.overlooked.top/img/drsstc/two/38.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">高浪涌阻抗的DRSSTC</center><br>\n\n⠀⠀来看一下初级回路浪涌阻抗不同的DRSSTC的工作有什么区别\n\n⠀⠀显然，初级回路低浪涌阻抗的DRSSTC有着更大的初级谐振电流峰值，而且初级谐振电流到达峰值所需要的时间更短\n\n⠀⠀所以，我们需要的初级回路DRSSTC有更小的浪涌阻抗\n\n⠀⠀小的浪涌阻抗可以带来更大的初级谐振电流，获得更长的电弧。小的浪涌阻抗还能使电流到达峰值的时间缩短。到达峰值后，我们便可以通过灭弧电路切断功率器件，从而减轻功率器件的压力\n\n⠀⠀要让初级回路有更小的浪涌阻抗，我们可以增加谐振电容的容量，减小初级线圈的圈数。当然，浪涌阻抗也不能减的太小啦。不然在功率桥工作的第一个周期，电流就超过限制了，这还怎么友好的玩耍呢。。。\n\n![带有灭弧的DRSSTC的工作波形](https://image.overlooked.top/img/drsstc/two/39.webp)\n<center style=\"font-size:14px;color:#A0A0A0;\">带有灭弧的DRSSTC的工作波形</center><br>\n\n⠀⠀于是我们的DRSSTC的工作过程就确定啦\n\n⠀⠀起振后驱动电路给初级回路注入能量，初级回路电流振升，同时向次级回路传递能量\n\n⠀⠀初级回路电流达到峰值一段时间后，由灭弧电路使驱动电路停止工作。之后，初级回路中的能量继续传递到次级回路\n\n⠀⠀次级线圈接受能量，电压逐渐升高，直到击穿空气发生放电，将能量释放，产生电弧\n\n---\n⠀⠀不过实际上，DRSSTC并不是靠这么一个工作周期就能产生长长的电弧的\n\n⠀⠀DRSSTC每秒工作数百个周期，而在两个周期之间，电弧产生的导电的离子通道并不会完全消散\n\n⠀⠀于是下一个周期的电弧会利用上一个周期产生的导电通道，继续电离前方的空气\n\n⠀⠀经过一个个周期的叠加，空气被电离击穿的距离越来越长，就形成了长长的电弧啦\n\n---\n⠀⠀最后举一个反例，QCWDRSSTC。它的耦合度很高，初级回路的浪涌阻抗也很高（使用较小的谐振电容和较多的初级圈数），这是为了压制初级回路电流的振升速度\n\n⠀⠀它的一个周期长达数十毫秒，所以只需一个周期就能形成长长直直的电弧啦\n\n![QCWDRSSTC](https://image.overlooked.top/img/drsstc/two/40.gif)\n<center style=\"font-size:14px;color:#A0A0A0;\">QCWDRSSTC</center><br>\n\n> QCWDRSSTC电弧的生长高速摄影，拍摄于2016年\n","tags":["DRSSTC"],"categories":["电子DIY"]},{"title":"DRSSTC教程 第一章 - 特斯拉线圈的分类和欣赏","url":"/post/f40ed205.html","content":"## 前言\n⠀⠀本教程前两个章节将对特斯拉线圈做总体介绍，后续章节开始专门讲解DRSSTC\n\n## 什么是特斯拉线圈\n⠀⠀特斯拉线圈（`Tesla Coil`），通常简称为TC，是一种特殊的`高压变压器`，可以产生`高频高压电场`，击穿空气。空气被击穿后会形成紫色的电晕放电或产生飞舞的电弧\n\n⠀⠀虽然特斯拉线圈可以应用于无线输电等场合，但是`99%`的人制作特斯拉线圈，是为了看电弧。。没错，这个教程是`教你做一台产生电弧的机器，然后看电弧。。`（当然，这台机器还能以奇大的音量的播放一些**单音轨音乐。。**）\n\n⠀⠀雷雨天的闪电只能持续一瞬间，但特斯拉线圈放出的“闪电”却能让我们仔细观赏。如果你对此有兴趣，恭喜你，可以入坑了。。\n\n## 安全说明\n⠀⠀虽然谐振频率较高的特斯拉线圈，其电弧为高频电流，具有一定的`趋肤效应`（貌似趋肤深度也不算浅），人体的神经组织本身也**对高频电流不敏感**，但是，`给电弧点它作为电弧的面子，不要试图去触摸它。。`\n\n⠀⠀否则，至少会被烫伤。如果电流中混有低频交流分量，则还会导致触电。。\n\n⠀⠀另外，特斯拉线圈初级线圈和功率部分的电路，在工作时是`绝对严禁触碰`的。DRSSTC中这部分电路对地带有**工频交流电压**，触碰会导致触电。SGTC的初级回路更是可能让人`一击毙命`。大的**电解电容**在断电后依然可能带有高电压，触碰前应先用电阻放电，否则会导致触电。身上装有心脏起搏器等任何电子医疗器具的人员，请不要操作特斯拉线圈并远离电弧，特斯拉线圈周围的高频电场可能会干扰或损坏这些器具，从而造成严重后果。特斯拉线圈的电弧`带有高温`，启动前应移除附近的可燃物\n\n⠀⠀总之，启动特斯拉线圈时，`站得远一些，不要尝试作死！`\n\n## 分类\n⠀⠀虽然每个特斯拉线圈，看起来都有一个标志性的**筒状次级线圈**，大多数还有一个会喷出电弧的**环形铝顶端**，但是特斯拉线圈的类型还是有很多的。它们之间的主要区别，是`驱动初级线圈的电路不同`\n### 火花间隙特斯拉线圈（SGTC）\n⠀⠀SGTC是古老的特斯拉线圈种类，其标志性的元件是**打火器**和一大堆**串串并并的电容**。SGTC使用高压供电，需要**高压变压器和高压电容组**，较为笨重。但`电路简单，容易制作`。SGTC的调谐方法与DRSSTC差不多。\n\n⠀⠀SGTC输入功率通常在**几十瓦（ZVS供电之类）到几千瓦（微波炉变压器或定制高压变压器）之间**\n\n![SGTC](https://image.overlooked.top/img/drsstc/one/1.webp)\n> 典型的SGTC电路图。主电容匹配合适时，使用工频高压供电甚至可以不必整流\n\n**噪音**：★★★★★\n\n⠀⠀打火器和电弧都会产生噪音，`噪音较大`。不过，理论上能用数控的主动打火器，用来使SGTC播放单音轨音乐，但是似\n乎没人试过，想放音乐的都在玩DRSSTC\n\n**弧长**：★★★★★\n\n⠀⠀SGTC想要电弧长只要`有钱就行`。线圈绕个十米高，电力变压器来一套。。。\n\n![SGTC](https://image.overlooked.top/img/drsstc/one/2.webp)\n> 比如这个国外的33KW的SGTC，可以和右面的房子比一下大小。。。\n\n### 真空管特斯拉线圈（VTTC）\n⠀⠀VTTC是使用`大功率真空管`（例如FU系列）做功率器件的特斯拉线圈，通常为`单管自激`的电路形式，电路非常简单。VTTC需要高压变压器和大电流的灯丝变压器，其高压供电通常整流后不加滤波电容，所以**供电波形为正弦半波**。以正弦半波供电的特斯拉线圈，**电弧通常比较直，分叉少，整体较粗**\n\n⠀⠀真空管可以很轻松的工作在`兆赫兹`级别，而高频（几到几十兆赫兹）连续工作的特斯拉线圈，其产生的电弧为`火焰状`\n\n⠀⠀VTTC输入功率通常在**几百（用几百块钱的电子管）到几千瓦（用几千块钱的电子管）**\n\n![VTTC](https://image.overlooked.top/img/drsstc/one/3.webp)\n> 一个**FU-33**的VTTC电路，VTTC的电路通常比较简单\n\n**噪音**：★☆☆☆☆\n\n⠀⠀使用工频正弦半波供电，电弧的电流波形上升柔和，因而电弧声音中的`高音成分很少，较低沉，音量也较小`\n\n**弧长**：★★★☆☆\n\n⠀⠀弧长`与功率有关`。似乎相同功率的VTTC电弧要比DRSSTC短一些，不过两者电弧形状不同，各有各的风格\n\n### 单管固态特斯拉线圈（SSTC）\n⠀⠀之所以把单管SSTC单独列出来，是因为这货玩的人数太多了。。单管SSTC使用`直流供电，一个MOS管（小功率电路也有用三极管）作功率管，驱动初级线圈`。功率管的驱动电路多种多样，有**自激，定频驱动，锁相环驱动**之类的。有的电路还可以**放音乐**。有的单管SSTC使用门极谐振他激驱动或自激驱动MOS管，频率可以到十几兆赫兹，电弧效果与高频率的VTTC相似\n\n⠀⠀受到单管功率容量的限制，其输入功率通常在**几瓦（三极管自激）到几百瓦（E类拓扑）**\n\n![SSTC](https://image.overlooked.top/img/drsstc/one/4.webp)\n> 单管自激SSTC电路（带音乐调制功能）\n\n![SSTC](https://image.overlooked.top/img/drsstc/one/5.webp)\n> 锁相环单管SSTC(带音乐调制功能）\n\n**噪音**：☆☆☆☆☆ - ★★☆☆☆\n\n⠀⠀噪音与SSTC`是否加了灭弧`有关。小功率的SSTC不加灭弧CW（连续波）工作，基本**毫无声音**。而它加了灭弧会有\n一定的声音，受到功率限制，**音量通常可以忍受**\n\n⠀⠀CW工作并加入**调制电路**后，SSTC能利用电弧**播放音乐**\n\n**弧长**：☆☆☆☆☆ - ★★☆☆☆\n\n⠀⠀单管自激功率下限实在是太低，功率可以小到根本没电弧（但是`能靠电场点亮节能灯`）。而利用E类拓扑也能把功率做大一些，**可以到几百瓦**\n\n### 桥式固态特斯拉线圈（SSTC）\n⠀⠀驱动方式跟单管SSTC相近，也有自激，定频他激，锁相环驱动之类的。功率可以可以比单管的SSTC大一些。`桥式SSTC的功率管一般使用MOS管`\n\n⠀⠀虽然使用了功率桥，但是SSTC功率也做不到太大，因为桥式SSTC的功率管是`硬开关`，`开关损耗较大`。它的输入功率通常在**几百瓦到一千瓦之间**\n\n![SSTC](https://image.overlooked.top/img/drsstc/one/6.webp)\n> 定频驱动的半桥SSTC（带音乐调制功能）\n\n**噪音**：★☆☆☆☆ - ★★★☆☆\n\n⠀⠀同单管SSTC一样，噪音`与是否加灭弧有关`。同样可以**播放音乐**\n\n**弧长**：★★☆☆☆\n\n⠀⠀由于`瞬时功率较小`，SSTC的电弧比同功率的DRSSTC短。但是论播放音乐的话，`DRSSTC只能播放单音轨的方波音乐，SSTC能播放正常的乐曲`\n\n### 双谐振固态特斯拉线圈（DRSSTC）\n⠀⠀DRSSTC是本教程之后将介绍并制作的特斯拉线圈类型。DRSSTC是`初级线圈`**串入了一个**`谐振电容`**组成的**`桥式自激（初级反馈）SSTC`\n\n⠀⠀SSTC驱动初级线圈需要一定的**无功功率**，这会带来一定的**损耗**。而DRSSTC初级有**谐振电容**，`谐振回路功率因数较高`，驱动的损耗便减小了，驱动功率可以提升。较大的驱动功率使初级回路的电流快速振升，传递到次级线圈，带来了`较大的瞬时功率`，也就是较长的电弧\n\n⠀⠀DRSSTC使用市电或市电经自耦调压器降压后`整流供电`。由于要承受较大的`谐振电流峰值`，DRSSTC的功率管基本上都使用的是`IGBT`。输入功率通常在**几百（使用功率管）到几千瓦（并管或使用功率模块）**\n\n⠀⠀DRSSTC由**驱动电路、灭弧电路、功率桥**等组成，电路在以后的章节给出\n\n**噪音**：★★★★☆\n\n⠀⠀强力的电弧在每个工作周期都会**因加热而使空气剧烈膨胀**，在固定频率灭弧时，`会产生很大的噪音`。但是也可以用这种“噪音”播放单音轨的音乐（**音乐灭弧**）\n\n**弧长**：★★★★★\n\n⠀⠀使用功率模块`可以做到较大功率`，产生较长的电弧\n\n### 准连续波双谐振固态特斯拉线圈（QCWDRSSTC）\n⠀⠀此TC其实就是`调制电源`的DRSSTC。原理是使DRSSTC的供电电源在**数十毫秒内沿斜线上升到最大值**，则其**谐振电流也按斜线上升**\n\n⠀⠀这种调制方式可以产生**笔直、无分叉**的`剑状电弧`。不过电弧**每秒只能产生几根**。电源调制通常使用**大功率BUCK电路**，DRSSTC的工作脉宽要达到数十毫秒（普通DRSSTC为数百微秒），为此应减小DRSSTC的谐振电容，增加初级线圈电感，以**压制电流的振升速度**\n\n⠀⠀比起输入功率，QCWDRSSTC的功率似乎更适合用单发电弧的能量（焦耳）来描述\n\n**噪音**：★☆☆☆☆\n\n⠀⠀类似正弦半波供电的VTTC，电流波形缓和的上升，电弧声音中刺耳的高音成分很少，`声音也不算大`\n\n**弧长**：★★★★★\n\n⠀⠀`又长又直的电弧，弧次比（电弧长度除以次级线圈的长度）还奇高`。不过QCW的**电路比较复杂**，要得到这种电弧还是要费些功夫的。此外也有使用特殊的驱动板，不用BUCK电路调制电源就可使初级谐振电流沿斜线上升的方法\n\n⠀⠀其他的比较少见的特斯拉线圈电路形式由于国内玩的人太少，经验不足，在此不做介绍\n\n## 特斯拉线圈电弧欣赏\n### SGTC\n![SGTC](https://image.overlooked.top/img/drsstc/one/7.gif)\n> 此SGTC使用ZVS电路驱动高压包供电，用电磁炉电容串联作为谐振电容组\n\n![SGTC](https://image.overlooked.top/img/drsstc/one/8.webp)\n> 一个微波炉变压器供电的，但是没仔细调谐振，所以电弧不长。。\n\n### VTTC\n![VTTC](https://image.overlooked.top/img/drsstc/one/9.webp)\n![VTTC](https://image.overlooked.top/img/drsstc/one/10.webp)\n> 使用`FU-33`玻璃壳真空管作功率管的VTTC，微波炉变压器倍压整流供电，可以看到半波供电导致的剑状电弧\n\n### SSTC\n![单管自激](https://image.overlooked.top/img/drsstc/one/11.webp)\n> 输入功率15W，电路是单管自激，电路图图已经找不见了，功率管好像是13007\n\n![单管自激](https://image.overlooked.top/img/drsstc/one/12.webp)\n> 输入功率50W的单管自激，可以看出电弧长一些。。\n\n![半桥SSTC](https://image.overlooked.top/img/drsstc/one/13.webp)\n> 这个是定频驱动半桥，市电输入的SSTC，输入功率150W\n\n![高频SSTC](https://image.overlooked.top/img/drsstc/one/15.webp)\n> 一个CW（连续波）工作的高频SSTC\n\n![MOS单管自激](https://image.overlooked.top/img/drsstc/one/16.webp)\n> MOS单管自激，次级超小，弧次比还是挺霸气的。。\n\n![高频自激SSTC](https://image.overlooked.top/img/drsstc/one/17.webp)\n> 工作频率10MHz的高频自激SSTC，CW工作，电弧像火焰\n\n![锁相环SSTC](https://image.overlooked.top/img/drsstc/one/18.webp)\n> 锁相环驱动的CW工作的SSTC，输入频率1MHz，输入功率200W\n\n### QCWSSTC\n![QCWSSTC](https://image.overlooked.top/img/drsstc/one/14.webp)\n> 一个单管定频驱动的迷你QCWSSTC。。可以看到标志性的剑状电弧\n\n![QCWDRSSTC](https://image.overlooked.top/img/drsstc/one/23.webp)\n![QCWDRSSTC](https://image.overlooked.top/img/drsstc/one/24.webp)\n> 一台QCWDRSSTC。。电弧又长又直，弧次比挺霸气的。。  \n\n> **该TC参数如下**：\n⠀⠀`电源部分`：市电整流后，通过 TL494 + G4PC50UD并管 + 75120快恢复 + EE55磁芯组成的boost升压器升压，将 450v 3000uF 的电容充到420V。此BOOST最大功率600W，给电容充电时为恒流工作，充满后维持420V输出\n⠀⠀`BUCK部分`：外部触发信号输入锯齿波发生器，在此信号上升沿处触发锯齿波发生器产生一个脉宽15ms的锯齿波，此锯齿波通过TL494产生一个占空比从0%一直升高到100%的PWM信号，此信号送入隔离驱动器，驱动一个由G4PC50UD四并管 + RGRH75120三并管 + 环形磁芯组成的BUCK电路，此BUCK电路由电源部分的BOOST电路供电，产生一个0 - 420V变化的电压\n⠀⠀`DRSSTC部分`：G4PC50UD二并管全桥组成的DRSSTC ，MMC = 0.012uF，在母线上升至10V时被触发开始工作，一直到一个周期（15ms）结束。次级线圈高20cm，使用0.15mm漆包线绕制\n\n### DRSSTC\n![DRSSTC](https://image.overlooked.top/img/drsstc/one/19.webp)\n> 用小逆变器供电的DRSSTC，功率开不大\n\n![DRSSTC](https://image.overlooked.top/img/drsstc/one/20.webp)\n> 这台线圈比较大，但这张图只开了60W功率。。\n\n![DRSSTC](https://image.overlooked.top/img/drsstc/one/21.webp)\n> 输入功率400W，算是一台比较正常的小DRSSTC了\n\n![DRSSTC](https://image.overlooked.top/img/drsstc/one/22.webp)\n> 挺漂亮的一台一体化DRSSTC，输入功率大概600W左右\n\n![DRSSTC](https://image.overlooked.top/img/drsstc/one/25.webp)\n> 一台CW工作的DRSSTC\n\n![DRSSTC](https://image.overlooked.top/img/drsstc/one/26.webp)\n![DRSSTC](https://image.overlooked.top/img/drsstc/one/27.webp)\n> 一台**大功率的DRSSTC**，输入功率**5KW**左右，后文重点介绍的对象\n","tags":["DRSSTC"],"categories":["电子DIY"]},{"title":"计算机网络知识点","url":"/post/5532fc86.html","content":"##  计算机网络的概念\n\n###  定义\n\n一些互连的、独立自治的**计算机集合**。最重要的功能是`连通性和资源共享`\n\n###  分类\n\n从网络的作用范围进行分类:  \n> 广域网`WAN (Wide Area Network)`、局域网`LAN (Local Area Network)`、城域网`MAN (Metropolitan Area Network)`、个人区域网`PAN (Personal Area Network)`  \n\n从网络的使用者进行分类:\n> 公用网`(public network)`、专用网`(private network)`、接入网`AN (Access Network)`\n\n##  计算机网络的性能指标\n\n###  基础前置知识\n\n比特(bit)意思是一个二进制数字（0或1）。 `B为字节(Byte)，b为比特(bit)，一字节为8比特，即1B = 8b。` 网络技术中的`数率`指的是**数据的传送速率**，当数据率较高时，常常在bit/s前面加上字母，比如`k = 10³ , M = 10⁶ , G = 10⁹ , T = 10¹²`等。 注意区分网络传输和文件系统中的数据**后缀字母**。比如一个**100MB**的文件，这里的**M**就是**2²⁰**。传输率为**100Mbit/s**，这里的**M**为**10⁶**\n\n###  数据率\n\n又叫`比特率`，指连接在网络上的主机在数字信道上**传送数据的速率**。 速率的单位是:`b/s`，或`kb/s`，`Mb/s`，`Gb/s`等\n\n###  带宽\n\n带宽本来是指信号具有的**频带宽度**，单位是**赫兹**（或**千赫**、**兆赫**、**吉赫**等）。 现在“带宽”是数字信道所能传送的“`最高数据率`”的同义语\n\n###  时延\n\n####  发送时延\n\n发送数据时，数据帧从结点进入到传输媒体所需要的时间：$\\mathrm{发送时延}\\;=\\;\\frac{\\mathrm{数据帧长度}(b)}{\\mathrm{发送速率}(b/s)}$\n\n####  传播时延\n\n电磁波在信道中需要传播一定的距离而花费的时间：$\\mathrm{传播时延}\\;=\\;\\frac{\\mathrm{信道长度}(米)}{\\mathrm{信号在信道上的传输速率}(b/s)}$\n\n####  处理时延\n\n交换结点为存储转发而进行一些必要的处理所花费的时间\n\n####  排队时延\n\n结点缓存队列中分组排队所经历的时延\n\n####  总时延\n\n**总**时延 = **发送**时延 + **传播**时延 + **处理**时延 + **排队**时延\n\n![1.webp](https://image.overlooked.top/img/net-base/1.webp)\n\n###  利用率\n\n`信道利用率`指出某信道有**百分之几的时间**是被利用的  \n`网络利用率`则是全网络的信道利用率的**加权平均值**  \n$D\\;=\\;\\frac{D_0}{1\\;-\\;U}$ $D_0$为网络空闲时的时延，$D$为当前时延，$U$为利用率\n\n##  计算机网络的体系结构\n\n###  OSI的七层协议\n\n从上到下为：`应用层`，`表示层`，`会话层`，`运输层`，`网络层`，`数据链路层`，`物理层`\n\n###  协议的概念\n\n控制两个`对等实体`进行通信而建立的**规则、标准或约定**  \n`语法`：数据与控制信息的结构或格式  \n`语义`：需要发出何种控制信息，完成何种动作以及做出何种响应  \n`同步`：事件实现顺序的详细说明\n\n###  存储转发\n\n路由器在输入链路上`接收整个分组`、`存储接收的分组`、然后`选择输出链路`，并以**最大传输速率向输出链路转发**\n\n###  分组交换技术`☆`\n\n![2.webp](https://image.overlooked.top/img/net-base/2.webp)\n\n**作用**：提高信道利用率，提高抗毁性\n> `端到端数据流`被划分为若干数据块，添加首部形成若干分组，分组首部中携带地址、长度等控制信息  \n> `主机`的用途是为用户进行信息处理，并且可以和其他主机通过网络交换信息  \n> `路由器`的用途则是用来转发分组，即进行分组交换\n\n分组交换的**优点**：\n> `高效`：动态分配传输带宽，对通信链路是逐段占用  \n> `灵活`：以分组为传送单位和查找路由  \n> `迅速`：不必先建立连接就能向其他主机发送分组  \n> `可靠`：保证可靠性的网络协议  \n> `分布式的路由选择协议`使网络有很好的生存性\n\n###  五层结构（OSI与TCP/IP的折中方案）\n\n####  应用层\n\n是体系中的最高层，任务是`通过应用进程间的交互来完成特定网络应用`，把**应用层交互的数据单元**称为`报文`\n\n####  运输层\n\n为两台主机中`进程`之间的通信`提供通用的数据传输服务`，主要用到以下两种协议：\n\n- `TCP`：传输控制协议（`Transmission Control Protocol`），提供面向连接，可靠地数据传输服务，其数据传输的单位是`报文段`\n- `UDP`：用户数据报协议（`User Datagram Protocol`），提供无连接的，尽最大努力的数据传输服务，`是不可靠的`，其数据传输的单位是`用户数据报`\n\n####  网络层\n\n负责为分组交换网上的`不同主机`提供`通信服务`  \n\n在发送数据时，网络层把运输层产生的报文段或者用户数据报**封装成**`分组或包`进行传送\n> 网络层在TCP/IP体系中`使用IP协议`，因此`分组`也叫做`IP数据报`\n\n####  数据链路层\n\n两台主机之间的数据传输，总是在一段一段的**链路**上进行传送的，需要使用专门的**链路层协议**\n\n在两个相邻结点之间传送数据时，数据链路层将网络层交下来的`IP数据报`组装成`帧`，在两个`相邻结点`之间的**链路**上传送帧。每一帧包括**数据**和必要的**控制信息**（同步信息，地址信息，差错控制等）。\n在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样数据链路层在接收到一个帧后，就可以从中提取出数据部分，上交给网络层\n\n####  物理层\n\n物理层利用**传输介质**为通信的两端建立、管理和释放物理链接，实现比特流的透明传输，保证比特流正确的传输到对端\n物理层上所传数据的单位是`比特`\n> 注：**传递信息所用的载体（比如双绞线，光缆等）不属于物理层，是物理层下面一层**\n\n###  TCP/IP体系结构（四层结构，IP协议的地位）`☆`\n\n![3.webp](https://image.overlooked.top/img/net-base/3.webp)\n![4.webp](https://image.overlooked.top/img/net-base/4.webp)\n\n## 物理层\n\n物理层考虑的是怎样才能在连接各种计算机的**传输媒体上传输数据比特流**，而`不是`指**具体的传输媒体**\n\n###  数据通信基础`☆`\n\n####  通信方式\n\n`单工`通信：能有一个方向的通信而没有反方向的交互，例如：**广播和电视节目**  \n\n`半双工`通信：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)，例如：**对讲机**  \n\n`全双工`通信：通信的双方可以同时发送和接收信息，例如：**手机**\n\n####  数字信号的编码概念\n\n将数字数据采用数字信号进行编码，数字信号是离散的电压或电流脉冲序列，常用方法是使用脉冲信号来表示二进制数字字符“0”和“1”\n\n####  数字信号的编码方式`☆`\n\n![5.webp](https://image.overlooked.top/img/net-base/5.webp)\n> `不归零制`：正电平代表1，负电平代表0\n> `归零制`：正脉冲代表1，负脉冲代表0\n> `曼彻斯特编码`：位周期中心的向上跳代表0，位周期中心的向下跳代表1，也可以反过来定义\n> `差分曼彻斯特编码`：在每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1\n\n####  信道极限容量\n\n`信噪比`:如果信号相对较强，那么噪声的影响就相对较小，因此信噪比就很重要。\n$\\mathrm{信噪比}(dB)=10\\log_{10}\\left(\\frac SN\\right)$  \n`香农(Shannon)`用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的`极限`、`无差错`的信息传输速率。信道的极限信息传输速率 $C$ 可表达为：$C=W\\log_2\\left(1+\\frac SN\\right)$ ，其中$W$为信道的带宽（以 Hz 为单位）、$S$为信道内所传信号的平均功率、$N$为信道内部的高斯噪声功率\n\n###  传输介质`☆`\n\n####  概念\n\n`泛指`计算机网络中用于连接各计算机的`物理媒体`，`特指`用来连接各个通信处理设备的`物理介质`\n\n####  分类\n\n- **双绞线**：最古老又最常用、价格便宜\n- **光纤**：传输带宽大，传输损耗小，中继距离长，抗干扰能力强（雷电和电磁干扰），保密性好（不易被窃听）体积小，重量轻。精确对接困难\n- **无线电波**：通过空间电磁传播、无需安装物理线路\n- **红外线**：通过空间电磁传播、无需安装物理线路\n\n###  多路复用技术\n\n`复用`是通信技术中的基本概念\n\n####  频分复用\n\n用户被分配在一定频宽后，在通信过程中自始至终都占用这个频带。频分复用的所有用户**在同样的时间占用不同的带宽资源**\n\n####  时分复用\n\n将时间划分为一段段等长的时分复用帧，每一个时分复用的用户在每一个`TDM帧`中占领固定序号的时隙，时分复用的所有用户是**在不同的时间占用同样的频带宽度**\n\n####  码分复用\n\n更常用的名词是`码分多址CDMA`，每个用户可以**在同样时间使用同样频带进行通信**，具有很强的**抗干扰性**\n\n###  宽带接入技术\n\n####  ADSL\n\n非对称数字用户线，ADSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务\n\n####  HFC\n\n`光纤同轴混合网HFC`，HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务\n\n##  数据链路层\n\n###  使用点对点信道的数据链路层\n\n这种信道使用一对一的点对点通信方式\n\n####  封装成帧\n\n`封装成帧(framing)`就是在一段数据的前后分别添加**首部**和**尾部**，然后就构成了一个帧\n\n####  透明传输\n\n`字节填充或字符填充`：发送端的数据链路层在数据中出现**控制字符\"SOH\"或\"EOT\"**的前面插入一个**转义字符\"ESC\"**(其十六进制编码是**1B**)。 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个\n\n####  差错控制\n\n在传输过程中可能会产生比特差错：**1 可能会变成 0 而 0 也可能变成 1**  \n在一段时间内，传输错误的比特占所传输比特总数的比率称为`误码率 BER (Bit Error Rate)`。误码率与信噪比有很大的关系，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 数据链路层广泛使用`循环冗余检验 CRC`的检错技术\n\n####  CRC循环冗余检验\n\n以下运算皆使用`二进制的模2运算`  \n\n**CRC冗余码的生成**：先进行$2^n$乘M(待发送的数码)，其相当于在M后面加n个零，M(k位)是原本的数码。然后除以除数P(n+1位)(一般用多项式表示，比如P为1101,用多项式表示就是$P(x) = x^3+x^2+1$，就是对应位)，得到的余数(n位)就是冗余码，把它拼接到尾部即可\n\n**CRC冗余码的检验**：将收到的数码(k+n位)除以事先商定好的除数P(n+1位)，得出的余数为R(n位)，如果`R为0说明没有差错`\n\n####  点对点协议PPP\n\n现在全世界使用得最多的**数据链路层协议**是**点对点协议 PPP (Point-to-Point Protocol)**。 用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议\n\n####  零比特填充\n\n\n**在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除**\n\n###  使用广播信道的数据链路层`☆`\n\n这种信道使用`一对多`的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用`专用的共享信道协议`来协调这些主机的数据发送。\n\n####  局域网\n\n局域网最主要的**特点**是：网络为一个单位所拥有，且地理范围和站点数目均有限  \n\n局域网具有如下的一些主要优点：\n> 具有**广播**功能，从一个站点可很方便地访问全网\n> 局域网上的主机可**共享连接**在局域网上的各种硬件和软件资源\n> 便于系统的**扩展**和逐渐地**演变**，各设备的位置可灵活调整和改变\n> 提高了系统的**可靠性、可用性和残存性**\n\n####  CSMA/CD协议\n\n`CSMA/CD`：载波监听多点接入/碰撞检测\n\n+ `多点接入`表示许多计算机以多点接入的方式连接在一根总线上\n+ `载波监听`是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞\n+ `碰撞检测`就是计算机边发送数据边检测信道上的信号电压大小。 当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞\n\n###  使用广播信道的以太网`☆`\n\n以太网：**施乐公司**1975年研制的**基带总线局域网**，数据率为**2.94Mb/s**，使用集线器的星形拓扑，传统以太网最初是使用**同轴电缆**，后发展为使用更便宜和更灵活的**双绞线**。这种以太网采用**星形拓扑**，在星形的中心则增加了一种可靠性非常高的设备，叫做**集线器(hub)**\n\n####  以太网的利用率\n\n发送一帧占用线路的时间是 $T_0+t$，而帧本身的发送时间是 $T_0$，要提高信道利用率必须**减小** $t$ **与** $T_0$ **的比值**\n\n首先定义参数 $a: a=\\frac{t}{T_0}$，在**理想**的情况下，以太网上的各站发送数据**都不会产生碰撞**，即总线一旦空闲就有某一个站立即发送数据，于是我们可计算出理想情况下的极限信道利用率为：$S_{max}=\\frac{T_0}{T_0+t}=\\frac1{1+a}$\n\n####  以太网的MAC层\n\n**硬件地址**又称为**物理地址**，或**MAC地址**，用于在网络中**唯一标识**一个网络终端设备。MAC 地址共48位（6个字节）。前24位由IEEE（电气和电子工程师协会）决定如何分配，后24位由实际生产该网络设备的厂商自行制定\n\n##  网络层\n\n###  网络层概述\n\n**基本服务**：`主机到主机`的端到端通信服务\n网络层要解决的**基本问题**：`异构网络`互联的方法\n提供何种类型的**网络服务**：主机编址，数据转发与路由选择\n网络层**向上**只提供`简单灵活的`、`无连接的`、`尽最大努力交付`的数据报服务\n\n###  IP地址`☆`\n\n网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一\n\n####  分类的IP地址（A,B,C,D）\n\n![6.webp](https://image.overlooked.top/img/net-base/6.webp)\n\n**IP的指派范围：**\n![7.webp](https://image.overlooked.top/img/net-base/7.webp)\n**一般不使用的特殊IP：**\n![8.webp](https://image.overlooked.top/img/net-base/8.webp)\n\n####  IP地址和硬件地址(MAC)\n\n`物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址`\n\nIP地址是一种**逻辑地址**(因为IP地址是用软件实现的)，在发送数据时，数据从高层下到低层，然后才能到通信链路上传输，使用IP地址的IP数据报一旦交给了数据链路层，就被封装成MAC帧了\nMAC帧在传送时使用的源地址和目的地址都是**硬件地址**，这两个硬件地址都写在了MAC帧首部。 IP地址放在IP数据报首部，硬件地址规则放在MAC帧的首部，在`网络层以上使用的都是IP地址`，`在数据链路层及以下使用的都是硬件地址`\n\n####  地址解析协议ARP\n\n不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。通过`地址解析协议ARP`即可知道IP地址对应的MAC值。 ![9.webp](https://image.overlooked.top/img/net-base/9.webp)\n\n#### 划分子网（子网掩码）\n\n从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分\n使用`子网掩码(subnet mask)`可以找出**IP地址中的子网部分**\n子网掩码的二进制值高位**连续为1时**，对应的IP地址值为**子网号**；子网掩码二进制值**连续为0时**，对应的IP地址值为**主机号**\n![10.webp](https://image.overlooked.top/img/net-base/10.webp)\n\n#### CIDR地址块\n\nCIDR(Classless Inter-Domain Routing)全称是**无分类域间路由选择**，也称**无分类编址**，它也是构成超网的一种技术实现\n\nCIDR在一定程度上解决了**路由表项目过多过大**的问题。CIDR之所以称为无分类编址，就是因为CIDR完全放弃了之前的分类IP地址表示法，它真正消除了传统的A类、B类、C类地址以及划分子网的概念，它使用如下的IP地址表示法：\n**IP地址 ::= {<网络前缀>， <主机号>} / 网络前缀所占位数**\n\n![11.webp](https://image.overlooked.top/img/net-base/11.webp)\n\n###  网际控制报文协议ICMP\n\n为了提高 IP 数据报交付成功的机会，在网际层使用了**网际控制报文协议 ICMP (Internet Control Message Protocol)**来允许主机或者路由器**报告差错和异常情况**\n> ICMP不是高层协议，而**是IP层的协议**\n> ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去\n> ICMP差错报文类型：终点不可达、源点抑制(Source quench)、时间超过、参数问题、改变路由(重定向，即Redirect)\n\n####  应用：ping和tracert命令\n\nPING 用来测试两个主机之间的连通性\nPING 使用了 ICMP 回送请求与回送回答报文\nPING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或 UDP\nTracert 是测试报文从发送端到目的地所经过的路由的方法，它能够直观展现报文在转发的时候所经过的路径\n\n###  因特网的路由选择协议\n\n####  RIP\n\n`路由信息协议（Routing Information Protocol）`是内部网关协议IGP中最先得到广泛使用的协议\n\nRIP是一种分布式的`基于距离向量`的路由选择协议，是**因特网的标准协议**，其最大优点就是`简单`。 RIP协议的距离也称为`跳数`，每经过一个路由器，跳数就加1\nRIP认为一个好的路由就是它通过的路由器的**数目少**，即**距离短**。 RIP协议要求网络中的每个路由器都要维护从它自己到其他每一个目的网络的距离\nRIP 协议最大的优点就是`实现简单，开销较小`。 RIP 协议具有一个特点：**好消息传播得快，而坏消息传播得慢**\nRIP 限制了网络的规模，它能使用的**最大距离为 15（16 表示不可达）**。 路由器之间交换的路由信息是路由器中的**完整路由表**，因而随着网络规模的扩大，开销也就增加\n\n####  OSPF\n\n`开放式最短路径优先OSPF（Open Shortest Path First）`是IETF组织开发的一个`基于链路状态`的**内部网关协议（Interior Gateway Protocol）**\n\nOSPF协议的基本特点:\n+ **开放**：表明 OSPF 协议不是受某一家厂商控制，而是公开发表的\n+ **最短路径优先**：使用了 Dijkstra 提出的最短路径算法SPF，实现了最短路径优先（注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是 \"最短路径优先\"）\n+ 是分布式的**链路状态协议**\n\n##  运输层\n\n###  运输层概述\n\n![12.webp](https://image.overlooked.top/img/net-base/12.webp)\n\n###  端口\n\n进程的创建和撤销都是动态的，通信的一方几乎无法识别对方机器上的进程，解决这个问题的办法就是在**运输层使用协议端口号，简称端口**\n\n这种在协议层间的抽象协议端口是`软件端口`，注意和路由器或交换机上的`硬件端口`进行区分，硬件端口是不同硬件设备进行交互的接口，软件接口是应用层的各种协议进程与运输实体进行层间交互的一种地址\n\n###  用户数据报协议UDP\n\n####  功能\n\nUDP只是在IP的数据报服务上加了很少一点功能，这就是`复用和分用`功能以及`差错检测`功能\n\n####  特点\n\n- **无连接**：发送数据前不需要建立连接，减少开销和发送数据之前的时延\n- **尽最大努力交付**：也就是`不保证可靠交付`，主机不需要维持复杂的连接状态表（这里面有很多参数）\n- **面向报文**：应用层给UDP多长的报文，UDP就照样发送\n- **无拥塞控制**：`网络上出现的拥塞不会使源主机的发送速率降低`，但是可能会出现严重的网络拥塞\n- **UDP首部开销小**：只有8个字节，比TCP的20个字节短很多\n- **支持一对一，一对多，多对一和多对多交互通信**\n\n###  传输控制协议TCP`☆`\n\n####  特点\n\n- TCP 是**面向连接**的运输层协议：进程在使用TCP通信之前必须先建立TCP连接\n- 每一条 TCP 连接**只能有两个端点**，每一条 TCP 连接只能是`点对点`的（一对一）\n- TCP 提供**可靠交付**的服务：通过TCP连接传送的数据，`无差错`，`不丢失`，`不重复`，并且`按序到达`\n- TCP 提供**全双工通信**：TCP允许通信双方的应用程序在**任何时刻**都能发送数据，TCP连接的两端都设有**发送缓存和接收缓存**，用来临时存放双向通信数据\n- **流量控制**：发送方不能淹没接收方\n- **拥塞控制**：抑止发送方速率来防止过分占用网络资源\n- **面向字节流**：TCP中的\"流(stream)\"指的是流入进程或从进程流出的字节序列。面向字节流的含义是：\n虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成一连串无结构的字节流，TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小关系（例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序）。这就要求开发者自己做好**分包**和**粘包**操作\n![13.webp](https://image.overlooked.top/img/net-base/13.webp)\n\n####  TCP可靠传输`☆`\n\n由于TCP发送的报文段是交给IP层发送的，而IP层不是可靠传输，所以TCP自己需要采用适当措施才能使两个运输层之间通信可靠\n\n#####  停止等待协议\n\n在发送完一个分组后，必须**暂时保留**已发送的分组的副本\n分组和确认分组都必须进行**编号**\n超时计时器的**重传时间**应当比数据在分组传输的平均往返时间更长一些\n![14.webp](https://image.overlooked.top/img/net-base/14.webp)\n![15.webp](https://image.overlooked.top/img/net-base/15.webp)\n使用上述的确认和重传机制，我们就可以**在不可靠的传输网络上实现可靠的通信**\n这种可靠传输协议常称为**自动重传请求**`ARQ(Automatic Repeat reQuest)`\nARQ 表明重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组\n\n#####  改进(连续ARQ协议)\n\n停止等待协议的优点是**简单**，但缺点是**信道利用率太低**\n\n发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 接收方一般采用累积确认的方式，即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了\n\n**优点是**：容易实现，即使确认丢失也不必重传\n**缺点是**：不能向发送方反映出接收方已经正确收到的所有分组的信息\n\n#####  小知识：TCP报文段首部\n\n![16.webp](https://image.overlooked.top/img/net-base/16.webp)\n\n#####  滑动窗口协议\n\n**特点**：接收方会把自己的接收窗口数值放在窗口字段发送给对方\n![17.webp](https://image.overlooked.top/img/net-base/17.webp)\n![18.webp](https://image.overlooked.top/img/net-base/18.webp)\n![19.webp](https://image.overlooked.top/img/net-base/19.webp)\n\n#####  超时重传\n\n**重传机制**是 TCP 中最重要和最复杂的问题之一\n\nTCP 每发送一个报文段，就对这个报文段设置一次计时器\n只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段\n超时计时器的重传时间应当比数据在分组传输的平均往返时间RTT更长一些\n\n######  加权平均往返时间\n\nTCP 保留了 RTT 的一个`加权平均往返时间` $RTT_S$(这又称为平滑的往返时间)\n第一次测量到 RTT 样本时，$RTT_S$ 的值就取为所测量到的 RTT 样本值，以后每测量到一个新的 RTT 样本，就按下式重新计算一次$RTT_S$：\n\n> $\\mathrm{新的}RTT_S=\\left(1-\\alpha\\right)\\times(\\mathrm{旧的}RTT_S)+\\alpha\\times(\\mathrm{新的}RTT\\mathrm{样本})$\n\n其中，**RFC2988** 推荐的 $\\alpha$ 值为 1/8，即 0.125\n\n######  超时重传时间RTO\n\n`超时重传时间RTO`应略大于上面得出的加权平均往返时间$RTT_S$\n\n**RFC2988**建议使用下式计算 RTO：\n\n> $RTO=RTT_S+4\\times RTT_D$\n\n其中，$RTT_D$ 是 RTT 的`偏差的加权平均值`，**RFC2988**建议这样计算$RTT_D$：\n第一次测量时，$RTT_D$值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的$RTT_D$：\n\n> $\\mathrm{新的}RTT_D=(1-\\beta)\\times(\\mathrm{旧的}RTT_D)+\\beta\\times(RTT_S-\\mathrm{新的}RTT\\mathrm{样本})$\n\n其中 $\\beta$ 推荐值为0.25\n\n####  TCP的运输连接管理\n\n运输连接的三个阶段：`连接建立`、`数据传送`和`连接释放`\n\n运输连接的管理就是使运输连接的建立和释放都能正常地进行\n\n连接建立过程中要解决以下三个问题\n+ 要使每一方能够确知对方的存在\n+ 要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）\n+ 能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配 \n![20.webp](https://image.overlooked.top/img/net-base/20.webp)\n\n为什么不使用两次握手来建立TCP连接？\n> 三次握手可`防止已失效的连接请求报文`导致建立无效的TCP连接\n\n![21.webp](https://image.overlooked.top/img/net-base/21.webp)\n\n##  应用层\n\n不同的网络应用的应用进程之间，还需要有不同的通信规则，因此在运输层协议上，还需要有应用层协议\n\n###  域名系统DNS\n\n是互联网使用的`命名系统`，用来把便于人们使用的`机器名字`转换为`IP地址`，例如：\n> www.baidu.com　--->　[39.156.66.14](http://39.156.66.14)\n\n####  域名结构\n\nDNS采用了`层次化树状`的命名方法\n\n域名：唯一的层次结构名字\n域：名字空间中一个可被管理的划分，还可划分子域 如：[mail.cctv.com](http://mail.cctv.com)\n\n###  文件传输协议FTP\n\nFTP是因特网上使用得最广泛的文件传送协议\n\nFTP 提供**交互式的访问**，允许客户指明文件的类型与格式，并允许文件具有存取权限\nFTP **屏蔽**了各计算机系统的**细节**，因而适合于在异构网络中任意计算机之间传送文件\nRFC959 定义了FTP协议规范，其很早就成为了**因特网的正式标准**\n\n####  FTP工作原理\n\n利用TCP的可靠传输，使用**客户服务器**方式，一个FTP服务器进程可以同时为多个客户进程提供服务\n\nFTP的服务器进程由两大部分组成：一个**主进程**，负责接受新的请求；另外有若干个**从属进程**，负责处理单个请求\n\nFTP在工作时使用两个并行的TCP连接，一个是**控制连接（端口号21）**，一个是**数据连接（端口号20）**\n\n###  万维网WWW`☆`\n\nWWW并非某种特殊的计算机网络，万维网是一个大规模的，联机式的信息储藏所，简称Web\n万维网引用连接的方法能非常方便的从互联网上的一个站点访问另一个站点，从而主动获取丰富的知识\n\n####  统一资源定位符URL\n\nURL用于表示从互联网上得到的资源位置和访问这些资源的方法\n\nURL由以冒号隔开的两大部分组成，并且在 URL 中的字符**对大写或小写没有要求**。 URL 的一般形式是： \n![22.webp](https://image.overlooked.top/img/net-base/22.webp)\n\n####  超文本传送HTTP\n\n定义了客户进程（浏览器）怎样向万维网服务器请求万维网文档\n\n####  超文本标记语言HTML\n\n要使任何一台计算机都能显示出任何一个万维网服务器上面的画面，就必须解决页面制作的标准化问题。超文本标记语言HTML就是一种制作万维网页面的标准语言\n","tags":["计算机网络"],"categories":["计算机网络"]},{"title":"IDEA快捷键","url":"/post/610bdf07.html","content":"## 前言\n由于写java-web或其它java程序基本上都离不开IDEA，故在此记录一下IDEA的快捷键设置，方便以后查询。\n\n## Ctrl类\n\n| **快捷键**          | **介绍**                                                     |\n| ------------------- | ------------------------------------------------------------ |\n| **Ctrl + F**        | **在当前文件进行文本查找 `（必备）`**                        |\n| **Ctrl + R**        | **在当前文件进行文本替换 `（必备）`**                        |\n| **Ctrl + Z**        | **撤销 （必备）**                                            |\n| **Ctrl + Y**        | **删除光标所在行 或 删除选中的行 （必备）**                  |\n| **Ctrl + X**        | **剪切光标所在行 或 剪切选择内容**                           |\n| **Ctrl + C**        | **复制光标所在行 或 复制选择内容**                           |\n| **Ctrl + D**        | **复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 `（必备）`** |\n| Ctrl + W            | 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 |\n| **Ctrl + E**        | **显示最近打开的文件记录列表**                               |\n| **Ctrl + N**        | **根据输入的 类名 查找类文件**                               |\n| Ctrl + G            | 在当前文件跳转到指定行处                                     |\n| Ctrl + J            | 插入自定义动态代码模板                                       |\n| Ctrl + P            | 方法参数提示显示                                             |\n| Ctrl + Q            | 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 |\n| Ctrl + U            | 前往当前光标所在的方法的父类的方法 / 接口定义                |\n| Ctrl + B            | 进入光标所在的方法/变量的接口或是定义出，等效于 `Ctrl + 左键单击` |\n| Ctrl + K            | 版本控制提交项目，需要此项目有加入到版本控制才可用           |\n| Ctrl + T            | 版本控制更新项目，需要此项目有加入到版本控制才可用           |\n| Ctrl + H            | 显示当前类的层次结构                                         |\n| Ctrl + O            | 选择可重写的方法                                             |\n| Ctrl + I            | 选择可继承的方法                                             |\n| Ctrl + +            | 展开代码                                                     |\n| Ctrl + -            | 折叠代码                                                     |\n| Ctrl + /            | 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 `（必备）` |\n| Ctrl + [            | 移动光标到当前所在代码的花括号开始位置                       |\n| Ctrl + ]            | 移动光标到当前所在代码的花括号结束位置                       |\n| Ctrl + F1           | 在光标所在的错误代码出显示错误信息                           |\n| Ctrl + F3           | 调转到所选中的词的下一个引用位置                             |\n| Ctrl + F4           | 关闭当前编辑文件                                             |\n| Ctrl + F8           | 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 |\n| Ctrl + F9           | 执行 Make Project 操作                                       |\n| Ctrl + F11          | 选中文件 / 文件夹，使用助记符设定 / 取消书签                 |\n| **Ctrl + F12**      | **弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选**   |\n| Ctrl + Tab          | 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 |\n| **Ctrl + Enter**    | **智能分隔行**                                               |\n| **Ctrl + End**      | **跳到文件尾**                                               |\n| **Ctrl + Home**     | **跳到文件头**                                               |\n| Ctrl + Space        | 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 `Ctrl + 逗号``（必备）` |\n| Ctrl + Delete       | 删除光标后面的单词或是中文句                                 |\n| Ctrl + BackSpace    | 删除光标前面的单词或是中文句                                 |\n| Ctrl + 1,2,3…9      | 定位到对应数值的书签位置                                     |\n| **Ctrl + 左键单击** | **在打开的文件标题上，弹出该文件路径**                       |\n| **Ctrl + 光标定位** | **按 Ctrl 不要松开，会显示光标所在的类信息摘要**             |\n| Ctrl + 左方向键     | 光标跳转到当前单词 / 中文句的左侧开头位置                    |\n| Ctrl + 右方向键     | 光标跳转到当前单词 / 中文句的右侧开头位置                    |\n| Ctrl + 前方向键     | 等效于鼠标滚轮向前效果                                       |\n| Ctrl + 后方向键     | 等效于鼠标滚轮向后效果                                       |\n\n## Alt\n\n| 快捷键             | 介绍                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| Alt + `            | 显示版本控制常用操作菜单弹出层                               |\n| Alt + Q            | 弹出一个提示，显示当前类的声明 / 上下文信息                  |\n| Alt + F1           | 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择   |\n| Alt + F2           | 对于前面页面，显示各类浏览器打开目标选择弹出层               |\n| Alt + F3           | 选中文本，逐个往下查找相同文本，并高亮显示                   |\n| Alt + F7           | 查找光标所在的方法 / 变量 / 类被调用的地方                   |\n| Alt + F8           | 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 |\n| Alt + Home         | 定位 / 显示到当前文件的 `Navigation Bar`                     |\n| **Alt + Enter**    | **IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 `（必备）`** |\n| **Alt + Insert**   | **代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等** |\n| **Alt + 左方向键** | **按左方向切换当前已打开的文件视图**                         |\n| **Alt + 右方向键** | **按右方向切换当前已打开的文件视图**                         |\n| Alt + 前方向键     | 当前光标跳转到当前文件的前一个方法名位置                     |\n| Alt + 后方向键     | 当前光标跳转到当前文件的后一个方法名位置                     |\n| Alt + 1,2,3…9      | 显示对应数值的选项卡，其中 1 是 Project 用得最多             |\n\n## Shift\n\n| 快捷键                   | 介绍                                                         |\n| ------------------------ | ------------------------------------------------------------ |\n| Shift + F1               | 如果有外部文档可以连接外部文档                               |\n| Shift + F2               | 跳转到上一个高亮错误 或 警告位置                             |\n| Shift + F3               | 在查找模式下，查找匹配上一个                                 |\n| Shift + F4               | 对当前打开的文件，使用新Windows窗口打开，旧窗口保留          |\n| Shift + F6               | 对文件 / 文件夹 重命名                                       |\n| Shift + F7               | 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 |\n| Shift + F8               | 在 Debug 模式下，跳出，表现出来的效果跟 `F9` 一样            |\n| Shift + F9               | 等效于点击工具栏的 `Debug` 按钮                              |\n| Shift + F10              | 等效于点击工具栏的 `Run` 按钮                                |\n| Shift + F11              | 弹出书签显示层                                               |\n| Shift + Tab              | 取消缩进                                                     |\n| Shift + ESC              | 隐藏当前 或 最后一个激活的工具窗口                           |\n| **Shift + End**          | **选中光标到当前行尾位置**                                   |\n| **Shift + Home**         | **选中光标到当前行头位置**                                   |\n| **Shift + Enter**        | **开始新一行。光标所在行下空出一行，光标定位到新行位置**     |\n| **Shift + 左键单击**     | **在打开的文件名上按此快捷键，可以关闭当前打开文件**         |\n| **Shift + 滚轮前后滚动** | **当前文件的横向滚动轴滚动**                                 |\n\n## Ctrl + Alt\n\n| 快捷键                | 介绍                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| **Ctrl + Alt + L**    | **格式化代码，可以对当前文件和整个包目录使用 `（必备）`**    |\n| **Ctrl + Alt + O**    | **优化导入的类，可以对当前文件和整个包目录使用 `（必备）`**  |\n| Ctrl + Alt + I        | 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化       |\n| Ctrl + Alt + T        | 对选中的代码弹出环绕选项弹出层                               |\n| Ctrl + Alt + J        | 弹出模板选择窗口，讲选定的代码加入动态模板中                 |\n| Ctrl + Alt + H        | 调用层次                                                     |\n| Ctrl + Alt + B        | 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口     |\n| Ctrl + Alt + V        | 快速引进变量                                                 |\n| Ctrl + Alt + Y        | 同步、刷新                                                   |\n| Ctrl + Alt + S        | 打开 IntelliJ IDEA 系统设置                                  |\n| Ctrl + Alt + F7       | 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 |\n| Ctrl + Alt + F11      | 切换全屏模式                                                 |\n| Ctrl + Alt + Enter    | 光标所在行上空出一行，光标定位到新行                         |\n| Ctrl + Alt + Home     | 弹出跟当前文件有关联的文件弹出层                             |\n| Ctrl + Alt + Space    | 类名自动完成                                                 |\n| Ctrl + Alt + 左方向键 | 退回到上一个操作的地方 `（必备）**（注意与其他软件快捷键冲突）**` |\n| Ctrl + Alt + 右方向键 | 前进到上一个操作的地方 `（必备）**（注意与其他软件快捷键冲突）**` |\n| Ctrl + Alt + 前方向键 | 在查找模式下，跳到上个查找的文件                             |\n| Ctrl + Alt + 后方向键 | 在查找模式下，跳到下个查找的文件                             |\n\n## Ctrl + Shift\n\n| 快捷键                      | 介绍                                                         |\n| --------------------------- | ------------------------------------------------------------ |\n| **Ctrl + Shift + F**        | **根据输入内容查找整个项目 或 指定目录内文件 `（必备）`**    |\n| **Ctrl + Shift + R**        | **根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 `（必备）`** |\n| **Ctrl + Shift + J**        | **自动将下一行合并到当前行末尾 `（必备）`**                  |\n| **Ctrl + Shift + Z**        | **取消撤销 `（必备）`**                                      |\n| Ctrl + Shift + W            | 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 `（必备）` |\n| **Ctrl + Shift + N**        | **通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 `（必备）`** |\n| **Ctrl + Shift + U**        | **对选中的代码进行大 / 小写轮流转换 `（必备）`**             |\n| Ctrl + Shift + T            | 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 |\n| **Ctrl + Shift + C**        | **复制当前文件磁盘路径到剪贴板**                             |\n| **Ctrl + Shift + V**        | **弹出缓存的最近拷贝的内容管理器弹出层**                     |\n| Ctrl + Shift + E            | 显示最近修改的文件列表的弹出层                               |\n| Ctrl + Shift + H            | 显示方法层次结构                                             |\n| **Ctrl + Shift + B**        | **跳转到类型声明处**                                         |\n| Ctrl + Shift + I            | 快速查看光标所在的方法 或 类的定义                           |\n| Ctrl + Shift + A            | 查找动作 / 设置                                              |\n| **Ctrl + Shift + /**        | **代码块注释 `（必备）`**                                    |\n| Ctrl + Shift + [            | 选中从光标所在位置到它的顶部中括号位置                       |\n| Ctrl + Shift + ]            | 选中从光标所在位置到它的底部中括号位置                       |\n| Ctrl + Shift + +            | 展开所有代码                                                 |\n| Ctrl + Shift + -            | 折叠所有代码                                                 |\n| Ctrl + Shift + F7           | 高亮显示所有该选中文本，按Esc高亮消失                        |\n| Ctrl + Shift + F8           | 在 Debug 模式下，指定断点进入条件                            |\n| Ctrl + Shift + F9           | 编译选中的文件 / 包 / Module                                 |\n| Ctrl + Shift + F12          | 编辑器最大化                                                 |\n| Ctrl + Shift + Space        | 智能代码提示                                                 |\n| Ctrl + Shift + Enter        | 自动结束代码，行末自动添加分号 `（必备）`                    |\n| Ctrl + Shift + Backspace    | 退回到上次修改的地方                                         |\n| Ctrl + Shift + 1,2,3…9      | 快速添加指定数值的书签                                       |\n| **Ctrl + Shift + 左方向键** | **在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句** |\n| **Ctrl + Shift + 右方向键** | **在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句** |\n| Ctrl + Shift + 左方向键     | 在光标焦点是在工具选项卡上，缩小选项卡区域                   |\n| Ctrl + Shift + 右方向键     | 在光标焦点是在工具选项卡上，扩大选项卡区域                   |\n| Ctrl + Shift + 前方向键     | 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序   |\n| Ctrl + Shift + 后方向键     | 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序   |\n\n## Alt + Shift\n\n| 快捷键                 | 介绍                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| Alt + Shift + N        | 选择 / 添加 task                                             |\n| Alt + Shift + F        | 显示添加到收藏夹弹出层                                       |\n| Alt + Shift + C        | 查看最近操作项目的变化情况列表                               |\n| Alt + Shift + F        | 添加到收藏夹                                                 |\n| Alt + Shift + I        | 查看项目当前文件                                             |\n| Alt + Shift + F7       | 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 |\n| Alt + Shift + F9       | 弹出 `Debug` 的可选择菜单                                    |\n| Alt + Shift + F10      | 弹出 `Run` 的可选择菜单                                      |\n| Alt + Shift + 左键双击 | 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 |\n| Alt + Shift + 前方向键 | 移动光标所在行向上移动                                       |\n| Alt + Shift + 后方向键 | 移动光标所在行向下移动                                       |\n\n## Ctrl + Shift + Alt\n\n| 快捷键                 | 介绍                  |\n| ---------------------- | --------------------- |\n| Ctrl + Shift + Alt + V | 无格式黏贴            |\n| Ctrl + Shift + Alt + N | 前往指定的变量 / 方法 |\n| Ctrl + Shift + Alt + S | 打开当前项目设置      |\n| Ctrl + Shift + Alt + C | 复制参考信息          |\n\n## 其他\n\n| 快捷键            | 介绍                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| F2                | 跳转到下一个高亮错误 或 警告位置 `（必备）`                  |\n| F3                | 在查找模式下，定位到下一个匹配处                             |\n| F4                | 编辑源                                                       |\n| F7                | 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 |\n| F8                | 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 |\n| F9                | 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 |\n| F11               | 添加书签                                                     |\n| F12               | 回到前一个工具窗口                                           |\n| Tab               | 缩进                                                         |\n| ESC               | 从工具窗口进入代码文件窗口                                   |\n| **连按两次Shift** | **弹出 `Search Everywhere` 弹出层**                          |\n","tags":["IDEA"],"categories":["开发工具使用"]},{"title":"Java基础---接口","url":"/post/1acd505d.html","content":"## 前言\n理解好了**抽象**的概念，进一步学习**接口**\n\n接口的设计弥补了Java不能**多继承**的缺陷\n\n本篇文章将介绍Java接口的相关内容\n*******\n\n## 关于接口\n\n可以将接口理解为：**多个类的公共规范**\n\n接口是一种引用数据类型，最重要的内容就是其中的**抽象方法**\n\n接口的定义格式：\n\n``` java\npublic interface 接口名称 {\n    // 接口内容\n}\n```\n\n在Java7中，接口可以包含：\n\n+ `常量`（定义后不可更改）\n\n+ `抽象方法`（`abstract`）\n\n在Java8中，又可以定义：\n\n+ `默认方法`（`default`）\n\n+ `静态方法`（`static`）\n\n在Java9中，还可以包含：\n\n+ `私有方法`（`private`）\n\n> 注意：接口是没有**静态代码块**或者**构造方法**的\n\n## 使用\n\n### 基本使用\n\n接口使用规范：\n\n1. 接口不能直接使用，必须有一个`实现类`来实现该接口\n\n``` java\npublic class 实现类名称 implements 接口名称 {\n    // ...\n}\n```\n\n2. 接口的实现类必须`覆盖重写`（实现）接口中所有的`抽象方法`\n3. 创建`实现类`的对象，进行使用\n\n在定义接口的**抽象方法**时需要注意**格式**：\n\n`public abstract 返回值类型 方法名称(参数列表);`\n\n+ 接口当中的抽象方法，修饰符必须是两个固定的关键字：`public abstract`\n\n+ 这两个关键字修饰符，可以`选择性地省略`（省略后仍为抽象方法）\n\n定义接口`InterfaceDemo`：\n\n``` java\npublic interface InterfaceDemo {\n    public abstract void method1();\n    void method2();\n}\n```\n\n定义接口实现类`InterfaceDemoImpl`：\n\n``` java\npublic class InterfaceDemoImpl implements InterfaceDemo {\n    @Override\n    public void method1() {\n        System.out.println(\"第一个方法\");\n    }\n\n    @Override\n    public void method2() {\n        System.out.println(\"第二个方法\");\n    }\n}\n```\n\n定义使用类`Demo`\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        InterfaceDemoImpl Demo = new InterfaceDemoImpl();\n        Demo.method1();\n        Demo.method2();\n    }\n}\n```\n\n结果如下：\n\n``` java\n第一个方法\n第二个方法\n```\n\n### 默认方法\n\n接口中的默认方法，可以解决`接口升级`的问题\n\n``` java\npublic default 返回值类型 方法名称(参数列表) {\n    方法体\n}\n```\n\n> 假设一个项目已经投入使用，这时在接口升级中准备添加一个新的方法，但是该接口的所有实现类都需要重写新的方法。如此一来升级维护成本太大，所以在Java8之后，允许接口定义默认方法，免去接口实现类重写的麻烦\n\n+ 实现类可以**重写**接口中定义的**默认方法**\n\n+ 实现类可以**直接使用**接口中定义的**默认方法**\n\n定义接口`InterfaceDemo`：\n\n``` java\npublic interface InterfaceDemo {\n    public abstract void method();\n\n    public default void method1() {\n        System.out.println(\"接口默认方法一\");\n    }\n\n    default void method2() {\n        System.out.println(\"接口默认方法二\");\n    }\n}\n```\n\n定义接口实现类`InterfaceDemoImpl`：\n\n``` java\npublic class InterfaceDemoImpl implements InterfaceDemo {\n    @Override\n    public void method() {\n        System.out.println(\"重写接口的抽象方法\");\n    }\n\n    @Override\n    public void method1() {\n        System.out.println(\"重写接口的默认方法一\");\n    }\n}\n```\n\n定义使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        InterfaceDemoImpl Demo = new InterfaceDemoImpl();\n        Demo.method();\n        Demo.method1();\n        Demo.method2();\n    }\n}\n```\n\n结果如下：\n\n``` java\n重写接口的抽象方法\n重写接口的默认方法一\n接口默认方法二\n```\n\n### 静态方法\n\nJava8后还允许接口定义`静态方法`，格式如下：\n\n``` java\npublic static 返回值类型 方法名称(参数列表) {\n    方法体\n}\n```\n\n注意：\n\n+ 必须有`public`关键字修饰，不然其他类无法访问\n\n+ 正确用法：不可以通过接口的实现类来调用静态方法，直接按照调用格式使用：<br>`接口名称.静态方法名(参数);`\n\n定义接口`InterfaceDemo`：\n\n``` java\npublic interface InterfaceDemo {\n    public static void method() {\n        System.out.println(\"接口的静态方法\");\n    }\n}\n```\n\n定义使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        InterfaceDemo.method();\n    }\n}\n```\n\n结果如下：\n\n``` java\n接口的静态方法\n```\n\n### 常量\n\n接口当中也可以定义成员变量，但是必须使用`public static final`三个关键字进行修饰，从效果上看，这其实就是接口的`常量`\n\n``` java\npublic static final 数据类型 常量名称 = 数据值;\n```\n\n注意：\n\n+ 接口当中的常量，可以省略`public static final`（省略不写效果一样）\n\n+ 接口当中的常量，`必须`进行`赋值`\n+ 推荐接口常量的`命名规则`：使用完全**大写的字母**，用**下划线**进行分隔\n\n定义接口`InterfaceDemo`：\n\n```java\npublic interface InterfaceDemo {\n    public static final String STR1 = \"接口常量一\";\n    String STR2 = \"接口常量二\";\n}\n```\n\n定义使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        System.out.println(InterfaceDemo.STR1);\n        System.out.println(InterfaceDemo.STR2);\n    }\n}\n```\n\n结果如下：\n\n``` java\n接口常量一\n接口常量二\n```\n\n### 接口的多实现\n\n一个类的直接`父类是唯一的`，但是一个类可以同时`实现多个接口`\n\n``` java\npublic class InterfaceImpl implements InterfaceA, InterfaceB {\n    // 覆盖重写所有抽象方法\n}\n```\n\n使用时需要`注意`：\n\n+ 如果实现类所实现的**多个接口**当中，**存在重复的抽象方法**，那么只需要**覆盖重写一次**即可\n+ 如果实现类**没有**覆盖重写**所有接口**当中的**所有抽象方法**，那么实现类就**必须是一个抽象类**\n+ 如果实现类所实现的**多个接口**当中，**存在重复的默认方法**，那么实现类**一定要对冲突的默认方法进行覆盖重写**\n+ 一个类如果直接父类当中的方法，和接口当中的**默认方法**产生了冲突，**优先用父类当中的方法**（可以不用重写）\n\n定义接口`InterfaceDemoA`：\n\n``` java\npublic interface InterfaceDemoA {\n    public abstract void methodA();\n\n    public default void method() {\n        System.out.println(\"接口A的重名默认方法\");\n    }\n}\n```\n\n定义接口`InterfaceDemoB`：\n\n``` java\npublic interface InterfaceDemoB {\n    public abstract void methodB();\n\n    public default void method() {\n        System.out.println(\"接口B的重名默认方法\");\n    }\n}\n```\n\n定义父类`Father`：\n\n``` java\npublic class Father {\n    public void method_Father() {\n        System.out.println(\"父类方法\");\n    }\n\n    public void method() {\n        System.out.println(\"父类重名方法\");\n    }\n}\n```\n\n定义子类/接口实现类`Son`：\n\n``` java\npublic class Son extends Father implements InterfaceDemoA,InterfaceDemoB {\n    @Override\n    public void methodA() {\n        System.out.println(\"重写接口A的方法\");\n    }\n\n    @Override\n    public void methodB() {\n        System.out.println(\"重写接口B的方法\");\n    }\n\n    @Override\n    public void method() {\n        System.out.println(\"重写接口和父类的重名方法\");\n    }\n}\n```\n\n定义使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.methodA();\n        son.methodB();\n        son.method_Father();\n        son.method();\n    }\n}\n```\n\n结果如下：\n\n``` java\n重写接口A的方法\n重写接口B的方法\n父类方法\n重写接口和父类的重名方法\n```\n\n### 接口的多继承\n\n`接口与接口`之间是`多继承`的\n\n``` java\npublic interface InterfaceDemo extends InterfaceA, InterfaceB {\n\t// 覆盖重写所有冲突的默认方法\n}\n```\n\n使用时注意：\n\n+ 可以**不用重写**父接口的**抽象方法**（冲突也不要紧，因为实现类总要重写）\n+ 多个父接口当中的**默认方法**如果**重复**，那么子接口**必须进行默认方法的覆盖重写**\n\n定义父接口`InterfaceA`：\n\n``` java\npublic interface InterfaceA {\n    public abstract void methodA();\n    public abstract void methodCommon();\n    public default void methodDefault() {\n        System.out.println(\"父接口A的重名默认方法\");\n    }\n}\n```\n\n定义父接口`InterfaceB`：\n\n``` java\npublic interface InterfaceB {\n    public abstract void methodB();\n    public abstract void methodCommon();\n    public default void methodDefault() {\n        System.out.println(\"父接口B的重名默认方法\");\n    }\n}\n```\n\n定义子接口`InterfaceDemo`：\n\n``` java\npublic interface InterfaceDemo extends InterfaceA, InterfaceB {\n    public abstract void methodC();\n    @Override\n    public default void methodDefault() {\n        System.out.println(\"重写父接口默认重名方法\");\n    }\n}\n```\n\n定义子接口实现类`InterfaceDemoImpl`：\n\n``` java\npublic class InterfaceDemoImpl implements InterfaceDemo {\n    @Override\n    public void methodA() {\n        System.out.println(\"重写父接口A的方法\");\n    }\n\n    @Override\n    public void methodB() {\n        System.out.println(\"重写父接口B的方法\");\n    }\n\n    @Override\n    public void methodC() {\n        System.out.println(\"重写子接口的方法\");\n    }\n\n    @Override\n    public void methodCommon() {\n        System.out.println(\"重写父接口的重名方法\");\n    }\n}\n```\n\n定义实现类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        InterfaceDemoImpl Demo = new InterfaceDemoImpl();\n        Demo.methodA();\n        Demo.methodB();\n        Demo.methodC();\n        Demo.methodCommon();\n        Demo.methodDefault();\n    }\n}\n```\n\n结果如下：\n\n``` java\n重写父接口A的方法\n重写父接口B的方法\n重写子接口的方法\n重写父接口的重名方法\n重写父接口默认重名方法\n```\n\n","tags":["Java"],"categories":["Java基础"]},{"title":"Java基础---继承","url":"/post/52443915.html","content":"## 前言\n本篇文章将介绍Java继承的相关内容\n*******\n\n## 关于继承\n\n简而言之，继承主要解决的问题就是：`共性抽取`\n\n代码定义：\n\n``` java\n//父类：也称作基类、超类\npublic class 父类名称 {\n    // ...\n}\n```\n\n``` java\n//子类：也称作派生类\npublic class 子类名称 extends 父类名称 {\n    // ...\n}\n```\n\n> 最高父类其实就是一个**普通类**，这点在代码定义时就可以看出来；\n>\n> 在继承的关系中，**“子类就是一个父类”**。也就是说，子类可以被当做父类看待。（例如：父类是员工，其子类有经理、业务员。那么可以有这样的表达：“经理、业务员是员工”）\n\n在继承关系中：\n\n+ 子类可以`拥有父类的“内容”`\n\n+ 子类还可以定义除父类之外的`专有内容`\n\n+ Java语言是`单继承`的：一个类的直接父类只能有唯一一个\n\n+ Java语言可以`多级继承`：\n\n``` java\nclass A {}\nClass B extends A {}\nclass C extends B {}\n```\n\n+ 一个父类可以拥有很多个子类：\n\n``` java\nclass A {}\nclass B extends A {}\nclass C extends A {}\n```\n\n## 用法\n\n### 基本使用\n\n定义父类`Father`：\n\n``` java\npublic class Father {\n    String father_string = \"这是父类变量\";\n    public void father_method() {\n        System.out.println(\"这是父类方法\");\n    }\n}\n```\n\n定义子类`Son`：\n\n``` java\npublic class Son extends Father {\n    String son_string = \"这是子类变量\";\n    public void son_method() {\n        System.out.println(\"这是子类方法\");\n    }\n}\n```\n\n使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Son son = new Son();\n        System.out.println(son.father_string);  //访问父类变量\n        System.out.println(son.son_string);  //访问子类变量\n        son.father_method();  //访问父类方法\n        son.son_method();  //访问子类方法\n    }\n}\n```\n\n运行结果：\n\n``` java\n这是父类变量\n这是子类变量\n这是父类方法\n这是子类方法\n```\n\n### 成员变量访问\n\n+ 局部变量：`局部变量名`\n+ 本类的成员变量：`this.成员变量名`\n+ 父类的成员变量：`super.成员变量名`\n\n定义父类`Father`：\n\n``` java\npublic class Father {\n    String words = \"父类变量\";\n}\n```\n\n定义子类`Son`：\n\n``` java\npublic class Son extends Father {\n    String words = \"子类变量\";\n\n    public void son_method() {\n        String words = \"局部变量\";\n        System.out.println(words);  //局部变量\n        System.out.println(this.words);  //子类变量\n        System.out.println(super.words);  //父类变量\n    }\n}\n```\n\n使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.son_method();  //访问子类方法\n    }\n}\n```\n\n运行结果：\n\n``` java\n局部变量\n子类变量\n父类变量\n```\n\n### 成员方法访问\n\n#### 基本使用\n\n`访问规则`：创建的对象是谁，就**优先用**谁的方法，如果没有，则**向上找父类**。\n\n#### 重写\n\n在继承关系当中，**方法名称**一样，**参数列表**也一样。\n\n> 注意区别重写与重载：\n>\n> + 重写（Override）：方法的名称一样，参数列表也一样\n> + 重载（Overload）：方法的名称一样，参数列表不一样\n\n注解`@Override`：写在方法前面，用来检测是不是有效的正确重写。（也可以不写，但**建议书写**，起到检测作用）\n\n定义父类`Father`：\n\n``` java\npublic class Father {\n    public void method() {\n        System.out.println(\"父类重名方法执行\");\n    }\n}\n```\n\n定义子类`Son`：\n\n``` java\npublic class Son extends Father {\n    @Override\n    public void method() {\n        System.out.println(\"子类重名方法执行\");\n    }\n}\n```\n\n使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.method();  //访问子类方法\n    }\n}\n```\n\n运行结果：\n\n``` java\n子类重名方法执行\n```\n\n#### 重写注意事项：\n+ 如果`父类`方法访问修饰符为**private**则`子类就不能重写`该方法\n+ `子类`方法的抛出异常范围必须**小于等于**`父类`方法的抛出异常范围\n+ `子类`方法的返回值必须**小于等于**`父类`方法的返回值范围<br>`java.lang.Object类`是所有类的公共最高父类，而`java.lang.String类`就是Object的子类\n+ `子类`方法的权限必须**大于等于**`父类`方法的权限修饰符<br>`public > protected > (default) > private`（注：(default)不是关键字default，而是什么都不写，留空）\n\n### 构造方法访问\n\n#### 基本使用\n\n继承关系中，构造方法的访问特点：\n\n+ 子类构造方法当中有一个默认隐含的`super();`调用，所以一定是**先调用**的父类构造方法，**后执行**的子类构造方法\n+ 子类构造方法可以通过`super`关键字来调用父类重载构造方法\n+ super的父类构造调用，`必须是`子类构造方法的`第一个语句`（不能一个子类构造调用多次super构造）\n\n定义父类`Father`：\n\n``` java\npublic class Father {\n    public Father() {\n        System.out.println(\"父类无参构造方法\");\n    }\n}\n```\n\n定义子类`Son`：\n\n``` java\npublic class Son extends Father {\n    public Son() {\n        System.out.println(\"子类无参构造方法\");\n    }\n}\n```\n\n使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Son son = new Son();\n    }\n}\n```\n\n运行结果：\n\n``` java\n父类无参构造方法\n子类无参构造方法\n```\n\n#### super\n\n用法：\n\n+ 在子类的**成员方法**中，访问父类的**成员变量**\n+ 在子类的**成员方法**中，访问父类的**成员方法**\n+ 在子类的**构造方法**中，访问父类的**构造方法**\n\n定义父类`Father`：\n\n``` java\npublic class Father {\n    String string = \"父类变量\";\n\n    public Father() {\n        System.out.println(\"父类无参构造方法\");\n    }\n\n    public Father(String string) {\n        this.string = string;\n        System.out.println(\"父类有参构造方法\");\n    }\n}\n```\n\n定义子类`Son`：\n\n``` java\npublic class Son extends Father {\n    String string = \"子类变量\";\n\n    public Son() {\n        super(\"调用父类的有参构造方法\");\n        System.out.println(\"子类无参构造方法\");\n    }\n\n    public Son(String string) {\n        this.string = string;\n        System.out.println(\"子类有参构造方法\");\n    }\n}\n```\n\n使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Son son = new Son();\n    }\n}\n```\n\n运行结果：\n\n``` java\n父类有参构造方法\n子类无参构造方法\n```\n\n#### this\n\n用法：\n\n+ 在本类的**成员方法**中，访问本类的**成员变量**\n+ 在本类的**成员方法**中，访问本类的另一个**成员方法**\n+ 在本类的**构造方法**中，访问本类的另一个**构造方法**\n\n> 注意：\n>\n> + `this(...)`调用也必须是构造方法的`第一个语句`，且是`唯一的一个`\n> + `super(...)`和`this(...)`两种构造调用，`不能同时使用`\n\n使用类`Demo`：\n\n``` java\npublic class Demo {\n    int num;\n    String words;\n\n    public Demo() {\n        this(1);\n        System.out.println(\"无参构造方法\");\n    }\n\n    public Demo(int num) {\n        this(1,\"参数\");\n        this.num = num;\n        System.out.println(\"仅含一个参数的构造方法\");\n    }\n\n    public Demo(int num, String words) {\n        this.num = num;\n        this.words = words;\n        System.out.println(\"全参构造方法\");\n    }\n\n    public static void main(String[] args) {\n        Demo demo = new Demo();\n    }\n}\n```\n\n运行结果：\n\n``` java\n全参构造方法\n仅含一个参数的构造方法\n无参构造方法\n```\n\n## 抽象（abstract）\n\n如果父类中的方法不确定如何具体实现方法体的内容，那么就应该考虑使用`抽象方法`。\n\n> 例如：父类为`Animal`，其有两个子类`Dog`、`Cat`。在`Animal`父类中定义了一个`Eat(...){...}`的方法，但是由于狗啃骨头、猫吃鱼，这两个子类的吃行为是不一样的，无法在父类的方法体中进行准确定义，这时就需要将`Eat(...)`定义为`抽象方法`。\n\n概念：\n\n+ **抽象方法**：用`abstract`关键字修饰，然后去掉方法体，直接分号结束<br>`public abstract void method(...);`\n+ **抽象类**：抽象方法所在的类，必须是抽象类才行。在`class之前`用`abstract`关键字修饰\n\n使用时需要注意：\n\n+ **不能直接new**抽象类对象\n+ 必须用一个子类来**继承**抽象父类\n+ 子类必须**覆盖重写**抽象父类当中**所有**的抽象方法，**否则该子类也必须为抽象类**\n+ 抽象类需要**创建子类对象**进行使用\n+ 一个抽象类**不一定含有**抽象方法，只要保证抽象方法所在的类是抽象类即可（在一些特殊场景下有用途）\n\n定义父类`Father`：\n\n``` java\npublic abstract class Father {\n    public abstract void method();\n\n    public void normalMethod() {\n        System.out.println(\"普通的成员方法（子类不用重写此方法）\");\n    }\n}\n```\n\n定义子类`Son`：\n\n``` java\npublic class Son extends Father {\n    @Override\n    public void method() {\n        System.out.println(\"重写父类的抽象方法\");\n    }\n}\n```\n\n使用类`Demo`：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.method();\n    }\n}\n```\n\n运行结果：\n\n``` java\n重写父类的抽象方法\n```\n\n","tags":["Java"],"categories":["Java基础"]},{"title":"Java基础---类和对象","url":"/post/443644a4.html","content":"## 前言\n本篇文章将介绍Java类和对象的相关内容\n*******\n\n## 关于面向对象\n传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要考虑存储数据的方式（即：算法 + 数据结构 = 程序）。注意在这种设计模式中，算法是第一位的，数据结构是第二位的。但是`面向对象程序设计（OOP）`调换了这一顺序：将数据放在第一位，然后再考虑操作数据的算法。  \n\n面向对象与面向过程的区别：  \n\n|          | **面向对象程序设计**                                         | **面向过程程序设计（结构化编程）**                           |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 定义     | 面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“`自下而上`”的设计语言，先设计组件，再完成拼装 | 面向过程是“`自上而下`”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现mian()函数中所要用到的其他方法 |\n| 特点     | `封装、继承、多态`                                           | `算法 + 数据结构`                                            |\n| 优势     | 适用于大型复杂系统，方便复用                                 | 适用于简单系统，容易理解                                     |\n| 劣势     | 比较抽象、性能比面向过程低                                   | 难以应对复杂系统，难以复用，不易维护、不易扩展               |\n| 对比     | `易维护、易复用、易扩展`，由于面向对象有封装、继承、多态性的特性，可以设计出`低耦合`的系统，使系统 更加灵活、更加易于维护 | `性能比面向对象高`，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素 |\n| 设计语言 | Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等       | C、Fortran                                                   |\n\n面向对象的基本特征：\n\n+ `封装`：保护内部的操作不被破坏\n+ `继承`：在原本的基础之上继续进行扩充\n+ `多态`：在一个指定的范围之内进行概念的转换\n\n## 类与对象的基本概念\n\n把数据以及对数据的操作方法放在一起，作为一个相互依存的整体，这就是**对象**；对同类对象抽象出其共性，从而形成**类**。类与对象是整个面向对象中最基础的组成单元。\n\n+ `类`：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为（方法）\n+ `对象`：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象\n\n## 类与对象的定义和使用\n### 定义标准类\n定义一个标准类，通常拥有以下四个组成部分：\n\n+ 所有成员变量都要使用`private`关键字修饰\n+ 为每一个成员变量编写一对`Getter/Setter`方法\n+ 编写一个`无参`数的构造方法\n+ 编写一个`全参`数的构造方法\n\n这样标准的类也叫做`Java Bean`，定义语法如下：\n\n``` java\nclass 类名称 {\n    private 属性 (即变量) ;\n    public  行为 (即方法) ;\n}\n```\n\n如下示例，定义一个`Student`类：\n\n``` java\npublic class Student {\n\n    private String name; // 姓名\n    private int age; // 年龄\n\n    public Student() { //无参数的构造方法\n    }\n\n    public Student(String name, int age) { //全参数的构造方法\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() { //变量name的Getter方法\n        return name;\n    }\n\n    public void setName(String name) { //变量name的Setter方法\n        this.name = name;\n    }\n\n    public int getAge() { //变量age的Getter方法\n        return age;\n    }\n\n    public void setAge(int age) { //变量age的Setter方法\n        this.age = age;\n    }\n}\n```\n\n### 类的使用\n\n类的定义完成之后，无法直接使用。如果要使用，首先需要**导包**（这不是必须的）：\n\n+ 导包需要指出使用的类\n+ 对于和当前类`属于同一个包`的情况，`可省略`导包语句不写\n+ `java.lang`包下的内容不需要导包\n+ 导包格式：`import 包名称.类名称;`（举例：import java.lang）\n\n使用类必须依靠对象，实例化对象的方法有如下两种方式：\n\n``` java\n//方式一：声明并实例化对象\n类名称 对象名称 = new 类名称 () ;\n```\n\n``` java\n//方式二：先声明对象，然后实例化对象\n类名称 对象名称 = null ;\n对象名称 = new 类名称 () ;\n```\n\n示例，实例化一个`student`对象：\n\n``` java\n//方式一\nStudent student = new Student();\n//方式二\nStudent student = null;\nstudent = new Student();\n```\n\n*实例化过程*：实例化对象语句分为两个部分，`new Student()`构造了一个Student类型的对象，并且它的值是`对新创建对象的引用`，然后将这个`引用`存储在变量`student`中，完成实例化\n\n> 引用数据类型与基本数据类型最大的不同在于：引用数据类型需要内存的分配和使用。所以，关键字`new`的主要功能就是`分配内存空间`，也就是说，只要使用引用数据类型，就要使用关键字new来分配内存空间。\n\n实例化对象之后，可以按照如下方式进行类的操作：\n\n+ 调用类中的属性（变量）：`对象名.成员变量名;`（前提是类中的属性没有被关键字`Private`修饰）\n+ 调用类中的方法：`对象名.成员方法名(参数);`\n\n示例：操作Student类\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Student stu1 = new Student();  //声明并实例化对象（调用一个无参的构造方法）\n        stu1.setName(\"张三\");\n        stu1.setAge(20);\n        System.out.println(\"姓名：\" + stu1.getName() + \"，年龄：\" + stu1.getAge());\n\n        Student stu2 = null; //声明对象\n        stu2 = new Student(\"李四\", 21); //实例化对象（调用一个全参的构造方法）\n        System.out.println(\"姓名：\" + stu2.getName() + \"，年龄：\" + stu2.getAge());\n    }\n}\n```\n\n输出结果：\n\n``` java\n姓名：张三，年龄：20\n姓名：李四，年龄：21\n```\n\n### 区分不同实例化的方式\n\n首先给出两种内存空间的概念：\n\n+ 堆内存：保存`对象的属性内容`，堆内存需要用`new`关键字来`分配空间`\n+ 栈内存：保存的是`堆内存的地址`（在这里为了分析方便，可以简单理解为栈内存保存的是对象的名字）\n\n![mem1.png](https://image.overlooked.top/img/java/mem1.png)\n\n在任何情况下，只要看见关键字`new`，都表示要分配新的堆内存空间，一旦堆内存空间分配了，里面就会有`类中定义的属性`，并且属性内容都是其对应数据类型的`默认值`。\n\n以上两种实例化对象方式内存表示如下：\n\n![mem2.png](https://image.overlooked.top/img/java/mem2.png)\n\n两种方式的差别在于①②，第一种声明并实例化的方式实际就是①②组合在一起，而第二种先声明然后实例化是把①和②分步骤来。\n\n如果没有实例化对象的过程，直接使用类，如下（则会报错）：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Student stu1 = null; //声明对象\n        //stu1 = new Student(); //取消实例化对象步骤\n        stu1.setName(\"张三\");\n        stu1.setAge(20);\n        System.out.println(\"姓名：\" + stu1.getName() + \"，年龄：\" + stu1.getAge());\n    }\n}\n```\n\n运行结果：\n\n``` java\nException in thread \"main\" java.lang.NullPointerException\n\tat Demo.Demo.main(Demo.java:8)\n```\n\n此时，程序只声明了Student对象，但并没有`实例化Student对象`（只有了栈内存，并没有对应的堆内存空间），则程序在编译的时候不会出现任何的错误，但是在执行的时候出现了上面的错误信息。这个错误信息表示的是“NullPointerException（空指向异常）”，这种异常只要是应用数据类型都有可能出现。\n\n## 对象引用传递分析\n\n同一块堆内存空间，可以同时被多个栈内存所指向，不同的栈可以修改同一块堆内存的内容。\n\n引用传递代码示例：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Student stu1 = new Student(); //声明并实例化对象stu1\n        stu1.setName(\"张三\");\n        stu1.setAge(20);\n        System.out.println(\"姓名：\" + stu1.getName() + \"，年龄：\" + stu1.getAge());\n\n        Student stu2 = stu1; //引用传递\n        stu2.setName(\"李四\");\n        stu1.setAge(21);\n        System.out.println(\"姓名：\" + stu2.getName() + \"，年龄：\" + stu2.getAge());\n    }\n}\n```\n\n输出结果：\n\n``` java\n姓名：张三，年龄：20\n姓名：李四，年龄：21\n```\n\n对应的内存分配图如下：\n\n![mem3.png](https://image.overlooked.top/img/java/mem3.png)\n\n我们来看另一种情况：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Student stu1 = new Student(); //声明并实例化对象stu1\n        Student stu2 = new Student(); //声明并实例化对象stu2\n        stu1.setName(\"张三\");\n        stu1.setAge(20);\n        stu2.setName(\"李四\");\n        stu2.setAge(21);\n        System.out.println(\"姓名：\" + stu1.getName() + \"，年龄：\" + stu1.getAge());\n        System.out.println(\"姓名：\" + stu2.getName() + \"，年龄：\" + stu2.getAge());\n\n        stu2 = stu1; //引用传递\n        stu2.setName(\"王五\");\n        stu2.setAge(22);\n        System.out.println(\"姓名：\" + stu2.getName() + \"，年龄：\" + stu2.getAge());\n    }\n}\n```\n\n输出结果：\n\n``` java\n姓名：张三，年龄：20\n姓名：李四，年龄：21\n姓名：王五，年龄：22\n```\n\n对应的内存分配图如下：\n\n![mem4.png](https://image.overlooked.top/img/java/mem4.png)\n\n> 垃圾：指的是在程序开发之中`没有任何对象所指向`的一块`堆内存空间`，这块空间就成为垃圾，所有的垃圾将等待`GC(垃圾收集器)`不定期的进行回收与空间的释放。\n\n## 关于封装性\n\n前文提到面向对象的程序设计具有**封装性**。通俗的理解就是外部在调用类使用时，无法直接访问其内部属性，相当于对外不可见。举例如下代码：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n        Student stu = new Student(); //声明并实例化对象stu\n        stu.name = \"张三\"; //直接访问name属性\n        stu.age = 20; //直接访问age属性\n        System.out.println(\"姓名：\" + stu.getName() + \"，年龄：\" + stu.getAge());\n    }\n}\n```\n\n实际上在该段代码编写阶段就会直接提示错误信息，运行后可以也可以看到错误提示，name与age变量在Student类中是**private**访问控制。这就是封装性的具体体现，在Student类中，变量受到private关键字修饰，致使外部无法通过直接调用其属性并修改或访问。但是我们可以在定义类中增添对应属性的**Setter/Getter**方法来修改、访问。这就是具有封装性的标准类的一般创建方式。\n\n## 关于构造方法\n\n构造方法是在对象使用关键字new实例化的时候被调用。\n\n\n\n构造方法与普通方法最大的区别在于：`构造方法`在实例化对象（new）的时候`只调用一次`，而`普通方法`是在实例化对象之后可以`随意调用多次`。\n\n\n\n在创建类中会默认生成**一个无参数的构造方法**，但是一旦**定义了一个构造方法**，无参构造方法将**不会自动生成**。一个类中`至少存在一个构造方法`。\n\n\n\n同样的，构造方法也属于方法，同样`可以重载`，一般在构建类的时候，会创建一个**无参数的构造的方法**以及一个**全参数的构造方法**。（如有需要，可以自行创建其他参数形式的构造方法）：\n\n``` java\npublic class Student {\n    private String name; // 姓名\n    private int age; // 年龄\n\n    public Student() { //无参数的构造方法\n    }\n\n    public Student(String name, int age) { //全参数的构造方法\n        this.name = name;\n        this.age = age;\n    }\n}\n```\n\n> 在进行构造方法重载时有一个编写建议：所有重载的构造方法按照参数的个数**由多到少**，或者是**由少到多**排列。\n\n## 关于匿名对象\n\n**没名字的对象**称为匿名对象，对象的名字按照之前的内存关系来讲在栈内存之中，而对象的具体内容在堆内存之中保存，这样，**没有栈内存指向堆内存空间**，就是一个匿名对象。\n\n先定义一个`Book`类：\n\n``` java\npublic class Book {\n    private String name;\n    private double price;\n\n    public Book() { //无参的构造方法\n    }\n\n    public Book(String name, double price) { //全参的构造方法\n        this.name = name;\n        this.price = price;\n    }\n\n    public void getInfo(){\n        System.out.println(\"书名：\" + name + \"，价格：\" + price);\n    }\n}\n```\n\n创建并使用匿名对象：\n\n``` java\npublic class Demo {\n    public static void main(String[] args) {\n         new Book(\"Java核心技术 卷Ⅰ\",149.00).getInfo(); //创建并使用匿名对象\n    }\n}\n```\n\n输出结果：\n\n``` java\n书名：Java核心技术 卷Ⅰ，价格：149.0\n```\n\n> 匿名对象由于没有对应的栈内存指向，所以`只能使用一次`，**一次之后就将成为垃圾，并且等待被GC回收释放**。\n","tags":["Java"],"categories":["Java基础"]},{"title":"Java基础---方法重载","url":"/post/cb581db9.html","content":"## 前言\n本文将介绍Java中方法重载的概念以及使用\n*******\n\n## 方法重载\n### 概念\n在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数的类型不同即可\n### 特点\n重载的方法`与返回值类型无关`，只看参数列表，且`参数列表必须不同`(参数个数或者参数类型)。调用时，根据方法参数列表的不同来区别\n\n## 示例\n写一个求和类：\n``` java\npublic class demo {\n    //两个整型数求和\n    public static void sum(int a,int b){\n        System.out.println(a+b);\n    }\n    //三个整形数求和\n    public static void sum(int a,int b,int c){\n        System.out.println(a+b+c);\n    }\n    //两个浮点数求和\n    public static int sum(double a,double b){\n        System.out.print((int) (a+b));\n        System.out.println(\"  (打印整数部分)\");\n        System.out.print(a+b);\n        System.out.println(\"  (打印浮点数)\");\n        return (int) (a+b);\n    }\n    \n    public static void main(String[] args) {\n        sum(10,20);\n        sum(10,20,30);\n        sum(11.1,22.2);\n    }\n}\n```\n输出结果：\n``` java\n30\n60\n33  (打印整数部分)\n33.3  (打印浮点数)\n```\n## 构造方法\n当一个对象被创建时候，构造方法用来`初始化该对象`。  \n构造方法和它所在类的名字相同，但构造方法`没有返回值`  \n\n例如：\n``` java\n// 一个简单的构造函数\nclass MyClass {\n    int x;\n\n    // 以下是构造函数\n    MyClass() {\n        x = 10;\n    }\n}\n```\n\n构造方法大体上可分为两类：\n+ `无参`数的构造方法\n+ `有参`数的构造方法\n\n在构建类的时候，若`没有重载`构造方法，则会自动创建`无参的构造方法`，否则将使用`重载后的构造方法`\n","tags":["Java"],"categories":["Java基础"]},{"title":"Java基础---数组","url":"/post/779ec391.html","content":"## 前言\n本文将介绍Java数组的创建与使用\n*******\n## 数组的概念\n\n数组是`相同类型`数据的`有序集合`。\n\n数组描述的是相同类型的若干个数据，按照一定的`先后次序排列`组合而成。其中，每一个数据称作一个数组元素，每个数组元素可以通过一个`下标来访问`他们\n\n## 数组的初始化\n### 动态初始化\n\n``` java\n//语法：\nint[] arr = new int[3];\n```\n\n``` java\n//可以拆分为两个步骤：\nint[] arr;\narr = new int[3];\n```\n\n### 静态初始化\n\n``` java\n//语法：\nint[] arr = new int[] {5,15,25};\n```\n\n``` java\n//可以拆分为两个步骤：\nint[] arr;\narr = new int[] {5,15,25};\n```\n\n``` java\n//静态初始化时可以简化书写：\nint[] arrayB = {5,15,25};\n```\n\n## 内存分析\n![arr.png](https://image.overlooked.top/img/java/arr.png)\n\n## 数组的特点\n+ 其`长度是确定的`。数组一旦被创建，它的大小就是不可以改变的\n\n+ 其元素必须是相同类型,`不允许出现混合类型`\n\n+ 数组中的元素可以是`任何数据类型`，包括基本类型和引用类型\n\n+ 数组变量属`引用类型`，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量\n\n+ 数组本身就是对象，Java中`对象是在堆中的`，因此数组无论保存原始类型还是其他对象类型,`数组对象本身是在堆中的`\n\n+ 关于数组边界：<br>⠀⠀下标的合法区间为`[0，length-1]`,如果越界就会出现异常<br>⠀⠀`ArraryIndexOutOfBoundsException`:数组下标越界异常\n\n## 数组的使用\n### for-each循环\n``` java\n//适用于打印输出，不适合修改元素\nfor(声明语句 : 表达式){\n\t//代码句子\n}\n```\n``` java\npublic class demo {\n\tpublic static void main(String[] args) {\n\t\tint [] numbers = {10, 20, 30, 40, 50};\n\t\tfor(int x : numbers ){\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n}\n```\n``` java\n//输出结果：\n10\n20\n30\n40\n50\n```\n## 数组做方法参数\n数组可以作为参数传递给方法\n``` java\n//示例：计算传入数组（整形）的和\npublic class demo {\n\tpublic static void sum(int[] array) {\n\t\tint s = 0;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\ts = s + array[i];\n\t\t}\n\t\tSystem.out.println(s); //10\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tsum(new int[]{1,2,3,4});\n\t}\n}\n//输出结果：\n10\n```\n## 数组做返回值\n``` java\n//示例：实现数组翻转\npublic class demo {\n\tpublic static int[] reverse(int[] list) {\n\t\tint[] result = new int[list.length];\n\t\tfor (int i = 0, j = result.length - 1; i < list.length; i++, j--) {\n\t\t\tresult[j] = list[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint[] result = reverse(new int[]{1,2,3,4});\n\t\tfor(int x : result){\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n}\n//输出结果：\n4\n3\n2\n1\n```\n## 多维数组\n``` java\n//示例：\npublic class demo {\n\tpublic static void main(String[] args) {\n\t\tint[][] arrays = new int[2][2]; //创建二维数组\n\t\tarrays[0][0] = 1;\n\t\tSystem.out.println(arrays[0][0]); //1\n\t}\n}\n//输出结果：\n1\n```\n","tags":["Java"],"categories":["Java基础"]},{"title":"Java基础---运算符及选择、循环结构","url":"/post/a5804ab6.html","content":"## 前言\n本文将介绍Java的运算符类型及选择、循环结构相关语法\n*******\n## 运算符\n### 算数运算符\n\n| **运算符** |                **描述**                |\n| :--------: | :------------------------------------: |\n| +⠀-⠀*⠀/⠀%  | 加、减、乘、除、取模（两数相除取余数） |\n| ++⠀⠀-- --  |         自增（+1）、自减（-1）         |\n|  \"\"⠀+⠀\"\"   |               连接字符串               |\n\n### 比较运算符\n| **运算符** |    **描述**    |\n| :--------: | :------------: |\n|     <      |    是否小于    |\n|     >      |    是否大于    |\n|     <=     | 是否小于或等于 |\n|     >=     | 是否大于或等于 |\n|     ==     |    是否相等    |\n|     !=     |    是否不等    |\n\n### 逻辑运算符\n\n| **运算符** |       **描述**       |\n| :--------: | :------------------: |\n|     &&     | 逻辑与，支持短路运算 |\n|    \\|\\|    | 逻辑或，支持短路运算 |\n|     !      |        逻辑非        |\n\n> *短路运算*：当 `false && xxx` 或 `true || xxx` 时，表达式`xxx`均不会被执行。\n\n### 位运算符\n\n| **运算符** |                     **描述**                     |\n| :--------: | :----------------------------------------------: |\n|     &      |                      按位与                      |\n|     \\|     |                      按位或                      |\n|     ^      |                     按位异或                     |\n|     ~      |                     按位取反                     |\n|     <<     |               按位左移，低位补`0`                |\n|     >>     | 按位右移，高位补`符号位`<br>`0(正数)`或`1(负数)` |\n|    >>>     |               按位右移，高位补`0`                |\n\n### 赋值运算符\n\n|           **运算符**           |           **描述**            |\n| :----------------------------: | :---------------------------: |\n|               =                |   将右边表达式结果赋给左边    |\n|     +=⠀、-=⠀、*=⠀、/=⠀、%=     | a⠀`x`=⠀b 相当于 x⠀=⠀a⠀⠀`x`⠀⠀b |\n| <<=⠀、>>=⠀、&=⠀、\\|=⠀、^=⠀、~= | a⠀`x`=⠀b 相当于 x⠀=⠀a⠀⠀`x`⠀⠀b |\n\n### 三元运算符\n\n格式：`数据类型 变量名称 = 判断条件 ? 表达式A : 表达式B;`\n\n等价于\n\n``` java\nif(判断条件){\n\t数据类型 变量名称 = 表达式A;\n}else{\n\t数据类型 变量名称 = 表达式B;\n}\n```\n\n### instanceof 运算符\n\n该运算符用于操作`对象实例`，检查该对象是否是一个特定类型（`类`类型或`接口`类型）\n\n使用格式：`(对象实例名) instanceof (class或interface类型)`\n\n例如：\n\n```java\nString name = \"James\";\nboolean result = name instanceof String;\n// 由于 name 是 String 类型，所以返回真\n```\n\n### 运算符优先级\n\n一般而言，`单目`运算符优先级`较高`，`赋值`运算符优先级`较低`。\n\n`算术`运算符优先级`较高`，`关系`和`逻辑`运算符优先级`较低`。\n\n多数运算符具有`左结合性`，`单目`运算符、`三目`运算符、`赋值`运算符具有`右结合性`\n\n| 优先级 |                            运算符                            | **结合性** |\n| :----: | :----------------------------------------------------------: | :--------: |\n|   1    |                         () 、[] 、{}                         |    -->     |\n|   2    |                   ! 、+ 、- 、~ 、++ 、- -                   |    <--     |\n|   3    |                          * 、/ 、%                           |    -->     |\n|   4    |                            + 、-                             |    -->     |\n|   5    |                        << 、>> 、>>>                         |    -->     |\n|   6    |               < 、<= 、> 、>= 、<br>instanceof               |    -->     |\n|   7    |                           == 、!=                            |    -->     |\n|   8    |                              &                               |    -->     |\n|   9    |                              ^                               |    -->     |\n|   10   |                              \\|                              |    -->     |\n|   11   |                              &&                              |    -->     |\n|   12   |                             \\|\\|                             |    -->     |\n|   13   |                             ? :                              |    <--     |\n|   14   | = 、<br>+= 、-= 、*= 、/= 、%= 、<br>&= 、\\|= 、^= 、~= 、<br><<= 、>>= 、>>>= |    <--     |\n\n> *注*：使用优先级为 1 的`小括号`可以`改变`其他运算符的`优先级`\n\n*******\n## 选择语句\n### if语句\n\n``` java\nif(布尔表达式){\n\t//如果布尔表达式为true将执行的语句\n}\n```\n\n### if…else语句\n\n``` java\nif(布尔表达式){\n\t//如果布尔表达式的值为true将执行的语句\n}else{\n\t//如果布尔表达式的值为false将执行的语句\n}\n```\n\n### if…else if…else语句\n\n``` java\nif(布尔表达式 1){\n\t//如果布尔表达式 1的值为true执行代码\n}else if(布尔表达式 2){\n\t//如果布尔表达式 2的值为true执行代码\n}else if(布尔表达式 3){\n\t//如果布尔表达式 3的值为true执行代码\n}else {\n\t//如果以上布尔表达式都不为true执行代码\n}\n```\n\n> *注*:表达式的判断`存在先后顺序`,若前面的成立,后面的将不会被执行\n\n### switch case 语句\n\n+ 用于判断的`变量类型`可以是： `byte`、`short`、`int` 或者 `char` , 从 Java SE 7 开始，switch 支持 `String` 类型\n+ `case 语句`中的值的`数据类型`必须与变量的数据类型`相同`，而且只能是`常量或者字面常量`\n+ `case 语句`执行后直至遇到`break`语句才会终止 , 若没有 `break 语句`出现，程序会继续执行下一条 `case 语句`，直到出现 `break 语句`\n+ `switch 语句`可以包含一个 `default 分支` , 一般放在`语句末尾` , 它将在没有 `case 语句`的值和变量值相等的时候执行 , 且不需要添加 `break 语句`\n\n``` java\nswitch(expression){\n\tcase value :\n\t\t//语句\n\t\tbreak; //可选\n\tcase value :\n\t\t//语句\n\t\tbreak; //可选\n\tcase value :\n\t\t//语句\n\t\tbreak; //可选\n\t//可以有任意数量的case语句\n\tdefault : //可选\n\t\t//语句\n}\n```\n\n\n\n*******\n## 循环语句\n### while循环\n\n```  java\n//格式：\nwhile(布尔表达式){\n\t//循环内容\n}\n//例如：\nint x = 1;\nwhile(x < 5){\n\tSystem.out.println(\"value of x : \" + x);\n\tx++;\n}\n//结果：\nvalue of x : 1\nvalue of x : 2\nvalue of x : 3\nvalue of x : 4\n```\n\n### do…while循环\n\n``` java\n//格式：\ndo {\n\t//代码语句,至少执行一次\n}while(布尔表达式);\n//例如：\nint x = 1;\ndo{\n\tSystem.out.println(\"value of x : \" + x);\n\tx++;\n}while(x < 5);\n//结果：\nvalue of x : 1\nvalue of x : 2\nvalue of x : 3\nvalue of x : 4\n```\n\n### for循环\n\n``` java\n//格式：\nfor(初始化; 布尔表达式; 更新) {\n\t//代码语句\n}\n//例如：\nfor(int x = 1; x < 5; x++){\n\tSystem.out.println(\"value of x : \" + x);\n}\n//结果：\nvalue of x : 1\nvalue of x : 2\nvalue of x : 3\nvalue of x : 4\n```\n\n### 增强for循环\n\n``` java\n//格式：\nfor(声明语句 : 表达式) {\n\t//代码语句\n}\n//例如：\nint [] numbers = {10, 20, 30, 40, 50};\nfor(int x : numbers){\n\tSystem.out.println(\"numbers : \" + x);\n}\n//结果：\n10\n20\n30\n40\n50\n```\n\n### break关键字\n\n> break 主要用在`循环语句`或者 `switch` 语句中，用来`跳出整个语句块`\n>\n> break 跳出`最里层`的循环，并且`继续执行`该循环`下面的`语句。\n\n``` java\npublic class demo {\n\tpublic static void main(String[] args) {\n\t\tint [] numbers = {10, 20, 30, 40, 50};\n\t\tfor(int x : numbers) {\n\t\t\t// x 等于 30 时跳出循环\n\t\t\tif(x == 30) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n}\n//结果：\n10\n20\n```\n\n### continue关键字\n\n> continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代\n>\n> 在 for 循环中，continue 语句使程序立即跳转到更新语句\n>\n> 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句\n\n``` java\npublic class demo {\n\tpublic static void main(String[] args) {\n\t\tint [] numbers = {10, 20, 30, 40, 50};\n\t\tfor(int x : numbers) {\n\t\t\t// x 等于 30 时直接进入下一循环\n\t\t\tif(x == 30) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n}\n//结果：\n10\n20\n40\n50\n```\n\n","tags":["Java"],"categories":["Java基础"]},{"title":"Java基础---基本数据类型","url":"/post/eafee158.html","content":"## 前言\n本文将介绍Java的八大基本数据类型\n*******\n## Java八大基本数据类型\n\n| **Java基本数据类型** | **类型** | **封装器类** | **描述**                                                     |\n| :------------------: | :------: | :----------: | ------------------------------------------------------------ |\n|         byte         | 整数类型 |     Byte     | 1字节，8位，容量：255，数据范围：(-128) ~ (127)              |\n|        short         | 整数类型 |    Short     | 2字节，16位，容量：65536，数据范围：(-32768) ~ (32767)       |\n|         int          | 整数类型 |   Integer    | 4字节，32位，容量：2³²-1，数据范围：(-2³¹) ~ (2³¹-1)         |\n|         long         | 整数类型 |     Long     | 8字节，64位，容量：2⁶⁴-1，数据范围：(-2⁶³) ~ (2⁶³-1)         |\n|        float         | 浮点类型 |    Float     | 4字节，32位，数据范围：`(-3.40E38) ~ (+3.40E38) `, 赋值时必须在数字后加上`f`或`F` |\n|        double        | 浮点类型 |    Double    | 8字节，64位，数据范围：`(-1.79E308) ~ (+1.79E308) `, 赋值时可以加`d`或`D`也可以不加 |\n|         char         |  字符型  |  Character   | 2字节，16位，存储`Unicode`码，用单引号赋值                   |\n|       boolean        |  布尔型  |   boolean    | 只有`true`和`false`两个取值                                  |\n\n``` java\nbyte a = 127;\nSystem.out.println(a); // 127\nbyte b = -128;\nSystem.out.println(b); // -128\n\nshort a = 32767;\nSystem.out.println(a); // 32767\nshort b = -32768;\nSystem.out.println(b); // -32768\n\nint a = 1;\nSystem.out.println(a); // 1\n\nlong a = 2;\nSystem.out.println(a); // 2\n\nfloat a = 1.2f;\nSystem.out.println(a); // 1.2\n\ndouble a = 1.4d;\nSystem.out.println(a); // 1.4\n\nchar a = 'c';\nSystem.out.println(a); // c\n\nboolean a = true;\nSystem.out.println(a); // true\n```\n## 数据类型转换规则\n\n+ `布尔型`和其它基本数据类型之间不能相互转换\n\n+ `byte`型可以转换为short、int、、long、float和double\n\n+ `short`可转换为int、long、float和double\n\n+ `char`可转换为int、long、float和double\n\n+ `int`可转换为long、float和double\n\n+ `long`可转换为float和double\n\n+ `float`可转换为double\n\n+ 使用`()`可进行强制类型转换，例如：\n\t``` java\n\tint a = 18;\n\tchar b = (char) a;\n\t```\n> 注意：类型强转可能会导致数据精度降低\n\n","tags":["Java"],"categories":["Java基础"]},{"title":"Android基础之Smali语法","url":"/post/d807e443.html","content":"## Android基础之Smali语法\n************************\n### 前言\n众所周知，java是一种面向对象的编程语言，一条狗，一部手机，一片树叶都可以是对象，它就像是对现实世界的映射。  \n\nAndroid代码一般是用java编写的，执行java程序一般需要用到`java虚拟机`，在Android平台上也不例外，但是出于性能上的考虑，并没有使用标准的JVM，而是使用专门的`Android虚拟机`（使用 C 或 C++ 代码实现，5.0以下为`Dalvik`，5.0以上为`ART`）。  \n\nAndroid虚拟机的可执行文件并不是普通的class文件，而是重新整合打包后生成的dex文件。dex文件`反编译`之后就是Smali代码，Smali实质上就是java字节码，所以说，Smali语言是Android虚拟机的`反汇编语言`。\n### 为什么要了解Smali\n1. 修改APK运行逻辑： 通过修改Smali代码，再重新编译打包成新的APK，可实现修改APP的运行逻辑，甚至逆向破解。\n2. 动态调试APK： 通常静态分析APK是不够的，如果需要彻底分析APK的执行逻辑，需要通过动态调试(常使用smalidea)来进行。\n3. 加强理解能力： Smali是介于Android虚拟机与java之间的语言，了解它有助于我们更好的理解代码的运行过程，从而写出性能更优的程序。\n### Smali简单入门\n举个例子，最简单的java代码：\n``` java\nSystem.out.println(\"Hello World\");\n```\n把它写成Smali大概就是：\n``` smali\n# 获取System类中的out字段，存到v0中\nsget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;\n# 把\"Hello World\"存到v1中\nconst-string v1, \"Hello World\"\n# 调用虚方法println，传入参数v0, v1\n# 相当于v0.println(v1)\ninvoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V\n```\n可以看到一句简单的Java代码会被分解成几句较为复杂的Smali代码，你可能会问为什么要搞这么复杂？因为Java是给人看的，Smali是给虚拟机执行的。  \n\n就像你叫一个人走过来，正常人他可以直接走过来，但如果是机器人，你就得告诉它先跨左脚，角度多少，然后右脚抬起后脚跟，重心往前......最后走完多少步停下，如果遇到转弯或者障碍的话就更复杂了。  \n\n没错，教机器做事就是得这么麻烦，所以同理Smali也是在和机器对话，因此比较麻烦。\n### Smali基本结构\n你可以在一个xxx.java中定义`多个类`（包括`匿名内部类`），但一个smali文件只能定义`一个类`，简单来看，其一般格式是：\n``` smali\n.class 修饰符 类名\n.super 父类的类名\n.source 源文件名\n\n# 接口\n.implements 接口类名\n\n# 注解\n.annotation xxxxxxx\n    xxxxxx\n.end annotation\n\n# 字段\n.field 描述符 字段名:字段类型\n\n# 方法\n.method 描述符 方法名(参数类型)返回类型\n    方法代码...\n.end method\n```\n1. 其中`修饰符`就是public、private、protected、static、final等，和Java中的差不多，另外对于类还有`interface`和`enum`来表示这个类是一个`接口`或者`枚举类`。\n2. Smali中的`类名`都是`L包名路径/类名;`，例如Android中的TextView类，它的包名是android.widget，如果你要在Smali中表示这个类，就要写成`Landroid/widget/TextView;`。\n3. `源文件名`就是编译这个类的java文件名，如`Main.java`，仅用于debug，因此删了也没影响。\n4. `接口`可以有0个或者多个，表示这个类实现了哪些接口，例如：\n``` smali\n.implements Landroid/view/View$OnClickListener;\n```\n5. `注解`可以有0个或者多个，注解的话就是Java代码中@XXX之类的代码，例如比较常见的`@Override`、`@Nullable`、`@NonNull`等，其实不了解注解也没关系，毕竟一般情况也用不上，只要在Smali中看到`annotation`时知道它是注解就行了；\n6. `字段`可以有0个或者多个，其语法为`.field 描述符 字段名:字段类型`，例如Java代码中定义了text字段：\n``` java\npublic String text;\n```\n其对应的Smali代码为：\n``` smali\n.field public text:Ljava/lang/String;\n```\n当一个字段是`static`和`final`（即静态常量）且它的类型是`基本类型`时，可以直接为它`赋值`：\n``` smali\n.field public static final ID:I = 0x7f0a0001\n```\n如果定义的字段`包含注解`，那么语法是：\n``` smali\n.field XXXXX\n    {注解列表}\n.end field\n```\n7. `方法`可以有0个或者多个，Smali中定义方法的语法是：\n``` smali\n.method 描述符 方法名(参数类型)返回类型\n    方法代码...\n.end method\n```\n其中`参数类型`可以有`0个或多个`，`返回类型`必须是`一个`，当要表达多个参数类型时，只需简单地将它们连接到一起，例如 `(int, int, String)` 表示为 `(IILjava/lang/String;)`  \n> 方法代码是最复杂的部分，将在后面的文章中慢慢介绍\n### Smali变量类型\n在Java中类型分为`基本类型`和`引用类型`\n`基本类型`共有9个，它们在Smali中的对应关系是：\n|  Java    | Smali |\n|  :----:  | :---: |\n|  void    |   V   |\n|  boolean |   Z   |\n|  byte    |   B   |\n|  short   |   S   |\n|  char    |   C   |\n|  int     |   I   |\n|  long    |   J   |\n|  float   |   F   |\n|  double  |   D   |\n> 其中除了`boolean对应Z`，`long对应J`，其它都是对应`首字母大写`，还是很好记的  \n\n而`引用类型`，在Smali中都是用`L包名路径/类名;`表示，例如Android中的TextView类，它的包名是android.widget，如果你要在Smali中表示这个类，就要写成`Landroid/widget/TextView;`  \n\nSmali中通过在类型前面加`[`来表示该类型的数组，例如`[I`表示`int[]`，`[Ljava/lang/String;`表示`String[]`，如果要表示多维数组，只需要`增加[的数量`，例如`[[I`表示二维数组`int[][]`\n### 调用方法\nSmali中必须以非常详细的形式指定要调用的方法，包括类名、方法名、参数类型和返回类型，其具体形式是：`类名->方法名(参数类型)返回类型`  \n例如：\n``` java\nSystem.out.println(\"Hello world\");\n```\n其中out是System的一个`静态字段`，它的`类型`是PrintStream，println是PrintStream中的`一个方法`，其`返回类型`为void，因此其调用方法为：\n``` smali\ninvoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V\n```\n### 引用字段\n和调用方法类似，在引用一个字段时，同样需要用非常详细的形式指定字段，其具体形式是：`类名->字段名:字段类名`  \n例如：\n``` java\nSystem.out.println(\"Hello world\");\n```\n在调用println方法前需要现将System类的字段out放到寄存器v0中，也就是下面这句代码：\n``` smali\nsget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;\n```\n后面那部分正是字段out的完整表达形式\n### 寄存器\n#### 普通寄存器\n如果你有看过一些Smali代码，你肯定会注意到有很多`v0`、`v1`、`v2`、`p0`、`p1`、`p2`之类的标识符，这些都代表了寄存器。  \n那么寄存器是什么？你可以把它认为是`变量`，或者是`暂时存放东西`的地方。  \n\n例如：\n有一个静态方法`static void abc(String s)`，如果你要在Java方法中调用这个方法，直接输入`abc(\"Hello\");`就行了。  \n而在Smali中，你不能直接把字符串参数传递给方法，你需要一个寄存器（比如`v0`），先把`\"Hello\"`放到`v0`中，然后再`调用abc方法`，并告诉它你需要的参数在`v0`里面：\n``` smali\n# 定义一个字符串常量\"Hello\"放到v0中\nconst-string v0, \"Hello\"\n# 调用abc方法，需要的参数放在v0中\ninvoke-static {v0}, LXX;->abc(Ljava/lang/String;)V\n```\n另外寄存器`v0`、`v1`、`v2`后面的数字也不是随便写的，需要在方法的开头用`.registers N`来指定`寄存器的数量`，然后才可以使用寄存器`v0到v(N-1)`。\n#### 参数寄存器\n上面说的都是普通寄存器`vN`，另外Smali还特意定义了一种参数寄存器`pN`，用于存放这个方法传入的参数的值。  \n如果一个方法有n个寄存器，有m个参数，那么`n必须大于等于m`，并且n个寄存器的后面m个是参数寄存器。  \n\n举个例子：  \n某个静态方法`static void abc(int, int, int)`，它一共有3个参数，如果它一共有5个寄存器（通过`.registers N`定义，`N不小于3`）：  \n|  普通寄存器  | 对应参数寄存器 |\n|   :----:    |     :---:     |\n|      v0     |               |\n|      v1     |               |\n|      v2     |       p0      |\n|      v3     |       p1      |\n|      v4     |       p2      |\n\n当调用`abc(11, 22, 33)`时，`p0`中的值初始化为`11`，`p1`中的值初始化为`22`，`p2`中的值初始化为`33`，`v0和v1不会被初始化`：\n|  普通寄存器  | 对应参数寄存器 |  初始化  |\n|   :----:    |     :---:     |  :---:  |\n|      v0     |               |         |\n|      v1     |               |         |\n|      v2     |       p0      |    11   |\n|      v3     |       p1      |    22   |\n|      v4     |       p2      |    33   |\n\n当把寄存器数量改成6(`.registers 6`)，寄存器就会变成下表所示：\n|  普通寄存器  | 对应参数寄存器 |  初始化  |\n|   :----:    |     :---:     |  :---:  |\n|      v0     |               |         |\n|      v1     |               |         |\n|      v2     |               |         |\n|      v3     |       p0      |    11   |\n|      v4     |       p1      |    22   |\n|      v5     |       p2      |    33   |\n\n思考一下，如果不使用参数寄存器，代码中全部用`vN`，那么改变寄存器数量后，你还得改多少代码？  \n#### 隐藏参数\n对于`非静态方法`，它的参数寄存器数量比实际参数`多了一个`，`p0`会固定用于表示当前类实例（Java中的`this`），从p1开始才是真正的参数，我们可以通过`Java2Smali`工具来验证一下，Java代码如下：\n``` java\npublic class Main{\n\n  static void test1(String s, int i){\n    System.out.println(s);\n    System.out.println(i);\n  }\n\n  void test2(String s, int i){\n    System.out.println(s);\n    System.out.println(i);\n  }\n\n}\n```\n`test1()`和`test2()`的唯一区别就是一个是`静态`一个是`非静态 `  \n\n`test1()`的Smali代码如下： \n``` smali\n.method static test1(Ljava/lang/String;I)V\n  .registers 3\n\n  .prologue\n  .line 4\n  sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;\n\n  invoke-virtual {v0, p0}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V\n\n  .line 5\n  sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;\n\n  invoke-virtual {v0, p1}, Ljava/io/PrintStream;->println(I)V\n\n  .line 6\n  return-void\n.end method\n```\n`test2()`的Smali代码如下： \n``` smali\n.method test2(Ljava/lang/String;I)V\n  .registers 4\n\n  .prologue\n  .line 9\n  sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;\n\n  invoke-virtual {v0, p1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V\n\n  .line 10\n  sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;\n\n  invoke-virtual {v0, p2}, Ljava/io/PrintStream;->println(I)V\n\n  .line 11\n  return-void\n.end method\n```\n两个方法都是依次打印出两个参数，`test1()`中打印第一个参数用的是`p0`，打印第二个参数用的是`p1`，对照之下`test2()`中则分别用的是`p1`和`p2`  \n\n那`test2()`中的`p0`真的代表`this`吗？我们也可以修改代码验证下：\n``` java\npublic class Main{\n\n  static void test1(String s, int i){\n    System.out.println(s);\n    System.out.println(i);\n  }\n\n  void test2(String s, int i){\n    System.out.println(this);\n  }\n\n}\n```\n`test2()`的Smali代码如下： \n``` smali\n.method test2(Ljava/lang/String;I)V\n  .registers 4\n\n  .prologue\n  .line 9\n  sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;\n\n  invoke-virtual {v0, p0}, Ljava/io/PrintStream;->println(Ljava/lang/Obiect;)V\n\n  .line 10\n  return-void\n.end method\n```\n由此便证实了，在Smali中对于`非静态方法`，会使用`p0`指代`this`(即`当前对象`)，`p1`为方法的`第一个参数`  \n\n而在`静态方法`中，`p0`为方法的`第一个参数`  \n### 调用方法的指令\nSmali语法中调用方法的指令一共有5条，分别是：\n|       指令名称      |     含义     |\n|       :----:       |    :---:     |\n|   invoke-virtual   |  调用虚方法   |\n|   invoke-direct    |  直接调用方法 |\n|   invoke-static    |  调用静态方法 |\n|   invoke-super     |  调用父类方法 |\n|   invoke-interface |  调用接口方法 |\n\n使用语法是：`invoke-xxxxxx {参数列表}, 类名->方法名(参数类型)返回类型`  \n\n所以当在Smali代码中看到`invoke开头`的指令，就可以直接确定这句代码用于`调用某个方法`，至于invoke-后面跟着的`单词`，取决于它要调用的`方法的类型`\n#### 调用虚方法\n虚方法其实是`Java多态`中的一个概念，大家应该知道Java中`子类可以重写父类中可被继承的非final方法`，调用这些方法时，都需要使用`invoke-virtual`指令，才能实现多态的特性，例如下面代码：  \n``` java\nObject obj = \"123\";\nobj.equals(\"456\");\n```\n这边调用equals方法的Smali代码为：\n``` smali\ninvoke-virtual {v0, v1}, Ljava/lang/Object;->equals(Ljava/lang/Object;)Z\n```\n表面上看是调用`Object的equals`方法，但是由于obj实际上是字符串“123”，而字符串类String中`重写了equals方法`，所以虚拟机最后调用的是`String的equals`方法  \n#### 直接调用方法\n由于调用虚方法时，虚拟机需要先查找该方法是否被重写，而对于那些无法被重写的方法，查找显得是在浪费时间，所以使用`invoke-direct`指令来`提高效率`，其通常用于`final方法`、`private方法`、`构造方法`  \n#### 调用静态方法\n这个没什么好说的，调用`static方法`时，就使用`invoke-static`  \n#### 调用父类方法\n在子类中，如果它已经`重写`了父类的XX方法，而又`想调用`父类的XX方法时，可通过`super.XX()`来调用，其对于的指令就是`invoke-super`  \n#### 调用接口方法\n这个很好理解，`invoke-xxxxxx {参数列表}, 类名->方法名(参数类型)返回类型`，如果类名对应的`类是个接口`，那么xxxxxx就得写`interface`  \n#### 补充\n上面的5条指令都有对应的`range扩展指令`，也就是：`invoke-virtual/range`、`invoke-direct/range`等  \n\n使用语法是：`invoke-xxxxxx/range {vN...vM}, 类名->方法名(参数类型)返回类型`，其中`N小于M`  \n\n其等价于：`invoke-xxxxxx{vN, vN+1,vN+2, ..., vM-2, vM-1, vM}, 类名->方法名(参数类型)返回类型`，其中`N小于M`  \n一般只会对`拥有很多个参数`的方法使用range指令，来`减少`生成的`代码体积`以及`提高运行效率`  \n### 更多语法\n以上只是初步的介绍了Smali基础语法，然而实际的Smali中还有许多其它的指令，例如`空指令`、`数据定义指令`、`数据移动指令`、`数据转换指令`、`数学运算指令`、`数组操作指令`、`实例操作指令`、`字段操作指令`、`比较指令`、`跳转指令`、`锁指令`、`异常指令`、`返回指令`等等。  \n\n当然，我们可能平时用Smali的时候并不多，因此粗略的了解一下便可以了，更多语法可参考下面的文档：  \nhttps://ctf-wiki.org/android/basic_operating_mechanism/java_layer/smali/smali/\n","tags":["Smali","Android","逆向"],"categories":["Android"]},{"title":"Android基础之apk的组成","url":"/post/963f24df.html","content":"## Android基础之apk的组成\n************************\n### 前言\n我们知道，生活中常见的手机品牌如华为、小米、三星、魅族、oppo、vivo等等均使用了`Android系统`（华为的鸿蒙系统也可兼容运行Android应用，苹果手机用的是IOS操作系统，不在讨论范围内）作为基础开发出了自家的ROM（鸿蒙及EMUI、MIUI、Flyme、Color OS、Funtouch OS等），这意味着它们可以运行Android的APP。而作为Android开发者，我们通常需要了解并掌握的便是Android开发需要的语言（`java`、`kotlin`）以及Android提供给开发者使用的`SDK`（Software Development Kit的缩写，译作软件开发工具包）和开发工具`Android Studio`。  \n\n那么一个Android的APP是怎样产生的呢？简单来讲，在APP开发经过需求分析、功能划分后，开发者利用Android Studio编写应用、经过编译构建后便可生成一个可安装调试的`debug`版apk文件，经过实机（模拟器）测试，修改调试，确认达到了预期目标后再通过正式的签名文件生成`release`版的apk文件，然后上传到手机应用市场，我们便可以下载安装各种APP来使用了。\n### apk的结构\nAPK是AndroidPackage的缩写，即Android安装包，其本质是一个`zip压缩包`，如果你有用过7zip、winRAR查看过apk文件，你将会发现如下图所示的目录结构：  \n![1.png](https://image.overlooked.top/img/apk/1.png)  \n1. assets目录：  存放需要打包到APK中的静态文件\n2. lib目录：  程序依赖的Native库\n3. META-INF目录：  存放应用程序签名和证书的目录\n4. res目录：  存放应用程序的资源\n5. AndroidManifest.xml：  应用程序的配置文件\n6. classes.dex：  dex可执行文件\n7. resources.arsc：  资源配置文件\n\n作为参考，一个典型的apk文件包含以下内容：\n![2.png](https://image.overlooked.top/img/apk/2.png)  \n### apk各文件作用\n#### AndroidManifest.xml\nAndroid应用的`配置清单文件`，它向Android系统介绍了这个应用的很多配置信息，系统可以根据这个文件在相当程度上了解这个应用的一些信息。该文件是每个应用都`必须定义和包含`的，它描述了应用的名字、版本、权限、引用的库文件等等信息，如要把apk上传到Google Market上，也要对这个xml做一些配置。\n> 在apk中的AndroidManifest.xml是经过压缩的，可以通过AXMLPrinter2或apktool等工具进行反编译查看。\n#### META-INF目录\nMETA-INF目录下存放的是`签名信息`，用来保证`apk包的完整性`和`系统安全`。没有签名的应用是不被系统认可的，也无法安装到手机中。  \nAndroid SDK在对APK进行打包的时候，会把APK中全部文件的完整信息保存到这里，这样应用在安装的时候会进行`完整性校验`，确保APK的文件不会被篡改，大大提升了应用和系统的安全性与完整性。META-INF目录下有`CERT.RSA`、`CERT.SF`和`MANIFEST.MF`这几个文件，其中的`CERT.RSA`文件记录了开发者的`私钥`对APK签名后的信息，`MANIFEST.MF`文件则保存了整个APK中所有文件的`SHA-1`进行`base64编码`后的值，`CERT.SF`则与`MANIFEST.MF`差不多，包括了后者所有的信息，然后又加入了`MANIFEST.MF`文件的`SHA-1`并进行`base64编码`的值。\n#### res目录\n存放`各种资源文件`的目录。这个目录中的所有文件，最终会被`映射`到Android工程中的`R文件`中，生成对应的`int型的ID`，在程序中访问这些资源文件的时候，直接使用资源的ID就能进行调用了。\nres目录下还包含着多个子文件夹：\n+ anmi中存放着动画文件\n+ drawable中存放着一些图片资源\n+ layout中存放的是布局文件\n+ menu则是自定义菜单的项\n+ raw目录中的文件则是可以直接复制到设备中的文件，不会被编译\n+ values中存放着一些特殊的值以供调用\n+ colors.xml记录的是自定义的颜色\n+ dimens.xml记录的是自定义的尺寸\n+ strings.xml则是自定义的字符串常量值\n+ styles.xml定义了一些样式\n+ 其他文件\n#### lib目录\n这个目录中存放着应用依赖的`native库文件`，这些以`.so`结尾的文件是用`C或者C++`语言编写的，一个简单的Android应用可能并不需要这些库，但一个功能全面而又追求性能的应用是不可能无视这个目录的，譬如`图片处理、网络处理、音视频处理`等一些对性能要求很高的功能，单纯依靠Java会十分吃力，性能更加强大而且更加接近底层的`C/C++`就是更合适的选择了。  \n> **注：**一般的Android开发是使用`Java`、`Kotlin`调用SDK接口，SDK的`底层实现`其实也是调用的`.so`文件，若要自己生成`.so`文件以供调用则需要使用`C/C++`文件进行`交叉编译`后通过`JNI(Java Native Interface)`进行调用。  \n\n根据手机CPU的架构，lib库大体上可以分为4种：`ARM`、`ARM-V7`、`MIPS`和`X86`，分别对应着4种CPU架构，在lib目录里则分别是`armeabi`、`armeabi-v7a`、`mips`和`x86`一共4个目录。每个目录中的.so库名字都是一样的，实际上功能也是相同的，它们只是`为了适配不同架构的CPU`而存在。实际上，市面上的手机几乎全都是ARM架构的，所以大多数情况下我们只需要有`armeabi`和`armeabi-v7a`两种类型的库就足够了。\n#### assets目录\n跟res目录有点相似，但实际上二者还是有区别的。res目录中的文件会`映射到R文件`中，每个资源文件都有自己的ID，而assets中的文件则直接使用`AssetManager类`通过文件路径进行访问，而且assets目录你可以添加`任意深度的子目录`，这一点会比较方便管理和归类文件。相比较之下，res目录目前不能支持更深级的子目录。\n#### classes.dex文件\nclasses.dex是Android系统的`可执行文件`，包含应用程序的全部操作指令以及运行时数据。  \nAndroid使用`dalvik虚拟机`(注意，Android5.0以后使用`ART`取代了dalvik，可简单认为是dalvik的升级版)运行java代码，但由于dalvik是一种`针对嵌入式设备`而特殊设计的java虚拟机，所以dex文件与标准的class文件在结构设计上有着本质的区别，不论是文件结构还是opcode都不一样。\n在程序编译过程中，java源文件先被编译成class文件，然后通过dx工具将多个class文件整合为一个dex文件，这样的文件结构使得各个类能够共享数据，从而提高程序的运行效率。  \n> **注：**其实dex也支持分包使用，分包后的文件需要重命名为classes`数字序号`.dex，如上文图片所示。\n#### resources.arsc\n编译后的二进制资源文件的`索引`，记录了资源文件（即res目录中的文件）和资源文件ID的`映射关系`，这样程序运行的时候就可以根据资源的ID获取到相应的资源了。\n### debug版与release版的区别\nDebug通常称为`调试版本`，通过一系列编译选项的配合，编译的结果通常`包含调试信息`，而且`不做任何优化`，以为开发人员提供强大的应用程序调试能力。\nRelease通常称为`发布版本`，是为用户使用的，一般客户不允许在发布版本上进行调试。所以`不保存调试信息`，同时，它往往进行了`各种优化`，以期达到代码最小和速度最优。为用户的使用提供便利。\n","tags":["Android","apk"],"categories":["Android"]},{"title":"NAT原理以及UDP穿透","url":"/post/67b35c1c.html","content":"## NAT 原理以及 UDP 穿透\n\n本文详细介绍了 NAT 的原理，并以此作为基础介绍了 UDP 穿透的原理和实现。\n\n### 一、NAT基础和分类\n\nNAT(Network Address Translation)全称为「网络地址转换」，用于为了解决 IPv4 地址短缺的问题。NAT 可以将私有 IP 地址转换为公有 IP 地址，以便多台内网主机只需要共用一个公有 IP 地址，便可以正常与互联网进行通信。\n\n#### NAT 可以分为两大类：\n\n1. 基础NAT：网络地址转换(Network Address Translation)\n2. NAPT：网络地址端口转换(Network Address Port Translation)\n   ![nat_1.png](https://image.overlooked.top/img/nat/nat_1.png)\n\n#### 1. 基础NAT\n\n基础 NAT 仅对网络地址进行转换，要求对每一个当前连接都要对应一个公网IP地址，所以需要有一个公网 ip 池；基础 NAT 内部有一张 NAT 表以记录对应关系，其映射关系如下：\n\n|    内网ip    | 外网ip |\n| :-----------: | :-----: |\n|  192.168.1.1  | 1.2.3.4 |\n| 192.168.1.12 | 1.2.3.5 |\n| 192.168.1.123 | 1.2.3.6 |\n\n> 基础 NAT 又分为：静态 NAT 和 动态 NAT ，其区别在于：静态要求内网ip和外网ip存在固定的一 一对应关系，而动态不存在这种固定的对应关系。\n\n#### 2. NAPT\n\nNAPT 需要对网络地址和端口都进行转换，这种类型允许多台主机共用一个公网 ip 地址，NAPT 内部同样有一张 NAT 表，并标注了端口，以记录对应关系，其映射关系如下：\n\n|      内网ip      |    外网ip    |\n| :---------------: | :----------: |\n| 192.168.1.10:1025 | 1.2.3.4:1025 |\n| 192.168.1.11:3333 | 1.2.3.5:3344 |\n| 192.168.1.12:7788 | 1.2.3.6:2000 |\n\n> NAPT又分为：锥型 NAT 和 对称型 NAT ，其对于映射关系有不同的权限限制。\n> 锥型 NAT 在网络拓扑图上像圆锥，而对称型 NAT 在网络拓扑图上呈现对称性。\n\n### 二、NAPT分类\n\n总的来说， NAPT 可分为四种类型：1.完全锥型，2.受限锥型，3.端口受限锥型，4.对称型。\n\n> 目前市场上常见的都是 NAPT 类型，我们常说的 NAT 一般也是特指 NAPT ，故下文均用 NAT 代表 NAPT\n\n#### 1. 完全锥型\n\n从同一个内网地址端口(`192.168.1.1:7777`)发起的请求都由 NAT 转换成公网地址端口(`1.2.3.4:10000`)。\n而内网地址端口(`192.168.1.1:7777`)可以收到任意外部主机发到公网地址端口(`1.2.3.4:10000`)的数据报。\n![nat_2.png](https://image.overlooked.top/img/nat/nat_2.png)\n\n#### 2. 受限锥型\n\n> 受限锥型也称地址受限锥型，其在完全锥型的基础上，对 ip 地址进行了限制。\n\n从同一个内网地址端口(`192.168.1.1:7777`)发起的请求都由 NAT 转换成公网地址端口(`1.2.3.4:10000`)，其访问的服务器为(`8.8.8.8:123`)。\n只有当(`192.168.1.1:7777`)主动向(`8.8.8.8:123`)发送一个报文后，(`192.168.1.1:7777`)才可以收到(`8.8.8.8:xxxx`)发往(`1.2.3.4:10000`)的报文，进而发送给(`192.168.1.1:7777`)，而其它地址如(`9.9.9.9:456`)发送的报文则会被 NAT 丢弃。\n![nat_3.png](https://image.overlooked.top/img/nat/nat_3.png)\n\n#### 3. 端口受限锥型\n\n> 端口受限锥型，是在受限锥型的基础上，对端口也做了进一步的限制。\n\n从同一个内网地址端口(`192.168.1.1:7777`)发起的请求都由 NAT 转换成公网地址端口(`1.2.3.4:10000`)，其访问的服务器为(`8.8.8.8:123`)。\n只有当(`192.168.1.1:7777`)主动向(`8.8.8.8:123`)发送一个报文后，(`192.168.1.1:7777`)才可以收到(`8.8.8.8:123`)发往(`1.2.3.4:10000`)的报文，进而发送给(`192.168.1.1:7777`)，而其它地址端口如(`8.8.8.8:456`)和(`9.9.9.9:456`)发送的报文则会被 NAT 丢弃。\n![nat_4.png](https://image.overlooked.top/img/nat/nat_4.png)\n\n#### 4. 对称型\n\n> 在对称型 NAT 中，只有来自于同一个内网地址端口、且针对同一目标地址端口的请求才会被 NAT  转换至同一个公网地址端口，否则的话， NAT 将为之分配一个新的公网地址端口。\n\n例如：内网地址端口(`192.168.1.1:7777`)发起请求到(`8.8.8.8:123`)，由 NAT 转换成公网地址端口(`1.2.3.4:10000`)，随后内网地址端口(`192.168.1.1:7777`)又发起请求到(`9.9.9.9:456`)，则 NAT 将分配新的公网地址端口(`1.2.3.4:20000`)，而其它地址端口如(`8.8.8.8:456`)和(`9.9.9.9:123`)发送的报文则会被 NAT 丢弃。\n![nat_5.png](https://image.overlooked.top/img/nat/nat_5.png)\n\n> 对称型 NAT 其实也可以理解为升级版的端口受限锥型 NAT ，其在端口受限锥型的基础上，增加了公网地址端口一对一分配功能。\n> 可以这么说，在锥型 NAT 中映射关系和目标地址端口无关，而在对称型 NAT 中则有关。锥型 NAT 正因为其于目标地址端口无关，所以网络拓扑是圆锥型的。\n\n如下图所示，在锥型 NAT 中对于同一个内网地址端口来说其公网地址端口(`1.2.3.4:10000`)是固定的。\n![nat_6.png](https://image.overlooked.top/img/nat/nat_6.png)\n\n### 三、NAT的工作流程\n\n按照上文的描述，我们可以很好的理解 NAT 对传输层协议(TCP/UDP)的处理，这里举例来更加深入的理解 NAT 的原理。\n\n#### 1. 发送数据\n\n当一个 TCP/UDP 的请求 `( 192.168.1.1:7777 => 8.8.8.8:123 )`到达 NAT 网关( `1.2.3.4` )时，由 NAT 修改报文的源地址和源端口以及相应的校验码，随后再发往目标：\n\n```TEXT\n192.168.1.1:7777 => 1.2.3.4:10000 => 8.8.8.8:123\n```\n\n#### 2. 接收数据\n\n随后( `8.8.8.8:123` )返回响应数据到( `1.2.3.4:10000` )， NAT 查询映射表，修改目的地址和目的端口以及相应的校验码，再将数据返回给真实的请求方：\n\n```TEXT\n8.8.8.8:123 => 1.2.3.4:10000 => 192.168.1.1:7777\n```\n\n#### 3. 其他协议\n\n对于常见的网络协议来说，除了 TCP/UDP 协议外还有 ICMP 等特殊协议，以及自定义实现的私有协议。例如 ICMP 协议工作在 IP 层，没有端口信息，NAT 以 ICMP 报文中的 `identifier` 作为标记，以此来判断这个报文是内网哪台主机发出的。下图为 `Cisco Packet Tracer` 下，在客户端发起 `TCP/UDP/ICMP` 请求后的 `NAT translations`：\n![nat_7.png](https://image.overlooked.top/img/nat/nat_7.png)\n\n> 当然还有一些特殊的协议，比如 FTP 协议，当请求一个文件传输时，主机在发送请求的同时也通知对方自己想要在哪个端口接受数据，NAT 必须进行特殊处理才能支持这种通信机制。\n> 在 NAT 中有一个应用网关层(Application Layer Gateway, ALG)，以此来统一处理这些协议问题。\n\n#### 4. 映射老化时间\n\n建立了 NAT 映射关系后，这些映射什么时候失效呢？\n\n不同协议有不同的失效机制，比如 TCP 的通信在收到 RST 过后就会删除映射关系，或 TCP 在某个超时时间后也会自动失效。而 ICMP 在收到 ICMP 响应后就会删除映射关系，当然超时后也会自动失效。具体的实现还和各个厂商有关系。\n\n### 四、NAT类型探测\n\n探测 NAT 的类型是 NAT 穿透中的第一步，我们可以通过客户端和两个服务器端的交互来探测 NAT 的工作类型，以下是来源于 STUN 协议(https://tools.ietf.org/html/rfc3489) 的探测流程图，在其上添加了一些标注：\n![nat_8.png](https://image.overlooked.top/img/nat/nat_8.png)\n\n如图所示，我们可以整理出：\n1. 客户端使用同一个内网地址端口分别向主服务器和协助服务器(不同IP)发起 UDP 请求，主服务器获取到客户端出口地址端口后，返回给客户端，客户端对比自己本地地址和出口地址是否一致，如果是则表示处于 `Open Internet` 中。  \n2. 协助服务器同样也获取到了客户端出口地址端口，将该信息转发给主服务器，同样将该信息返回给客户端，客户端对比两个出口地址端口(1、主服务器返回的，2、协助服务器返回的)是否一致，如果是则表示处于 `Symmetric NAT` 中。\n3. 客户端再使用`不同的内网地址端口`分别向主服务器和协助服务器(不同IP)发起 UDP 请求，主服务器和协助服务器都可以获得一个新的客户端出口地址端口，协助服务器将客户端出口地址端口转发给主服务器。\n4. 主服务器向协助服务器获取到的客户端出口地址端口发送 UDP 数据，客户端如果可以收到数据，则表示处于 `Full-Cone NAT` 中。\n5. 主服务器使用另一个端口，向主服务器获取到的客户端出口地址端口发送 UDP 数据，如果客户端收到数据，则表示处于 `Restricted NAT` 中，否则处于 `Restricted-Port NAT` 中。\n\n> 实际网络往往都更加复杂，比如：防火墙、多层 NAT 等原因，会导致无法准确的探测 NAT 类型。\n\n当然，实际上我们并不需要手动实现上述过程，我们有现成的NAT测试工具可用：  \n[GitHub：NatTypeTester](https://github.com/HMBSbige/NatTypeTester \"NatTypeTester\")  \n下载地址：https://github.com/HMBSbige/NatTypeTester/releases/download/3.4/NatTypeTester.exe  \n打开软件，点击左侧菜单栏RFC 3489：\n![nat_9.png](https://image.overlooked.top/img/nat/nat_9.png)\n\n上方菜单栏中可选择STUN服务器，大陆境内推荐使用QQ和MIWIFI：\n![nat_10.png](https://image.overlooked.top/img/nat/nat_10.png)\n\n点击TEST即可得到测试结果，如上图的FullCone即为NAT1 (完全锥型)\n\n### 五、UDP穿透\n\n在 NAT 的网络环境下，P2P 网络通信需要穿透 NAT 才能够实现。在熟悉 NAT 原理过后，我们就可以很好的理解如何来进行 NAT 穿透了。NAT 穿透的思想在于：如何复用 NAT 中的映射关系？\n\n在`锥型NAT`中，同一个内网地址端口访问不同的目标只会建立`一条映射关系`，所以可以复用，而`对称型NAT`不行。同时，由于 TCP 工作比较复杂，在 NAT 穿透中存在一些局限性，所以在实际场景中 UDP 穿透使用得更广泛一些，这里我们详细看看 UDP 穿透的原理和流程。\n\n> 我们以 `Restricted-Port NAT` 类型作为例子，因为其使用得最为广泛，同时权限也是最为严格的，在理解 `Restricted-Port NAT` 类型穿透后，`Full-Cone NAT` 和 `Restricted NAT` 就触类旁通了；  \n> 在实际网络场景下往往都是非常复杂的，比如：防火墙、多层NAT、单侧NAT，这里我们选择了两端都处于一层 NAT 的场景来进行演示讲解，可以让我们更容易的进行理解。  \n\n在我们的演示环境下，有 `PC1，Router1，PC2，Router2，Server` 五台设备；公网服务器用于获取客户端实际的出口地址端口，UDP 穿透的流程如下：  \n\n1. `PC1(192.168.1.1:7777)` 发送 UDP 请求到 `Server(9.9.9.9:1024)`，此时 Server 可以获取到 PC1 的出口地址端口(也就是 Router1 的出口地址端口) `1.2.3.4:10000`，同时 Router1 添加一条映射 `192.168.1.1:7777 <=> 1.2.3.4:10000 <=> 9.9.9.9:1024`  \n2. `PC2(192.168.2.1:8888)` 同样发送 UDP 请求到 Server，Router2 添加一条映射 `192.168.2.1:8888 <=> 5.6.7.8:20000 <=> 9.9.9.9:1024`  \n3. Server 将 PC2 的出口地址端口(`5.6.7.8:20000`) 发送给 PC1  \n4. Server 将 PC1 的出口地址端口(`1.2.3.4:10000`) 发送给 PC2  \n5. PC1 使用相同的内网地址端口(`192.168.1.1:7777`)发送 UDP 请求到 PC2 的出口地址端口(`Router2 5.6.7.8:20000`)，此时 Router1 添加一条映射 `192.168.1.1:7777 <=> 1.2.3.4:10000 <=> 5.6.7.8:20000`，与此同时 Router2 没有关于 `1.2.3.4:10000` 的映射，这个请求将被 Router2 丢弃  \n6. PC2 使用相同的内网地址端口(`192.168.2.1:8888`)发送 UDP 请求到 PC1 的出口地址端口(`Router1 1.2.3.4:10000`)，此时 Router2 添加一条映射 `192.168.2.1:8888 <=> 5.6.7.8:20000 <=> 1.2.3.4:10000`，与此同时 Router1 有一条关于 `5.6.7.8:20000` 的映射(上一步中添加的)，Router1 将报文转发给 PC1(`192.168.1.1:7777`)  \n7. 在 Router1 和 Router2 都有了对方的映射关系，此时 PC1 和 PC2 通过 UDP 穿透建立通信。  \n\n![nat_11.png](https://image.overlooked.top/img/nat/nat_11.png)\n\n### 六、拓展研究\n在实践了以上步骤后，我们对 锥型NAT 下的 UDP 穿透已经有了大致的了解，那我们接着再拓展研究一下「其他场景」。  \n\n#### 1. Symmetric NAT可以穿透吗？  \n根据 `Symmetric NAT` 的特性我们可以知道当请求的目标端口地址改变后，会创建新的一对映射关系，我们无法知晓新的映射关系中的端口号；但是在实际场景下，部分路由器对于 `Symmetric NAT` 的生成算法过于简单，新的端口可能呈现于：递增、递减、跳跃等特征，所以这种条件下，我们可以基于端口猜测，来穿透 `Symmetric NAT`。  \n> 如果两端的 `Symmetric NAT` 路由器是已知的，我们可以直接逆向分析映射生成算法，即可准确预测端口号。  \n\n#### 2. TCP穿透有哪些难点？\nTCP 穿透的流程基本和 UDP 穿透一样。  \n\n在标准 socket 规范中，UDP 可以允许多个 socket 绑定到同一个本地端口，但 TCP 不行，在 TCP 中我们不能在同一个端口上既 `listen` 又进行 `connect`；不过在部分操作系统下 socket 提供了端口复用选项(`SO_REUSEADDR / SO_REUSEPORT`) 可以允许 TCP 绑定多个 socket。  \n\n在使用端口复用选项后，TCP 就按照 UDP 穿透的流程一样借助公网服务器然后向对端发送 `syn` 报文了，其中靠后的 `syn` 报文就可以正确穿透完成 TCP 握手并建立连接。\n\n但是在`实际场景`下还有诸多的阻碍，不同厂商的 NAT 实现机制有一些差异，比如某些针对 TCP 的实现有：  \n\n1. 对端 NAT 在接收到 `syn` 由于没有找到映射而返回 `RST` 报文，而本端 NAT 在接收到 `RST` 报文后删除了此条映射  \n2. 由于主机生成的 `syn` 报文中的 `seq` 序号为随机值，如果 NAT 开启了 `syn` 过滤，对于没有标记过的 `seq` 的报文将直接丢弃  \n3. 其它不可控因素等等  \n#### 3. 无第三方服务器的穿透\n目前可行的一种不需要第三方服务器实现 NAT 穿透的项目：  \nhttps://github.com/samyk/pwnat  \n\n文中作者先提出了一种便于理解的网络拓扑，客户端位于公网，服务器位于 NAT 下，我们必须预先知道服务器的公网地址；在这个方法下，服务器不断的向外部未分配的地址发送 `ICMP(ECHO REQUEST)` 消息，服务器端的 NAT 将保留一条 ICMP 响应的映射，由于目的地址未分配所以没有设备会响应服务器发出的请求，此时由客户端发送一条伪装的 `ICMP(DESTINATION UNREACHABLE)` 给服务器，服务器可以收到该条消息并从中获取到客户端的地址；随后便可以根据预先约定的端口进行穿透并通信了。  \n\n但是如果客户端也位于 NAT 下呢，由于 NAT 可能会更改源端口信息(不同厂商的NAT实现不同)，导致无法向上文一样使用预设端口进行通信，所以这里需要和 `Symmetric NAT` 穿透一样进行端口猜测。  \n\n### 七、总结\n本文从 NAT 原理出发，详细介绍了不同 NAT 类型的工作流程和原理，在此基础上我们深入学习和实现了 锥型NAT 的穿透，并拓展介绍了一些特殊的穿透场景。  \n\nNAT 的出现极大的缓解了 IPv4 地址短缺，同时也延迟了 IPv6 的推广，但 IPv6 是大势所趋，未来使用 NAT 的场景可能会慢慢减少；但无论怎样， NAT 的原理和策略都非常值得我们学习，比如：  \n1. NAT 是一个天然的防火墙，  \n2. NAT 其实可以看作是代理服务器，  \n3. NAT 可以作为负载均衡服务器，  \n4. 等等。\n","tags":["NAT","TCP","UDP","计算机网络","网络安全"],"categories":["计算机网络"]},{"title":"Markdown基本语法","url":"/post/5d36ff15.html","content":"## Markdown的基本语法\n**************************\n### 标题\n> **注**：一共有6个级别的标题\n```\n# h1\n## h2\n### h3\n#### h4\n##### h5\n###### h6\n```\n**************************\n### 引用\n```\n> 这里是引用代码\n>> 可以多级嵌套\n```\n> 这里是引用代码\n>> 可以多级嵌套\n**************************\n### 段落\n一行文字结束后加两个空格然后回车，或相邻两个段落之间空一行\n**************************\n### 字体\nMarkdown 可以使用以下几种字体：\n```\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n```\n*斜体文本*  \n_斜体文本_  \n**粗体文本**  \n__粗体文本__  \n***粗斜体文本***  \n___粗斜体文本___\n**************************\n### 分割线\n三个或者三个以上的 - 或者 * 都可以\n```\n---\n***\n```\n**************************\n### 代码展示\n使用一对 ``` 将代码块包围起来，并指定一种语言(也可以不指定)\n```\n```代码语言\n在这里写你的代码\n```⠀\n```\n单行代码直接用一对 ` 将其包围就好，也可以在行内进行标记\n**************************\n### 超链接\n```\n[超链接名](超链接地址 \"超链接title\")\n例如：\n[百度一下](https://www.baidu.com \"百度一下\")\n```\n[百度一下](https://www.baidu.com \"百度一下\")\n**************************\n### 图片\n```\n![图片alt](图片地址 \"图片title\")  \n\n注：图片alt就是显示在图片下面的文字，相当于对图片内容的解释。\n    图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加\n```\n例如：`![1.png](https://image.overlooked.top/img/cover/1.png)`\n![1.png](https://image.overlooked.top/img/cover/1.png)\n**************************\n### 列表\n无序列表：用 - + * 任何一种都可以  \n有序列表：为 数字.\n列表嵌套：上一级和下一级之间敲三个空格即可\n**注**：符号后面有一个空格符\n```\n- 无序列表内容\n+ 无序列表内容\n* 无序列表内容\n\n1. 有序列表内容\n2. 有序列表内容\n3. 有序列表内容\n\n* 外层无序列表\n   1. 内层有序列表\n   2. 内层有序列表\n```\n- 无序列表内容\n+ 无序列表内容\n* 无序列表内容\n\n1. 有序列表内容\n2. 有序列表内容\n3. 有序列表内容\n\n* 外层无序列表\n   1. 内层有序列表\n   2. 内层有序列表\n**************************\n### 表格\n```\n表头|表头|表头\n---|:--:|---:\n内容|内容|内容\n内容|内容|内容\n\n注：\n    第二行分割表头和内容。\n    - 有一个就行，为了对齐，多加了几个\n    文字默认居左\n    -两边加：表示文字居中\n    -右边加：表示文字居右\n注：原生的语法两边都要用 | 包起来\n```\n例如：\n```\n|    a    |       b       |    c       |\n|:-------:|:------------- | ----------:|\n|   居中  |     左对齐     |   右对齐   |\n|=========|===============|============|\n| 其余内容 |    其余内容   |   其余内容  |\n```\n|    a    |       b       |    c       |\n|:-------:|:------------- | ----------:|\n|   居中  |     左对齐    |   右对齐   |\n|=========|===============|============|\n| 其余内容 |    其余内容   |   其余内容  |\n**************************\n### 表情包\n进入网站 https://www.emojiall.com/zh-hans/copy\n然后直接复制表情就好🙃🙃🙃(灰常简单😜😜)\n**************************\n### 空格字符\n输入 `&nbsp;` 即可，注意是英文分号\n当然，也可以使用中文的全角空格字符：【　】\n**************************\n### 锚点\n+ 跳转链接：\n```\n[跳转链接（说明文字）]（#jump）\n```\n+ 跳转位置：\n```\n<span id = \"jump\">跳转位置（说明文字）</span>\n```\n**************************\n### 上、下标\nMarkdown兼容HTML语法，所以直接用HTML语法中的上、下标来实现：\n```\nH<sub>2</sub>O \n2×10<sup>8</sup>\n```\nH<sub>2</sub>O \n2×10<sup>8</sup>\n**************************\n### 结语：\n更多语法请参考以下链接：\nhttps://markdown.com.cn/intro.html\nhttps://www.runoob.com/markdown/md-tutorial.html\n**************************\n","tags":["Markdown"],"categories":["Markdown"]}]